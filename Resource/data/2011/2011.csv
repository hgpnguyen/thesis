Long Nguyễn,1,11/6/2011,Nộp bài cho rồi,"Thầy đi Thái rồi, để lại nhiều thắc mắc bỏ ngỏ. Sinh viên tự mò và tự đưa ra chuẩn cho mình. Thôi thì cũng tới hạn rồi, thời gian còn lại chắc thầy cũng không xuất hiện đâu. Nộp bài luôn cho khoẻ. Dĩ nhiên thêm phần cầu trời nữa."
Sieutoc,1,11/6/2011,Re:Nộp bài cho rồi,OK đồng ý. Mình cũng nộp bài luôn đây. Ngày mai con đi GSC nữa.
Quái,1,12/21/2011,Chia cho 0?!?,"Các bạn cho mình hỏi có sử lý trường hợp chia cho 0 không vậy?? Còn nữa, về việc ép kiểu, thì như thế nào thì đúng??? Integer = real => OK real = integer => faild hay là, Integer = real => faild real = integer => OK"
Bernkastel 奇跡の魔女,1,12/21/2011,Re:Chia cho 0?!?,"Làm cái gì có trong đặc tả thôi bạn, còn cái real int thì ""In Crazy, just the integer can coerce to the real."" - real = integer đúng."
V For,1,12/21/2011,Re:Lỗi của String,"var a: string; procedure duyTien(); begin a := '2'; end; parser input bằng file PT của mình nó ra thế này, rồi dùng nó làm input cho ass2 thì đc kq: [var(a,string),proc(duyTien,[],[assign(a, ""'2'"" )])] Program(List(Var(a,PrimitiveType(string)), Proc(duyTien,List(),Block(List(Assign(Id(a),StringLit(""'2'""))))))) -----Var----- -----Proc----- Type Mismatch In Statement: assign(a,""'2'"") Còn nếu dùng file PT của thầy thì [var(a,string),proc(duyTien,[],[assign(a,string( """"'2'"""" ))])] Exception in thread ""main"" java.lang.RuntimeException: No result when parsing failed at scala.sys.package$.error(package.scala:27) at scala.util.parsing.combinator.Parsers$NoSuccess.get(Parsers.scala:141) at scala.util.parsing.combinator.Parsers$NoSuccess.get(Parsers.scala:130) at Main$.main(Main.scala:10) at Main.main(Main.scala) Bạn xem thử."
xuan vinh,1,12/23/2011,lab 6 sol,hiện tại vẫn chưa thấy giảng viên upload solution lab 6 lên. mong thầy sớm upload để tụi em có cái để ôn thi thank
Cơn Mưa Tình Yêu,1,12/25/2011,Re:lab 6 sol,"Bây giờ là gần 23h00 ngày 25/12. Tức còn khoảng 1 ngày, 14 giờ, 20 phút là đến thời điểm thi cuối kỳ PPL mà hiện tại vẫn chưa thấy Solution Lab 6 trong Module. Mong thầy up lên nhanh giúp vì nội dung thi có những cái này. Thanks thầy nhiều!"
Forever Alone,1,12/19/2011,Mong anh Hùng phổ biến rõ hơn về vấn đề Function Not Return,"vanhoa  wrote: 1>0 vẫn là true :))Thựcchấtstaticcheckcũngbaogồmnhữngcáinàynữa,tuỳvàongườiđịnhnghĩathôi,VDnhưmấycáiIDEjavađó,netbeans hoặcEclipsechẳnghạn,nóvẫncheckmấycáiđóđó :D Cái này a Hùng bảo làm chứ nếu không thì ass này đơn giản quá, còn có test hay ko thì mình ko rõ :)) Theo ý của bạn Hòa (bên topic ""Function Not Return"") thì khi xét Function Not Return thì phải tính xem những điều kiện của loop, while và if có chắc chắn đúng hay không.Hòa nói anh Hùng bảo làm nhưng có vẻ như chỉ bảo với 1 nhóm nhỏ chứ chưa phổ biến cho toàn thể sinh viên. Mong anh Hùng làm rõ vấn đề này giúp bọn em. Em cám ơn."
Thanh Pham Minh,1,12/20/2011,Mong anh Hùng phổ biến rõ hơn về vấn đề Function Not Return,Ngôn ngữ Crazy có tính kiểu short-circuit không thầy? Với x là biến thì biểu thức (true or x) được xem là true luôn hay vẫn phải xét tiếp x?
M.U.,1,12/21/2011,"cách xử lý integer, real, boolean, string","Mý bạn có thể cho mình hướng xử lý mý cái này dc ko, mình cám ơn,"
V For,1,12/21/2011,"cách xử lý integer, real, boolean, string","M.U.  wrote: Mý bạn có thể cho mình hướng xử lý mý cái này dc ko, mình cám ơn, 1. Kiểm tra kiểu nào được thao tác tren phép toán nào.' def KiemTraKieu1(op: string, expr: Expr){ nếu op == ""bnot"" thì expr fai là boolean ... } 2. Kiểm tra ứng với kiểu đó, kết quả trả về của phép toán là ji boolean and boolean => boolean"
M.U.,1,12/21/2011,"cách xử lý integer, real, boolean, string","tran ngoc duc wrote: M.U.  wrote: Mý bạn có thể cho mình hướng xử lý mý cái này dc ko, mình cám ơn, 1. Kiểm tra kiểu nào được thao tác tren phép toán nào.' def KiemTraKieu1(op: string, expr: Expr){ nếu op == ""bnot"" thì expr fai là boolean ... } 2. Kiểm tra ứng với kiểu đó, kết quả trả về của phép toán là ji boolean and boolean => boolean cám ơn bạn nhìu"
Đỗ Sỹ Hưng,1,12/3/2011,Cách biên dịch Prolog trong Eclipse,"Bước 1: Cài SWI-Prolog. 1. Vô trang http://www.swi-prolog.org/download/stable , download file SWI - Prolog 5.10.5. 2. Chạy file tải về để cài. 3. Set biến PATH: 3.1 Windows 7: Nhấp phải Computer -> Properties -> Advanced system settings -> Tab Advance -> Enviroment Variables... Windows XP: Nhấp phải Computer -> Properties -> Tab Advance -> Enviroment Variables... 3.2 Chọn biến PATH trong System variables -> Edit... -> thêm dòng %prolog%\bin (%prolog% là thư mục cài đăt SWI-Prolog nha). 3.3 Khởi động lại máy. Bước 2: Cài đặt tool Prolog cho Eclipse 1. Chạy Eclipse -> Help -> Install New Software... -> Add. 2. Mục Name để tên nào cũng được ^^ (mình để là Prolog >""<), mục Location thì copy đường link sauhttp://sewiki.iai.uni-bonn.de/public-downloads/update-site/ 3. Nhấp OK 4. Mở rộng 2 nhánh ""Program Analysis and Transformation"" với ""Prolog Development Tool (PDT)"" 5. Chọn 2 mục ""JTransformer"" và ""Prolog Development Tools"". 6. Nhấp Next và cài thôi :D Cách sử dụng: 1. Tạo 1 empty project: File -> New -> Project... -> General -> Project -> Next -> Đặt tên project -> Finish 2. Nhấp phải tên project -> New -> File -> đặt tên file có phần mở rộng là .pl (vd: Demo.pl) 3. Viết code trong file vừa tạo -> save file (phải save trước nha) 4. Từ menu Prolog -> Prolog Console 5. Để build file Prolog, chọn Prolog -> (re)consult -> xuất hiện mấy cái predicate trong cửa sổ Outline (nếu nó không xuất hiện là bị lỗi đó) 6. Trong cửa sổ Project Console, mình viết mấy câu query thôi ^^ 7. còn để debug thì gõ ""noguitracer."", rồi gõ theo cú pháp ""trace, p(X, Y, Z)."" Link: http://sewiki.iai.uni-bonn.de/research/pdt/start P/S: Cái này mình mới tìm ra, chia sẻ cho anh em ^^"
Nhan Nguyen Van,1,12/21/2011,"Return String, Array","Thấy cho em hỏi. Trong đặc tả có đoạn như thế này: For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . For an assignment statement, the LHS can be in real, integer or boolean type . The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. In Crazy, just the integer can coerce to the real. Vậy nếu xem kiểu trả về như là một LHS thì kiểu trả về chỉ có thể là real, integer hoặc boolean. Không được trả về kiểu string hay array đúng không ạ? For a call statement, the callee must be in procedure type and the number of arguments must be equal to that of callee parameters. In addition, for parameter passing, the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS. Tương tự, parameter có thể là kiểu string không?"
M.U.,1,12/21/2011,TestCase này mình ko hiểu ?,"Test44 của bạn vanhoa như sau: proceduremain(); begin vararrVar:array[2]ofstring; arrVar:=['1';'2']; arrVar[1]:='13'; end; [proc(main,[],[var(arrVar,arr([2],string)),assign(arrVar,array([string(""'1'""),string(""'2'"")])),assign(ele(arrVar,[1]),string(""'13'""))])] Program(List(Proc(main,List(),Block(List(Var(arrVar,Arr(List(IntLit(2)),PrimitiveType(string))), Assign(Id(arrVar),ArrayLit(List(StringLit(""'1'""), StringLit(""'2'"")))), Assign(Ele(arrVar,List(IntLit(1))), UnaryOp (string,StringLit(""'13'"")))))))) Mình ko hiểu cái UnaryOp, tại sao lại có và các vấn đề liên quan đến nó, mý bạn có thể giải thích giúp mình theo testcase ở trên ko, mình cám ơn rất nhiều."
Huỳnh Tiến Tài,1,12/21/2011,Re:TestCase này mình ko hiểu ?,Bởi vì file PT mới của thầy có định nghĩa thêm Unary Op của string. Nhưng bạn cứ theo đặc tả mà làm. Sẽ k có op cho string. Đơn giản vậy thui. Còn thầy đã nhấn mạnh là "PT chỉ để ta test bài nó sẽ k liên quan đến kết quả ta sẽ chạy để chấm trong ass này"
M.U.,1,12/21/2011,Re:TestCase này mình ko hiểu ?,cám ơn bạn nhìu
Quái,1,12/5/2011,Re:Cách biên dịch Prolog trong Eclipse,thanks! Thử xem...
BKIT 09,1,12/5/2011,Re:Cách biên dịch Prolog trong Eclipse,Các bạn cũng có thể sử dụng BProlog để lập trình trên cmd
Crazy Boy,1,12/7/2011,Cách biên dịch Prolog trong Eclipse,Thanks!
Phúc Trí,1,12/21/2011,"Re:Return String, Array",mình nghĩ làđượcđó. Trong specass1 có ghi "Return type and parameter type can be primitive type or array type." mà. xem para như LHS vàarg như RHS ý thầy là giữa para vàarg phải có sự tương thích (comform) về kiểu thôi.
Phúc Trí,1,12/22/2011,Re:mong anh Hùng trả lời:,thay da tra loi roi bạn. câu lệnh gán m:=1 ko được tính. nhưng câu x:=m+n vẫn check nên sẽ báo lỗi m not difined
M.U.,1,12/22/2011,"unaryop(string,StringLit(""'hello'"")) có tồn tại ko","thầy có nói trong notice :Trả lời: xem đặc tả ngôn ngữ string không có bất cứ phép toán nào cả Trong đặc tả scala có đoạn: The keyword string is used for a string type. A string constant can be assigned to a variable in an assignment statement, constant definition or be passed to a parameter. There is no operation on this type. vậy thì trường hợpunaryop(string,StringLit(""'hello'"")) có tồn tại ko ? Mình vẫn chưa hiểu hết về String cho lắm, mý bạn có thể nói rõ thêm String có thể dc phép làm gì nữa hay ko :( mình cám ơn :( Vậy còn lúc truyền par thì sao >""< Cám ơn mọi người. Sắp xong ùi, cố lên >""<"
_Đào_Hoa_Đảo_Chủ_,1,12/22/2011,"Re:unaryop(string,StringLit(""'hello'"")) có tồn tại ko",Đọc đề không thấy nghĩa là không có ^_^
Phúc Trí,1,12/20/2011,File PT vẫn chưa tương thích,"trong file Util của thầy kiểu int là PrimitiveType(""integer""), kiểu real là PrimitiveType(""real"") còn file PT là class IntTypePT extends PrimitiveTypePT { override def toString = ""int"" } class RealTypePT extends PrimitiveTypePT { override def toString = ""float"" } VD: procedure c(); begin var a: real; var b:real; b:=9.0; end; b:=9.0 bị lỗi vì b kiểu real còn 9.0 kiểu float. Mong thầy xem lại chỗ này"
Thanh Pham Minh,1,12/20/2011,Re:File PT vẫn chưa tương thích,"Các bạn thử lấy file PT mới test cái này (của ""nhan"" bên topic kia): function main():string; begin return 'a'; end; sẽ được cây sinh ra: Program(List(Func(main,List(),PrimitiveType(string),Block(List(Return( UnaryOp (string,StringLit(""'a'"")) )))))) =))"
Tan Phat,1,12/22/2011,"Re:Thắc mắc 1 test case: gấp, gấp!^^","Mình ra: Cannot Assign To Constant: assign(c,3)"
V For,1,12/22/2011,"Re:Thắc mắc 1 test case: gấp, gấp!^^","Tan Phat  wrote: Mình ra: Cannot Assign To Constant: assign(c,3) same Cannot Assign To Constant: assign(c,3)"
50902440,1,11/9/2011,Điểm tut2,"Thầy ơi, em có đi học giờ tut2 tiết 11-12 chiều thứ 3, có nộp bài và lên bảng làm bài đúng. Nhưng lại 0/10. Em còn nhớ chị TA gọi em lên bảng làm bài số 2, cái đề chị ấy đưa em bị sai có dư thêm 1 dòng số 6. =.= Thầy xem lại giúp em ạ. Em tên Nguyễn Quang Thái. MSSV 50902440."
50902440,1,11/11/2011,Điểm tut2,Em cám ơn thầy.
Forever Alone,1,12/20/2011,Re:File PT vẫn chưa tương thích,"Thanh Pham Minh wrote: Các bạn thử lấy file PT mới test cái này (của ""nhan"" bên topic kia): function main():string; begin return 'a'; end; sẽ được cây sinh ra: Program(List(Func(main,List(),PrimitiveType(string),Block(List(Return( UnaryOp (string,StringLit(""'a'"")) )))))) =)) Tui ra y chang Thành =))"
FirstName LastName,1,12/20/2011,Re:File PT vẫn chưa tương thích,"Làmđãđời gần hết hạn cái change tùm lum :)), fix bậy bạ coi chừng bỏassignment này luôn chứ chẳng chơi :))"
V For,1,12/20/2011,Re:File PT vẫn chưa tương thích,"Manchester United wrote: Làmđãđời gần hết hạn cái change tùm lum :)), fix bậy bạ coi chừng bỏassignment này luôn chứ chẳng chơi :)) k có file PT cũng làm thôi, tội j bỏ :D"
Ngan Tuyet,1,12/21/2011,Re:File PT vẫn chưa tương thích,Vậy cái UnaryOp mình làm chỉ có 2 TH sub và bnot thui à? Không liên quan j đến string như code thầy phải ko mấy bạn? Tại nếu thầy chấm dùng file PT.scala đó là cái test nào dính string sai hết !!!
Nha Nguyen,1,12/22/2011,Test thu !,procedure a(); begin end; procedure main(); begin a:=5; end;
Nha Nguyen,1,12/22/2011,Re:Test thu !,còn test này thì sao mấy bạn? procedure a( b: string); begin end; procedure main(); begin a('abc'); end;
facebook.com,1,12/20/2011,Scope của biến global???,chicken _  viết: ===================== procedure a(); begin end; procedure b(); begin var b: integer;  //có báo lỗi dòng này ko. end; ____________________________________________________ procedure a(); begin end; procedure b(); begin var a: integer;  //có báo lỗi dòng này ko. end; Cái này có báo lỗi ko vậy các bạn
Hieu Nguyen Minh,1,11/12/2011,Bài 3 tut 4,"if a is greater than 0and √ a >b  then return 1; otherwise if a equals 0 or b / a is greater than 1 then return 2. cho em hỏi là: đặt trường hợp a= 0.25, b=0.4 tức thỏa điều kiện a>0,√ a >b, b/a>1 thì return bao nhiêu? Cảm ơn."
Peter,1,12/22/2011,Re:Test thu !,Nguyen Nha wrote: còn test này thì sao mấy bạn? procedure a( b: string); begin end; procedure main(); begin a('abc'); end; None
_Trung_Than_Thong,1,12/22/2011,Re:Scope của biến global???,"nhan nguyen van wrote: var x :real; function demo(a: real): real; begin return 0; end; procedure main(); begin var demo: real; x := demo(demo); end; Cái này sao mấy bác?? biến demo có che hàm demo không? Nếu không che thì có thể gọi demo(demo) Function demo( biến demo) ko? không báo lỗi gì cả. Theo lý giải của Nhan bên dưới nhưng mà 1 cái là biến, 1 cái là hàm thì không liên quan gì nhau (nên sẽ không bị che). Vd: bạn gọi hàm demo ngay dưới biến demo vẫn OK vì hàm sẽ có cả tham số nữa mà (demo() khác với demo). @Dung: Quan trong là cái typeof mình lookup như thế nào. Đâu fai cứ lookup cái name vậy rồi nói nó che được"
Phúc Trí,1,12/22/2011,Re:Scope của biến global???,"_Trung_Than_Thong  wrote: nhan nguyen van wrote: var x :real; function demo(a: real): real; begin return 0; end; procedure main(); begin var demo: real; x := demo(demo); end; Cái này sao mấy bác?? biến demo có che hàm demo không? Nếu không che thì có thể gọi demo(demo) Function demo( biến demo) ko? không báo lỗi gì cả. Theo lý giải của Nhan bên dưới nhưng mà 1 cái là biến, 1 cái là hàm thì không liên quan gì nhau (nên sẽ không bị che). Vd: bạn gọi hàm demo ngay dưới biến demo vẫn OK vì hàm sẽ có cả tham số nữa mà (demo() khác với demo). @Dung: Quan trong là cái typeof mình lookup như thế nào. Đâu fai cứ lookup cái name vậy rồi nói nó che được Trongass của mìnhđề chỉ nói chung tên biến, hằng, hàm là identifier chứ có phân biệt = tên và kindđâu bạn  Most closed nested rule: For every applied occurrence (i.e., use) of an identifier I in a block A, there must be a corresponding declaration of I. The declaration is in a block that is smallest enclosing the applied occurrence of I.  Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block. Chỉ cần trùng tên là bị che ở block bên trong rồi. đúng là theo logic bình thường thì sẽ phân biệt hàm demo() và biến demo. nhưngởđâyđặc tảđãđơn giảnđi thì mình làm vậyđi ( thầy làm vậy làđểđơn giản cho mìnhđó)"
V For,1,12/22/2011,Scope của biến global???,"abc  wrote: Van Persie wrote: chicken _  viết: ===================== procedure a(); begin end; procedure b(); begin var b: integer;  //có báo lỗi dòng này ko. end; ____________________________________________________ procedure a(); begin end; procedure b(); begin var a: integer;  //có báo lỗi dòng này ko. end; Cái này có báo lỗi ko vậy các bạn 1.Redeclared Variable: b 2. Không lỗi: vì biến a bị khai báo đè. Nhầm k bạn, cả 2 trường hợp đều không lỗi. Vì func và proc được coi là biến toàn cục rồi, còn cái b đó nằm trong begin-end nên nó có quyền khai báo lại"
V For,1,12/22/2011,Re:Scope của biến global???,Guest User wrote: Nguyen Xuan Sang wrote: Cho mình hỏi báo lỗi chỗ nào: procedure test(); begin a:=true  <---------------- 1 end; var a:integer; var a:real;  <-----------------2 Mấy bạn giải thích lỗi giùm mình tại ko hiểu phần này lắm. test ko bao h có 2 lỗi đâu bạn Chổ này mình nghỉ ý của thầy là khác. Đúng là trog box bên kia thầy có nói là" test không bao giờ có 2 lỗi". Xin thầy xác nhận lại là: - Trong 1 testcase k có 2 lỗi Hay - trong 1 dòng của testcase không thể có 2 lỗi
meo_lac,1,11/20/2011,solution tut 3 và lab 4,Mong thầy up solution tut 3 và lab 4 sớm để tụi em tham khảo. Cảm ơn thầy.
Nha Nguyen,1,12/22/2011,Re:Test thu !,sao các cậu chạy được test trên mà không bi lỗi chỗ Unary j sao ?
nguyễn văntoàn,1,11/22/2011,Điểm tut 4,"Thưa Thầy, em tên là Nguyễn Văn Toàn, mssv: 50702528. Trong tut 4, e làm được 4 bài trên tổng số 5 bài. khi thầy gọi e lên bảng trúng ngay bài e không biết làm. Em nghĩ em chỉ được 5 /10 nhưng sao điểm của emchỉ được 0/10. Mong Thầy coi lại dùm em. Em cảm ơn Thầy nhiều."
nguyễn văntoàn,1,11/23/2011,Re:Điểm tut 4,Dạ không thưa Thầy. Nhóm e là nhóm 3 nên bữa đó chỉ đổi phòng qua 504 B4 thôi. Em đi học đúng giờ đúng lớp . Em học cùng với mấy đứa bạn nên không sai lớp được đâu Thầy. Mong Thầy coi lại dùm em. Em cảm ơn Thầy nhiều.
Phúc Trí,1,12/17/2011,Scope của biến global???,"các bạn cho mình hỏi biến global có tầm vực như thế nào? kể từ dòng khai báo biếnđó hay toàn bộ chương trình. Tương tự, 1 hàm cóđược sử dụng dụng phía trướcđịnh nghĩa hàmđó không? VD: procedure main(); begin y := 1; (1)//ngay cho nay co bị lỗi không writeRealLn(foo(y)); (2)//giả sử dòng trênđúng thì dòng này có báo lỗi không end; const x = 1.2e3; function foo(p:integer):real; begin return p * x; end; var y,z:integer;"
nguyễn văntoàn,1,11/24/2011,Re:Điểm tut 4,"Dạ, em cảm ơn Thầy nhiều."
Thanh Pham Minh,1,12/17/2011,Scope của biến global???,"H.T.P (^_^)  wrote: các bạn cho mình hỏi biến global có tầm vực như thế nào? Tương tự, 1 hàm cóđược sử dụng dụng phía trướcđịnh nghĩa hàmđó không? - The scope of a global variable: the entire program => Biến global có tầm vực toàn chương trình :) - The scope of a function/procedure: the entire program. Một hàm dùng được trong tầm vực (scope) của nó => ... - Có xét thêm: the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block."
Nguyen Vo,1,12/17/2011,Re:Scope của biến global???,Tóm lại là có báo lỗi ko vậy. Thầy ơi trả lời giúp em đi. !!!!!!!!! hàm dùng trước khi định nghĩa liệu có báo lỗi undeclare Trong C++ báo lỗi. Scala ko báo lỗi. Không biết Crazy language này thế nào. Help!!!! Sắp deadline rồi mà thầy đi đâu thế ko biết.
Phúc Trí,1,12/17/2011,Re:Scope của biến global???,vậy cả 2 VD của mình làđúng hết cả 2 à. (Chỗ này không hiểu cho lắm nên hỏi lại cho chắc.)
Nguyen Vo,1,12/17/2011,Re:Scope của biến global???,1 hàm được dùng trong scope của nó. Chứ không có nói là phải khai báo trươc hay ko. Thầy Hùng ơi vô trả lời đi ạ. Để em biết mà sửa lại. Báo sớm em còn có thời gian chỉnh sửa.
V For,1,12/17/2011,Re:Scope của biến global???,"H.T.P (^_^)  wrote: vậy cả 2 VD của mình làđúng hết cả 2 à. (Chỗ này không hiểu cho lắm nên hỏi lại cho chắc.) Cái này mình nghĩ ntn: Code mẫu của thầy là duyệt lần lượt từ a -> z, gặp sai báo error ngay. Vậy nên: đến điểm đang xét biến, const, hoặc func chưa đc khai báo => ERROR => sys.exit rồi. Làm j có khả năng ""cho em chạy thêm 1 lúc nữa xem có khai sau này có ai khai báo em không"" đâu ??? vd: x := y + function1(); // function1() chưa đc khai báo ........... function1(): real; begin ... end; làm sao nó chạy xuống để tìm được"
Thanh Pham Minh,1,12/17/2011,Scope của biến global???,"@H.T.P (^_^): hai ví dụ của bạn mình chưa chạy thử được nhưng xét về scope của biến và hàm thôi thì đều không có lỗi. Giải thích thì như bạn chicken _ đã nói: ""1 hàm được dùng trong scope của nó. Chứ không có nói là phải khai báo trươc hay ko."" Rõ hơn là không cần phải khai báo trước theo thứ tự từ trên xuống trong file source. @tran ngoc duc: bạn có thể giữ nguyên code mẫu, hoặc chỉnh sửa code mẫu miễn là thỏa được đặc tả."
Nguyen Vo,1,12/17/2011,Re:Scope của biến global???,Tóm lại là báo lỗi hay không. Mỗi người một ý vây. * Báo lỗi: Đã làm được. * Không báo lỗi: Sẽ phải sửa lại nhiều. Cái này còn liên quan tới nhiều vấn đề khác nữa => Sửa lại hàm tìm kiếm.
Thanh Pham Minh,1,12/17/2011,Re:Scope của biến global???,chicken _ wrote: Tóm lại là báo lỗi hay không. Mỗi người một ý vây. * Báo lỗi: Đã làm được. * Không báo lỗi: Sẽ phải sửa lại nhiều. Cái này còn liên quan tới nhiều vấn đề khác nữa => Sửa lại hàm tìm kiếm. Không báo lỗi ;))
Nguyen Vo,1,12/17/2011,Re:Scope của biến global???,Đã hiểu. Tóm lại là không báo lỗi.
Bruce Wayne,1,12/17/2011,Scope của biến global???,Theo mình là báo lỗi
Forever Alone,1,12/17/2011,Re:Scope của biến global???,Các bạn cứ dựa vào đặc tả mà làm. Assignment 1 thầy cũng đã nói là code thầy ko hoàn toàn đúng mà.
nguyen dung,1,12/17/2011,Re:Scope của biến global???,"Mình làm theo đặc tả là toàn bộ chương trình, chạy không báo lỗi, còn trước hay sau thì tùy cách duyệt thôi"
kid_ chem_ gio,1,12/17/2011,Scope của biến global???,Như bạn pham minh thành đã nói: Sẽ không báo lỗi đâu các bạn vì phạm vi của hàm foo() là toàn cục.Nên sử dụng trc rồi khai báo sau sẽ không gặp vấn đề gì hết. Chỉ ở trong Block các bạn mới cần check từng dòng vì phạm vi trong block là từ điểm bắt đầu khai báo tới khi kết thúc block đó
FirstName LastName,1,12/17/2011,Re:Scope của biến global???,"Cái ví dụ bạn chủ topicđưa ra là 1 trong những phần:Exampleof Crazy Language trong file Spec.pdf Như vậy, Crazy ko báo lỗi. Mà có aiđểý là thầy lại ""dẫnđoànđi Olympic"" rồi ko, chả thấy trả lời gì cả :))"
Phúc Trí,1,12/17/2011,Re:Scope của biến global???,"Spec ass1 wrote: 2.5. Example of a Crazy program var y,z: integer; procedure main(); begin y := 1; writeRealLn(foo(y)); end; const x = 1.2e3; function foo(p:integer):real; begin return p * x; end; đã giải quyếtđược thắc mắc. Hàm dùng trước khai báo sauđược thì biến cũng thế. :)"
thinh van,1,11/22/2011,grade tut 4,"thầy xem lại dùm em thử, tut 4 em có nộp bài và làm bài đầy đủ sao có 0/10 a, em cảm ơn Bùi Văn Thịnh mssv: 50903451"
meo_lac,1,11/23/2011,Re:grade tut 4,Em đã đc điểu chỉnh lại điểm.
thinh van,1,11/23/2011,Re:grade tut 4,"Vo Thanh Hung wrote: Đã kiểm tra lại, em được 10, em kiểm tra lại nhé. em cảm ơn anh ạ"
Nhan Nguyen Van,1,12/17/2011,Re:Scope của biến global???,"procedure demo(); begin y := true; var y: integer; y := 0; end; var y : boolean; => None Test case này test tầm vực nè, ra None là ok"
Nhan Nguyen Van,1,12/17/2011,Re:Scope của biến global???,var x :real; function demo(a: real): real; begin return 0; end; procedure main(); begin var demo: real; x := demo(demo); end; Cái này sao mấy bác?? biến demo có che hàm demo không? Nếu không che thì có thể gọi demo(demo) Function demo( biến demo) ko?
kid_ chem_ gio,1,12/17/2011,Scope của biến global???,Theo lý thuyết thì hàm demo là toàn cục. như vậy có thể gọi demo(demo) lắm chứ
nguyen dung,1,12/17/2011,Re:Scope của biến global???,"Còn trong thực tế thì cái biến demo nó nằm trước hàm demo, nên gọi ra báo lỗi, khi gọi typeof cho demo thì không thể nào demo vừa là hàm mà lại vừa là biến , Nhân cho VD ác quá :)"
kid_ chem_ gio,1,12/17/2011,Scope của biến global???,uh! thực tế là vậy nên chắc đành chấp nhận sự thật phũ phàng đó
Nhan Nguyen Van,1,12/17/2011,Re:Scope của biến global???,"Most closed nested rule: For every applied occurrence (i.e., use) of an identifier I in a block A, there must be a corresponding declaration of I. The declaration is in a block that is smallest enclosing the applied occurrence of I. Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block. = Tầm vực của một định nghĩa không bao gồm tầm vực của định nghĩa khác cùng tên bên trong một block. Ví dụ: function demo():real; begin return 0; end; procedure main(); begin var demo: real; => Chổ này không thấy hàm demo nữa. end;"
Forever Alone,1,12/17/2011,Re:Scope của biến global???,"H.T.P (^_^)  wrote: Spec ass1 wrote: 2.5. Example of a Crazy program var y,z: integer; procedure main(); begin y := 1; writeRealLn(foo(y)); end; const x = 1.2e3; function foo(p:integer):real; begin return p * x; end; đã giải quyếtđược thắc mắc. Hàm dùng trước khai báo sauđược thì biến cũng thế. :) Cẩn thận cái này chỉ dành cho global thui nhé :)"
FirstName LastName,1,12/17/2011,Re:Scope của biến global???,Redeclared Constant: x v ì khi checkở ngoài hàm thì có biến x khai báo var const x khai báo lại 1 lần nữa -> lỗi
Nguyen Vo,1,12/18/2011,Re:Scope của biến global???,procedure a(); begin end; procedure b(); begin var b: integer; //có báo lỗi dòng này ko. end; ____________________________________________________ procedure a(); begin end; procedure b(); begin var a: integer; //có báo lỗi dòng này ko. end;
Sieutoc,1,12/19/2011,Re:Scope của biến global???,"nhan nguyen van wrote: Most closed nested rule: For every applied occurrence (i.e., use) of an identifier I in a block A, there must be a corresponding declaration of I. The declaration is in a block that is smallest enclosing the applied occurrence of I. Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block. = Tầm vực của một định nghĩa không bao gồm tầm vực của định nghĩa khác cùng tên bên trong một block. Ví dụ: function demo():real; begin return 0; end; procedure main(); begin var demo: real; => Chổ này không thấy hàm demo nữa. end; Chỗ này bạn giải thích rất đúng, mình cũng có cùng cách hiểu như vậy là hàm demo sẽ bị che => báo lỗi"
Nguyen Xuan Sang,1,12/20/2011,Re:Scope của biến global???,Cho mình hỏi báo lỗi chỗ nào: procedure test(); begin a:=true  <---------------- 1 end; var a:integer; var a:real;  <-----------------2 Mấy bạn giải thích lỗi giùm mình tại ko hiểu phần này lắm.
James Blunt,1,10/30/2011,Re:GradeBook Mid Term,thầy xem lại bài giùm em với Tên: Hoàng Văn Nhật Vũ MSSV:50903336
kid_ chem_ gio,1,10/26/2011,GradeBook Mid Term,Tên:   Nguyên Duy Tài MSSV :   50902316 Thầy xem lại bài làm giùm em. Sao điểm giữa kỳ 5/10. Em cảm ơn
Quan Nguyen,1,10/31/2011,Re:GradeBook Mid Term,Họ tên: Nguyễn Hoàng Minh Quân MSSV: 50902135 Mong thầy xem xét lại bài giúp em.
TAM NGOC,1,10/31/2011,Re:GradeBook Mid Term,Họ Tên: Nguyễn Thị Ngọc Tâm MSSV: 50801879 Mong thầy xem lại bài giúp em. Cám ơn thầy.
LAV,1,10/31/2011,GradeBook Mid Term,Tên: Lê Anh Vũ MSSV: 50903340
Nguyen Khoa Quang Khai,1,10/31/2011,Re:GradeBook Mid Term,Tên: Nguyễn Khoa Quang Khải MSSV: 50901205
Tuan Pham Duy,1,11/1/2011,GradeBook Mid Term,Họ và tên: Phạm Duy Tuấn MSSV: 50903120 Thầy xem lại bài em với. Em cảm ơn Thầy.
Tran Thanh,1,11/1/2011,GradeBook Mid Term,Tên: Trần Ngọc Thành MSSV: 50902484 Thầy xem lại bài em với. Em cảm ơn Thầy.
3N,1,11/2/2011,Re:GradeBook Mid Term,Tên: Trần Duy Khoa MSSV: 50901262 Thầy xem lại bài em với. Em cảm ơn Thầy.
Minh Triet Pham Tran,1,11/2/2011,Re:GradeBook Mid Term,"Em muốn nhờ thầy xem lại có cộng sót điểm không thôi, không cần chấm lại phần nội dung bài làm, em xin cảm ơn. Họ tên: Phạm Trần Minh Triết MSSV: 50702596"
Linh Nguyen Thanh,1,11/2/2011,Re:GradeBook Mid Term,Nguyễn Thanh Linh MSSV :50901393 mong thầy xem xét lại.
Sieutoc,1,11/2/2011,Re:GradeBook Mid Term,Họ tên:Phạm Quốc Việt MSSV : 50903277
hoc dot,0,11/2/2011,Re:GradeBook Mid Term,Nhờ thầy (cô) xem lại bài giúp em! Đỗ Phước Hậu MSSV: 50800617
n0b0dy,1,11/3/2011,GradeBook Mid Term,Mình cũng ko hiểu tại sao điểm mình thấp . Nhưng hôm đi học thầy giảng lại bài giữa kì thì mới bik mình có nhiều sai sót :) nên cũng đành phải chấp nhận điểm thấp thôi . :) . Dù sao thì cũng do ko nắm kĩ phần Lab tut nên mới bị như thế này :)
kid_ chem_ gio,1,11/6/2011,GradeBook Mid Term,Nguyễn Duy Tài MSSV:50902316 Em xin rút lại tên trong danh sách xin phúc khảo Lý do: Trong quá trình làm bài tập lớn đã phát hiện ra lỗi sai của mình
sat long,1,11/6/2011,Re:GradeBook Mid Term,Nguyễn Văn Viên MSSV:50802756 Nhờ thầy xem lại bài giúp!
Tuan Pham Duy,1,11/10/2011,Re:GradeBook Mid Term,"MSSV: 50903120 Sáng thứ 2 em đi học thực tập công nghiệp rồi, thầy có thể dành buổi khác được không?"
Linh Nguyen Thanh,1,11/10/2011,Re:GradeBook Mid Term,@Tuan Pham Duy bạn xem lại thông báo update đi : GCSđăng ký tham quan ngày 14/11 được chuyển sang 18/11 rồi mà.
LAV,1,10/26/2011,GradeBook Mid Term,Đợi thầy sửa bài xem sao! =]]
Ngan Tuyet,1,10/26/2011,Re:GradeBook Mid Term,Họ tên: Đỗ Thị Tuyết Ngân MSSV: 50901668
.                                . Kazumi              ..,1,10/26/2011,Re:GradeBook Mid Term,Sao điểm thấp vậy ta. Hoàng Văn Quân mssv: 50902128
Cơn Mưa Tình Yêu,1,10/26/2011,Re:GradeBook Mid Term,"Nguyên nhân điểm thấp: Sự nóng vội trong việc chấm điểm. Mới thi hồi thứ 6 tuần trước mà thứ 4 tuần sau đã có điểm. Có nghĩa là điểm đã chấm xong từ thứ hai hay thứ ba. Quá nhanh! chấm điểm trong vòng 3,4 ngày, còn nhanh hơn cả chấm trắc nghiệm nữa . Thế này không thấp mới là lạ..."
Thong Nguyen,1,10/26/2011,GradeBook Mid Term,Họ tên: Nguyễn Tấn Thông MSSV: 50902652
_Trung_Than_Thong,1,10/26/2011,Re:GradeBook Mid Term,
Thanh Pham Minh,1,10/26/2011,Re:GradeBook Mid Term,"Tân Trần Vĩnh wrote: Và như thông báo mới, chúng tôi sẽ chấm chặt tay, trước mặt các em, với những bài được thắc mắc. Mong thầy công bố chi tiết cách tính điểm. Ví dụ: trong một câu sai ý này, đúng ý kia thì được bao nhiêu; đúng nhưng chưa đủ thì được bao nhiêu; chữ xấu có trừ điểm không; một câu đúng ý nhưng trình bày khó hiểu thì thế nào;... Như vậy sinh viên dễ dàng hơn để xác định bài của mình có bị nhầm lẫn gì khi chấm không. Đây là bài thi tự luận nên ít nhiều sẽ có yếu tố chủ quan của người chấm (có năm người chấm) và khả năng diễn đạt của người làm. Theo em, nếu quyết định chấm gắt hơn ở những bài xin chấm lại thì cũng nên có bonus cho những bài xin chấm lại mà chính xác."
Trieu Nguyen Lam,1,10/26/2011,GradeBook Mid Term,Tên : Nguyễn Lâm Triều MSSV : 50902904
hien pham ngoc,1,10/26/2011,Re:GradeBook Mid Term,Thầy xem lại bài giúp em: Phạm Ngọc Hiển. MSSV: 50900856
facebook.com,1,10/26/2011,GradeBook Mid Term,
3N,1,11/14/2011,GradeBook Mid Term,"Hix, sáng giờ em học bài quên mất."
Tuan Pham Duy,1,11/16/2011,Re:GradeBook Mid Term,"Hôm thứ 2 em đi hụt ngày GCS, em xin được xem lại bài của mình. Thầy có thể mở thêm bữa gặp lần cuối được không ạ? Phạm Duy Tuấn, 50903120"
Ghost,1,10/26/2011,Re:GradeBook Mid Term,Xin thầy xem lại bài giúp em. Họ tên: Nguyễn Ngọc Hoàng MSSV: 50900923
MFC.Maximus,1,10/26/2011,Re:GradeBook Mid Term,MSSV : 50903240 Tên : Lê Văn
free_love,1,10/27/2011,Re:GradeBook Mid Term,thầy xem lại dùm: tên:Nguyễn Sỹ Thành MSSV:50801987
vominh khai,0,10/27/2011,Re:GradeBook Mid Term,họ và tên : võ minh khải mssv: 50901212
Linh Nguyen Thanh,1,10/27/2011,Re:GradeBook Mid Term,đợi lên lớp thầy sửa xem sao. Đề thấy khă quan mà mình làm thiếu sót gì đó không lường trước. Mà quả thật điểm kì dưới sự kì vọng. Mong thầy chẩm dễ hơi chút nữa .
Tin Bui,1,10/27/2011,Re:GradeBook Mid Term,Cho em hỏi điểm số này có làm tròn không? hay cứ giữ nguyên như thế rồi tính vào tổng kết rồi mới làm tròn?
Hieu Bui,0,10/27/2011,Re:GradeBook Mid Term,Họ tên: Bùi Đức Hiếu MSSV: 50900792 Thầy xem lại bài giúp em.
Mai Phương Nam,1,10/27/2011,Re:GradeBook Mid Term,"Tên: Mai Phương Nam MSSV: 50901616 Mong thầy phúc khảo lại giúp em, nếu có thể em mong được biết lỗi sai của mình để em rút kinh nghiệm. Em cám ơn thầy!"
librastar,1,10/27/2011,Re:GradeBook Mid Term,Thầy xem lại bài giúp em: Tên: Vũ Thế Khanh MSSV: 50800922
Nhất Tiếu nại Hà,1,10/27/2011,Re:GradeBook Mid Term,
50902440,1,10/28/2011,GradeBook Mid Term,Thầy xem lại bài giúp em Tên: Nguyễn Quang Thái Mssv: 50902440
Mai Phương Nam,1,10/28/2011,Re:GradeBook Mid Term,Thưa thầy mãi đến 3/11 lớp em mới được học thầy nên chưa biết được đáp án của các thầy ạ!
Dream,1,11/7/2011,Lỗi lời gọi hàm rỗng : foo();,Mỗi lần mình cho input là lời gọi hàm rỗng: foo(); thì nó lại báo lỗi không combine được. Có ai biết lỗi này không. Giúp mình với mình xin cám ơn !
Nhất Tiếu nại Hà,1,11/7/2011,Lỗi lời gọi hàm rỗng : foo();,Dream  wrote: Mỗi lần mình cho input là lời gọi hàm rỗng: foo(); thì nó lại báo lỗi không combine được. Có ai biết lỗi này không. Giúp mình với mình xin cám ơn ! quăng code chổ đó lên mới chỉnh cho bạn đc chứ.....mà cái đó thì cho phép null là đc rồi repsep nó là ok
Dream,1,11/7/2011,Re:Lỗi lời gọi hàm rỗng : foo();,"Code của mình: def calSta : Parser[CallStmtPT] = ident ~ ( ""("" ~> repsep(expr,"","") <~"")"" )<~ "";"" ^^ { case name ~ lst => new CallStmtPT (new IdPT(name),lst) } Cho lời gọi hàm là NULL thì nó báo lỗi."
Nhất Tiếu nại Hà,1,11/7/2011,Re:Lỗi lời gọi hàm rỗng : foo();,"Dream  wrote: Code của mình: def calSta : Parser[CallStmtPT] = ident ~ ( ""("" ~> repsep(expr,"","") <~"")"" )<~ "";"" ^^ { case name ~ lst => new CallStmtPT (new IdPT(name),lst) } Cho lời gọi hàm là NULL thì nó báo lỗi. cho này bạn làm đúng rồi......sai ở chổ expr của bạn đó.....nó ko chấp nhận null..chỉnh cái đó lại đi:D:D"
Phúc Trí,1,11/7/2011,Thầy cho em hỏi thêm về Access Array Element.  nhiều bạn cũng thắc mắc như em.,"Định dạng khi truy xuất 1 phần tử của array trong Spec là thế này. [ ,…, ].Nhưng không biết có trường hợp ko có expr giữa 2 dấu [ ] hay không? VD: procedure main(); begin a [ ] :=3; end; input như thế này thì có parse thành công hay không. Mong thầy giải đáp chỗ này vì nhiều bạn cũng thắc mắc như em và chưa được thống nhất."
Phúc Trí,1,11/7/2011,Re:Thầy cho em hỏi thêm về Access Array Element.  nhiều bạn cũng thắc mắc như em.,Em cám ơn thầy.
_Hồng_Thất_ Công,1,11/7/2011,Re:Lỗi lời gọi hàm rỗng : foo();,"mình nghĩ chỗ gọi hàm này có kiểu là FuncCallExprPT chứ ko phải là CallStmtPT đâu,CallStmtPT là kiểu của câu lệnh gọi procedure."
Dream,1,11/7/2011,Re:Lỗi lời gọi hàm rỗng : foo();,"Nhất Tiếu nại Hà  wrote: Dream  wrote: Code của mình: def calSta : Parser[CallStmtPT] = ident ~ ( ""("" ~> repsep(expr,"","") <~"")"" )<~ "";"" ^^ { case name ~ lst => new CallStmtPT (new IdPT(name),lst) } Cho lời gọi hàm là NULL thì nó báo lỗi. cho này bạn làm đúng rồi......sai ở chổ expr của bạn đó.....nó ko chấp nhận null..chỉnh cái đó lại đi:D:D Thanks bạn nhiều, mình đã fix lại được lỗi này rồi :)"
Dream,1,11/7/2011,Re:Lỗi lời gọi hàm rỗng : foo();,"_Hồng_Thất_ Công wrote: mình nghĩ chỗ gọi hàm này có kiểu là FuncCallExprPT chứ ko phải là CallStmtPT đâu,CallStmtPT là kiểu của câu lệnh gọi procedure. Phai la CallStmtPT đó bạn vì FuncalExprT nó không thuộc Stmt đâu"
Nha Nguyen,1,11/5/2011,Element of array !,vd co test : procedure a(x:real); begin a[]:=b; end; output la gi ?
Nhất Tiếu nại Hà,1,11/5/2011,Re:Element of array !,line 3:3: unexpected token: ]
Đỗ Sỹ Hưng,1,11/5/2011,Re:Element of array !,"Parse thành công [proc(a,[par(x,float)],[assign(a,b)])]"
Nha Nguyen,1,11/5/2011,Re:Element of array !,"Minh cung parse thanh cong !Giong Sy Hung! [proc(a,[par(x,float)],[assign(a,b)])]"
Bruce Wayne,1,11/5/2011,Element of array !,Phần tử của mảng là a[] cũng dc à. Mình nghĩ phải có gì trong cặp dấu [] chứ
Forever Alone,1,11/5/2011,Re:Element of array !,Ủa như vậy tức là chấp nhận cú pháp truy cập phần tử rỗng à ? Mình thấy trong đặc tả đâu có phần nào nói vậy đâu ?
Nguyen Vo,1,11/6/2011,Re:Element of array !,gio chang biet the nao. thay cung chang them tra loi. thoi de cho so phan quyet dinh vay.
nguyen dung,1,11/6/2011,Re:Element of array !,Nghe nói thầy phụ trách đi Thái tham gia ACM rồi :(
Forever Alone,1,11/6/2011,Re:Element of array !,À mấy bạn test thử test này xem function child1():real; begin var childShare: real; childShare := 1 / 2; return childShare; foo('abc'); loop (5) do const a = 1; end;
Bruce Wayne,1,11/6/2011,Element of array !,line 7:14: unexpected token: const
Sieutoc,1,11/6/2011,Re:Element of array !,line 7:14: unexpected token: `const' Cac ban oi vay la van chua xac dinh duoc la truy xuat phan tu mang rong hay khong rong a`.
Bruce Wayne,1,11/6/2011,Re:Element of array !,Mai Hoa Đạo  wrote: line 7:14: unexpected token: `const' Cac ban oi vay la van chua xac dinh duoc la truy xuat phan tu mang rong hay khong rong a`. Bạn phải bỏ 2 cái dấu ở 2 đầu chứ. Trong phần notice có ví dụ tương tự cho kí tự ] mà (`]' bỏ 2 dấu ở 2 đầu thành ])
Sieutoc,1,11/6/2011,Re:Element of array !,T.D.N  wrote: Mai Hoa Đạo  wrote: line 7:14: unexpected token: `const' Cac ban oi vay la van chua xac dinh duoc la truy xuat phan tu mang rong hay khong rong a`. Bạn phải bỏ 2 cái dấu ở 2 đầu chứ. Trong phần notice có ví dụ tương tự cho kí tự ] mà (`]' bỏ 2 dấu ở 2 đầu thành ]) Mai Hoa Đạo  wrote: Mình cũng dùng if-else để thể hiện nhưng mà không hiểu bị lỗi gì. Nếu chỉ if rồi else thì không có lỗi. Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là "type missmatch; found: Unit required: String". Các bạn giúp mình với. Hix. Mình vẫn chưa sửa được lỗi này. Hiện tại mình chỉ xài dc có 1 cặp if-else nên chưa thể hiện dc hết lỗi.
Bruce Wayne,1,11/6/2011,Re:Element of array !,Mai Hoa Đạo  wrote: T.D.N  wrote: Mai Hoa Đạo  wrote: line 7:14: unexpected token: `const' Cac ban oi vay la van chua xac dinh duoc la truy xuat phan tu mang rong hay khong rong a`. Bạn phải bỏ 2 cái dấu ở 2 đầu chứ. Trong phần notice có ví dụ tương tự cho kí tự ] mà (`]' bỏ 2 dấu ở 2 đầu thành ]) Mai Hoa Đạo  wrote: Mình cũng dùng if-else để thể hiện nhưng mà không hiểu bị lỗi gì. Nếu chỉ if rồi else thì không có lỗi. Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là "type missmatch; found: Unit required: String". Các bạn giúp mình với. Hix. Mình vẫn chưa sửa được lỗi này. Hiện tại mình chỉ xài dc có 1 cặp if-else nên chưa thể hiện dc hết lỗi. Bạn thử để: if else { if else } thử xem
I love you,1,11/7/2011,"a[5,true]     a[5,c[4]]    a[5,dasdasd]          ?",Các bạn cho mình hỏi 3 cái phần tử của mảng đó có hợp lệ không ?
BT Lớn,1,11/7/2011,"a[5,true]     a[5,c[4]]    a[5,dasdasd]          ?",Christian Enzo wrote: Các bạn cho mình hỏi 3 cái phần tử của mảng đó có hợp lệ không ? đúng rồi đấy bạn...
Sieutoc,1,11/6/2011,Re:Element of array !,line 7:14: unexpected token: const Mừng quá! Mình làm được rồi. Cảm ơn bạn @T.N.D nhiều lắm. Thì ra Scala cũng crazy không kém. ^^
_Trung_Than_Thong,1,11/6/2011,Re:Element of array !,"Nhất Tiếu nại Hà  wrote: line 3:3: unexpected token: ] Rõ ràng đặc tả đã nói hết rồi còn gì k rõ nữa. Try cập phần tử mảng thì theo cấu trúc ident [ <expression>,..] Mà expression không rỗng thì làm sao có kiểu a[] := được. Phải hiểu đề theo đệ qui xíu chứ"
Tan Phat,1,11/6/2011,Re:Element of array !,"_Trung_Than_Thong  wrote: Nhất Tiếu nại Hà  wrote: line 3:3: unexpected token: ] Rõ ràng đặc tả đã nói hết rồi còn gì k rõ nữa. Try cập phần tử mảng thì theo cấu trúc ident [ ,..] Mà expression không rỗng thì làm sao có kiểu a[] := được. Phải hiểu đề theo đệ qui xíu chứ Trong code đặt tả file PT có xét trường hợp expr=null, nên mới truy xuất a[ ] được. class EleExprPT(val id: IdPT, val exprs: List[ExprPT]) extends LefHandSidePT { def this(id: IdPT) = this(id, null) override def toString = if (exprs != null) ""ele("" + id + "",["" + (exprs.head.toString /: exprs.tail)(_ + "","" + _.toString) + ""])"" else id.toString }"
Forever Alone,1,11/6/2011,Re:Element of array !,Tùy thôi. Vấn đề này ko cãi nhau được đâu :-j
BT Lớn,1,11/7/2011,Re:Element of array !,"Vo Thanh Hung wrote: Không được, phải có ít nhất 1 biểu thức. Đặc tả đã hàm ý điều đó rồi thầy đã nói rồi đấy..."
Tin Bui,1,11/5/2011,Hỏi về dạng opt(...) ^^ {..},"Trong ass này mình gặp khá nhiều trường hợp dùng opt() nhất là trong những array vậy các bạn cho mình hỏi là ví dụ như với: opt( expr) ^^ { case Some(a) => ... // làm 1 câu lệnh nào đó case None => ...// nếu mình ko muốn case None này làm j cả thì mình phải ghi thế nào nhỉ, như trong mấy bài lab kì trước thì ghi case None => None đc, nhưng ở đây nó báo lỗi. Mong mọi người chỉ giúp. À thêm nữa là ai có thể giải thích thêm cho mình một ít về hàm repsep() ko? Cảm ơn"
nguyen,1,11/3/2011,Các bạn cho mình hỏi về cái def Show tý nhé !,"với test như thế này var A:integer; trong testsol nó ra là line 1:5: unexpected token: A sao của mình lại ra là line 1:5: unexpected token: *** error: `(' expected but A found trong khi những cái token khác thì nó show đúng. Mong các bạn giúp, mò cái def show bữa giờ :("
V For,1,11/5/2011,Re:Hỏi về dạng opt(...) ^^ {..},"opt (option) tương tự ? : Có hoặc không rep (repeat) tương tự * : Không, một hoặc nhiều"
Tuan Dinh Anh,1,11/7/2011,Re:Hỏi về dạng opt(...) ^^ {..},"Scala ^^  wrote: vi dụ nha repsep(ident,"";"") sẽ tạo ra một list: ident;ident;....ident . list này có thể rỗng cám ơn bạn, bây giờ xài cái ví dụ của bạn, nếu input là 1 cái ident thôi mà ko có dấu chấm phẩy, thì qua cái repsep(ident,"";"") đó, nó trả về cái gì? cái list có một phần tử là ident hay là nó ko nhận và trả về list rổng? Cám ơn lần nửa"
Thanh Pham Minh,1,11/3/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,"Với trong đề yêu cầu xuất line<blank><line>:<column>:<blank>unexpected token:<blank> <token> nhưng trong ví dụ lại có trường hợp xuất <eof> mà <eof> đâu phải token. Trong Stage 1 đã làm, EOF mới là token!"
Long Nguyễn,1,11/3/2011,Các bạn cho mình hỏi về cái def Show tý nhé !,"@nguyen: chỗ này phải xử lí chuỗi đó bạn. @Thanh Pham Minh: đặc tả yêu cầu ra <eof> thì cứ ra vậy đi, chừng nào thầy bảo sửa lại thì hẵng hay. Mình có làm sai thì còn có cái để đổ thừa mà! :))"
Huỳnh Trọng Khiêm,1,11/4/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,"@Long Xử lý sao vậy bạn, mình mò hoài không ra."
Long Nguyễn,1,11/4/2011,Các bạn cho mình hỏi về cái def Show tý nhé !,"code thì ko quăng lên được rồi, mình chỉ có thể gợi ý là dùng .indexOf của string thôi. chúc may mắn!"
nguyen dung,1,11/4/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,Bạn cho xuất cái next.first ra rồi chỉnh sửa cho đẹp là được mà ^^
Huỳnh Trọng Khiêm,1,11/4/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,"Scala ^^  wrote: nguyen dung wrote: Bạn cho xuất cái next.first ra rồi chỉnh sửa cho đẹp là được mà ^^ cái next.first xuất ra nhìu kiểu lỗi quá, ví dụ input là a; thì nó xuất ra: identifier a input var A:real; thì nó xuất ra: ErrorToken(`(' expected but A found) mình dùng .indexOf của string để lấy show dc cái TH này thì TH khác show không dc. k biết làm sao để show cho tất cả các TH đây . line : : unexpected token: mình show được gần hết rồi, chỉ còn cái Bạn dựa vào hàm clean() trong file TestToken mà viết"
tran danh hung,1,11/4/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,vậy cho mình hỏi nếu input: var a:integer; bc; var c:integer; thì output là : line 2:1: unexpected token: b hay: line 2:1: unexpected token: bc
nguyen dung,1,11/4/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,@ tran danh hung: Của mình raline 2:1: unexpected token: bc
nguyen,1,11/4/2011,Các bạn cho mình hỏi về cái def Show tý nhé !,"mình làm chạy được rồi, dựa vào cái hàm clean trong file testtoken ấy, sửa lại tý là OK"
tran danh hung,1,11/4/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,nguyen dung wrote: @ tran danh hung: Của mình raline 2:1: unexpected token: bc mình thì nghĩ là ra: line 2:1: unexpected token: b mới đúng @_@
Vinh Thọt,1,11/5/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,Hì bạn nào lỡ làm ra cái gì thì nghĩ kết quả mình sẽ đúng ra cái đó hjhj => ko biết bạn nào đúng
BKIT 09,1,11/5/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,Gợi ý tí:Cái def show bạn dựa vào hàm clean() trong TestToken ấy. Để in token thì dùng next.first..... nhé !!! Ở đây có thểdùng if...else... sẽ ra đúng theo mọi trường hợp báo lỗi theo yêu cầu đề. Good luck!!!
thanhnghi_py,1,11/7/2011,Re:cac bạn Test cái này xem.,"Scala ^^  wrote: cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k? cái này mình lại parse thành công [proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[true]),ele(a,[i]))]),const(a,[a])] bộ arrayLiteral không nhận string sao các bạn"
Phạm Nguyên Trình,1,11/7/2011,RdivExprPT vs IdivExprPT??!,2 cái này khác nhau thế nào vậy pà kon?
Phúc Trí,1,11/5/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,tran danh hung wrote: nguyen dung wrote: @ tran danh hung: Của mình raline 2:1: unexpected token: bc mình thì nghĩ là ra: line 2:1: unexpected token: b mới đúng @_@ nguyên cái bc là 1 token đó bạn.
Sieutoc,1,11/5/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,Qui Pham Xuan wrote: Gợi ý tí:Cái def show bạn dựa vào hàm clean() trong TestToken ấy. Để in token thì dùng next.first..... nhé !!! Ở đây có thểdùng if...else... sẽ ra đúng theo mọi trường hợp báo lỗi theo yêu cầu đề. Good luck!!! Mình cũng dùng if-else để thể hiện nhưng mà không hiểu bị lỗi gì. Nếu chỉ if rồi else thì không có lỗi. Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là "type missmatch; found: Unit required: String". Các bạn giúp mình với.
Long Nguyễn,1,11/6/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,"Mai Hoa Đạo  wrote: Qui Pham Xuan wrote: Gợi ý tí:Cái def show bạn dựa vào hàm clean() trong TestToken ấy. Để in token thì dùng next.first..... nhé !!! Ở đây có thểdùng if...else... sẽ ra đúng theo mọi trường hợp báo lỗi theo yêu cầu đề. Good luck!!! Mình cũng dùng if-else để thể hiện nhưng mà không hiểu bị lỗi gì. Nếu chỉ if rồi else thì không có lỗi. Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là ""type missmatch; found: Unit required: String"". Các bạn giúp mình với. Chắc là bạn xuống dòng không đúng chỗ. Không bao giờ được xuống dòng chữ ""else"", do Scala không có ; cuối câu lệnh nên sẽ nghĩ rằng if không có else."
Tin Bui,1,11/6/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,Roni Mikado wrote: Gợi ý tí:Cái def show bạn dựa vào hàm clean() trong TestToken ấy. Để in token thì dùng next.first..... nhé !!! Ở đây có thểdùng if...else... sẽ ra đúng theo mọi trường hợp báo lỗi theo yêu cầu đề. Good luck!!! Mấy bạn cho mình hỏi là sau khi viết hàm dựa trên TestToken rồi mình dùng dấu gì để nối với " unexpected token: " vậy? Vì có if ... else nên chắc ko dùng đc dấu + như mấy cụm trước rồi
Long Nguyễn,1,11/6/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,"DoomAce  wrote: Roni Mikado wrote: Gợi ý tí:Cái def show bạn dựa vào hàm clean() trong TestToken ấy. Để in token thì dùng next.first..... nhé !!! Ở đây có thểdùng if...else... sẽ ra đúng theo mọi trường hợp báo lỗi theo yêu cầu đề. Good luck!!! Mấy bạn cho mình hỏi là sau khi viết hàm dựa trên TestToken rồi mình dùng dấu gì để nối với "" unexpected token: "" vậy? Vì có if ... else nên chắc ko dùng đc dấu + như mấy cụm trước rồi + vô tư, đây là Scala chứ không phải Crazy."
thanhnghi_py,1,11/7/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,"cho hỏi là cái next.first có tất cả là bao nhiêu trường hợp vậy, theo mình làm thì có: EOF identifier a `a' vậy mà một hồi vẫn thiếu trường hợp ErrorToken(`(' expected but A found) hok biết là còn thiếu cái gì nữa ko"
tuong vo,1,11/7/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,"có nhiều trường hợp lắm bạn xét theo độ dài của lỗi ,sử dụng thêm hàm substring nữa là sẽ xuất được tất cả lỗi"
huongcuibap,0,11/7/2011,Re:Các bạn cho mình hỏi về cái def Show tý nhé !,cơ bản thì dùng hàm clean() như mấy bạn trên kia. kết hợp thêm 1 số hàm về StringBuilder :
Nhất Tiếu nại Hà,1,11/7/2011,Re:cac bạn Test cái này xem.,"Trần Gia Lạc wrote: Scala ^^  wrote: cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k? cái này mình lại parse thành công [proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[true]),ele(a,[i]))]),const(a,[a])] bộ arrayLiteral không nhận string sao các bạn kết quả....: line 1:10: unexpected token: 'a'"
Phúc Trí,1,11/7/2011,cac bạn Test cái này xem.,"Nhất Tiếu nại Hà  wrote: Nhat Nguyen wrote: [proc(main,[],[assign(ele(a,[1.2,1]),1)])] zay laf trong kai lefhandside cua minh nhan toan bo lun ha.....sao kai mang gi ky the cungx nhan ko bik dat ta thi chang noi gi????hic.....dien lun mat thoi sao lại Spec ko có nói bạn.nó nè: <id>[<expr>,…,<expr>] expr là những cái nào thì bạn xem lại. đúng là a[1.2 , 1] nhìn hơi kì nhưng ass1 chỉ làm tới đây. phần kiểm tra chỗ đó nằm ở ass2."
thanhnghi_py,1,11/7/2011,Re:cac bạn Test cái này xem.,"đã đọc sót The elements may be integer, real, boolean or array constant"
Quái,1,11/7/2011,Re:cac bạn Test cái này xem.,procedure a(); begin a[4]:=3 end; test này ra gì vậy ta?
Nhất Tiếu nại Hà,1,11/7/2011,Re:cac bạn Test cái này xem.,Rec4rx  wrote: procedure a(); begin a[4]:=3 end; test này ra gì vậy ta? ra này nè bạn: line 4:1: unexpected token: end vì ko có dấu chấm phẩy sau a[4]:=3 đó
Quái,1,11/7/2011,Re:cac bạn Test cái này xem.,"Nhất Tiếu nại Hà  wrote: Rec4rx  wrote: procedure a(); begin a[4]:=3 end; test này ra gì vậy ta? ra này nè bạn: line 4:1: unexpected token: end vì ko có dấu chấm phẩy sau a[4]:=3 đó ok, giống rồi ku, còn test nào ngon ngon không quăng lên thử..."
LAV,1,11/7/2011,Re:cac bạn Test cái này xem.,"Nhất Tiếu nại Hà  wrote: Trần Gia Lạc wrote: Scala ^^  wrote: cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k? cái này mình lại parse thành công [proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[true]),ele(a,[i]))]),const(a,[a])] bộ arrayLiteral không nhận string sao các bạn kết quả....: line 1:10: unexpected token: 'a' sao mình ra còn có dấu "" "" nữa??? line 1:10: unexpected token: "" 'a' """
Forever Alone,1,11/7/2011,Re:cac bạn Test cái này xem.,"Scala ^^  wrote: khi mà test cái này, mình để hàm show xuất ra result.toString thì thấy nó bắt lỗi ngay dấu ' bắt đầu string trong array, tại array k nhận string. mấy bạn thử coi đi, theo tớ thì line 1:10: unexpected token: ' mới đúng cho tớ hỏi thêm procedure main(); begin a:=not-not 5; end; ra gì? mình ra [proc(main,[],[assign(a,bnot(bnot(bnot(5))))])] - ở đây 1 ngôi nên là bnot Mình nghĩ là vì cái 'a' là một cái token hợp lệ nên nó sẽ xuất ra 'a' luôn."
M.U.,1,11/7/2011,Re:cac bạn Test cái này xem.,"Trần Gia Lạc wrote: Scala ^^  wrote: cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k? cái này mình lại parse thành công [proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[true]),ele(a,[i]))]),const(a,[a])] bộ arrayLiteral không nhận string sao các bạn The elements may be integer, real, boolean or array constant. Spec ghi rõ là ko có string rồi bạn."
Dream,1,11/7/2011,Re:cac bạn Test cái này xem.,"Scala ^^  wrote: test thu cai nay no bao loi sao may ban const a=aba[1]; minh moi sua lai, const a=['a']; se bao loi lun cai 'a' Của mình là: line 1:9: unexpected token: aba"
M.U.,1,11/7/2011,Re:cac bạn Test cái này xem.,"Dream  wrote: Scala ^^  wrote: test thu cai nay no bao loi sao may ban const a=aba[1]; minh moi sua lai, const a=['a']; se bao loi lun cai 'a' Của mình là: line 1:9: unexpected token: aba me too"
Phạm Nguyên Trình,1,11/7/2011,Re:RdivExprPT vs IdivExprPT??!,còn mấy cái nữa như: NeExprPT GeExprPT vsGreaterExprPT LeExprPT vsLessExprPT Mấy cái này xài bậy là fail testcase như chơi @@ Ai rõ chỉ với @@
BT Lớn,1,11/7/2011,Re:RdivExprPT vs IdivExprPT??!,Phạm Nguyên Trình wrote: còn mấy cái nữa như: NeExprPT GeExprPT vsGreaterExprPT LeExprPT vsLessExprPT Mấy cái này xài bậy là fail testcase như chơi @@ Ai rõ chỉ với @@ theo mình nghĩ : NeExprPT : <> GeExprPT : >= LeExprPT: <=
Phạm Nguyên Trình,1,11/7/2011,Re:RdivExprPT vs IdivExprPT??!,"Cao Đại wrote: Phạm Nguyên Trình wrote: còn mấy cái nữa như: NeExprPT GeExprPT vsGreaterExprPT LeExprPT vsLessExprPT Mấy cái này xài bậy là fail testcase như chơi @@ Ai rõ chỉ với @@ theo mình nghĩ : NeExprPT : <> GeExprPT : >= LeExprPT: <= Uhm, còn cái RdivExprPT vs IdivExprPT thì pó hand @@"
tuong vo,1,11/7/2011,Re:RdivExprPT vs IdivExprPT??!,AddExprPT // cộng SubExprPT // trừ TimesExprPT // nhân RdivExprPT // chia thực "/" IdivExprPT // chia nguyên "div" ImodExprPT // mod NeExprPT // <> EqlExprPT // = GeExprPT // >= GreaterExprPT // > LeExprPT // <= LessExprPT // < BorExprPT // or BandExprPT // and BnotExprPT // not hoặc - ExponentExprPT // ^ FuncCallExprPT // gọi hàm ConsPT // trị hằng số LefHandSidePT // left hand side VarExprPT //biến EleExprPT //truy cập mảng
Long Nguyễn,1,11/7/2011,Re:RdivExprPT vs IdivExprPT??!,"Guest User wrote: AddExprPT // cộng SubExprPT // trừ TimesExprPT // nhân RdivExprPT // chia thực ""/"" IdivExprPT // chia nguyên ""div"" ImodExprPT // mod NeExprPT // <> EqlExprPT // = GeExprPT // >= GreaterExprPT // > LeExprPT // <= LessExprPT // < BorExprPT // or BandExprPT // and BnotExprPT // not hoặc - ExponentExprPT // ^ FuncCallExprPT // gọi hàm ConsPT // trị hằng số LefHandSidePT // left hand side VarExprPT //biến EleExprPT //truy cập mảng => cái này bữa mình viết nè chứ đâu, hok phải của thầy! :D có cái chỗ dấu - ấy hình như sai rồi: theo code thầy thìSubExprPT có nhận 1 ngôi nên - 1 ngôi là sub chứ không phải bnot đâu."
Phạm Nguyên Trình,1,11/7/2011,Re:RdivExprPT vs IdivExprPT??!,AddExprPT // cộng SubExprPT // trừ TimesExprPT // nhân RdivExprPT // chia thực "/" IdivExprPT // chia nguyên "div" ImodExprPT // mod NeExprPT // <> EqlExprPT // = GeExprPT // >= GreaterExprPT // > LeExprPT // <= LessExprPT // < BorExprPT // or BandExprPT // and BnotExprPT // not hoặc - ExponentExprPT // ^ FuncCallExprPT // gọi hàm ConsPT // trị hằng số LefHandSidePT // left hand side VarExprPT //biến EleExprPT //truy cập mảng
M.U.,1,11/7/2011,Mọi người cho mình hỏi về xuất chuỗi,"const a='a'; cấu trúc PT sinh ra là: const(a, ' a ' ) vậy làm sao để nó hiện ra dc cái dấu nháy đó vậy. Cám ơn mọi người."
tuong vo,1,11/7/2011,Re:Mọi người cho mình hỏi về xuất chuỗi,xoa ham substring o def const di
M.U.,1,11/7/2011,Re:Mọi người cho mình hỏi về xuất chuỗi,"Guest User wrote: xoa ham substring o def const di cám ơn bạn, mình làm dc rùi ^^"
abc,1,11/24/2011,Tut3,Em chào thầy em tên là Võ Minh Tùng MSSV : 50802555 em không rõ ở tut3 em làm được gần hết có sai ở 1 vài câu(sai khá nhiều) nhưng không hiểu sao em bị 0 điểm mong thầy kiểm tra lại em học các tiết tut và lab vào thứ 3 (từ 2h- 4h) lớp KSTN
Quái,1,11/7/2011,Re:1 thắc mắc cần đính chính!,"[proc(a,[],[assign(a,ele(b,[add(1,2),ele(c,[2])]))])]"
Nhất Tiếu nại Hà,1,11/6/2011,cac bạn Test cái này xem.,"var y,z: integer; procedure main(); begin y := 1; writeRealLn(foo(y)); end; const x = 1.2e3; function foo(p:integer):real; begin return p * x; end; kết quả sẽ là gì vậy mấy bạn???"
Dream,1,11/24/2011,Grade Tut 3,Em tên: Trần Hồ Sang MSSV 50801784 Tut 3 em có đi học tiết 11 -12 Thứ 5 và làm 5/5 bài nhưng em lại bị điểm 0. Mong anh xem xét !
M.U.,1,11/7/2011,Re:1 thắc mắc cần đính chính!,"Rec4rx  wrote: [proc(a,[],[assign(a,ele(b,[add(1,2),ele(c,[2])]))])] me too"
Sieutoc,1,11/7/2011,Re:1 thắc mắc cần đính chính!,"[proc(a,[],[assign(a,ele(b,[add(1,2),ele(c,[2])]))])]"
Crazy Boy,1,11/7/2011,1 thắc mắc cần đính chính!,keke. The same
Bruce Wayne,1,11/7/2011,1 thắc mắc cần đính chính!,"Vậy còn: const a=b[3]; thì xuất ra: line 1:9: unexpected token: b,  hay là parse dc bình thường vậy ạ"
Nhất Tiếu nại Hà,1,11/7/2011,1 thắc mắc cần đính chính!,"T.D.N  wrote: Vậy còn: const a=b[3]; thì xuất ra: line 1:9: unexpected token: b,  hay là parse dc bình thường vậy ạ ra là : line 1:9: unexpected token: b"
Bruce Wayne,1,11/7/2011,1 thắc mắc cần đính chính!,"Nhất Tiếu nại Hà  wrote: T.D.N  wrote: Vậy còn: const a=b[3]; thì xuất ra: line 1:9: unexpected token: b,  hay là parse dc bình thường vậy ạ ra là : line 1:9: unexpected token: b Uhm, vậy thì giống mình"
Dream,1,11/7/2011,1 thắc mắc cần đính chính!,"T.D.N  wrote: Vậy còn: const a=b[3]; thì xuất ra: line 1:9: unexpected token: b,  hay là parse dc bình thường vậy ạ Mình không parser dc Lỗi line 1:9: unexpected token: b"
Nhất Tiếu nại Hà,1,11/7/2011,1 thắc mắc cần đính chính!,"Heaven  wrote: Còn trường hợp này thì sao mọi người: procedure a(); begin a := a[a,a[a]]; end; Kết Quả: [proc(a,[],[assign(a,ele(a,[a,ele(a,[a])]))])]"
Sieutoc,1,11/6/2011,Re:cac bạn Test cái này xem.,"[var(y,int),var(z,int),proc(main,[],[assign(y,1),call(writeRealLn,[call(foo,[y])])]),const(x,1.2e3),func(foo,[par(p,int)],float,[return(times(p,x))])]"
Nhất Tiếu nại Hà,1,11/6/2011,Re:cac bạn Test cái này xem.,"var y,z: integer; procedure main(); begin y := 1; writeRealLn(foo(y)); end; const x = 1.2e3; function foo(p:integer):real; begin return p * x; end; cho mình hỏi cái chổ writeRealLn(foo(y)); là gì vậy bạn? code mình nó ko hiểu chổ này..báo lỗi..chỉnh từ sáng giờ..:("
Sieutoc,1,11/6/2011,Re:cac bạn Test cái này xem.,theo mình hiểu là: writeRealLn(foo(y)); là một procedure. Và chỗ này là một lời gọi hàm ( CallStmtPT)
Nhất Tiếu nại Hà,1,11/6/2011,Re:cac bạn Test cái này xem.,Mai Hoa Đạo  wrote: theo mình hiểu là: writeRealLn(foo(y)); là một procedure. Và chỗ này là một lời gọi hàm ( CallStmtPT) ok.thank bạn!:) chổ funcall minh con mot tí vấn đề chưa giải quyết xong.
Bruce Wayne,1,11/6/2011,cac bạn Test cái này xem.,theo mình hiểu là:
Nhất Tiếu nại Hà,1,11/6/2011,cac bạn Test cái này xem.,writeRealLn(foo(y));
Nhất Tiếu nại Hà,1,11/6/2011,Re:cac bạn Test cái này xem.,là một procedure. Và chỗ này là một lời gọi hàm ( CallStmtPT)
Phúc Trí,1,11/6/2011,Re:cac bạn Test cái này xem.,Test này mấy bạn output là gì vậy: const a=b[3];
Nhất Tiếu nại Hà,1,11/6/2011,Re:cac bạn Test cái này xem.,T.D.N  wrote: Test này mấy bạn output là gì vậy: const a=b[3]; ket qua ne banj: line 1:9: unexpected token: b
Sieutoc,1,11/6/2011,Re:cac bạn Test cái này xem.,thêm 1 test nữa các cậu ra ntn vậy? var a: array[5] of integer; // global variable procedure fill(x:array[5] of integer); begin var a:real; var x:real; a:=5.9; init(x); end; procedure init(x:array[5] of integer); begin var i:integer; //block variable i:=0; x[i]:=a[i]; // a is global var. end; procedure main(); begin fill(a); end; của tớ nó ra line 13:3: unexpected token: i trong kai ass này mình có làm cái golbal vs kai block ko mấy cậu???? còn chổ where <lefthandside> is a variable or an element of an array vậy an element of an array nó cho kiểu INT thôi đúng ko? hay còn chấp nhận kiểu String nữa???
Sieutoc,1,11/6/2011,Re:cac bạn Test cái này xem.,"[var(a,arr([5],int)),proc(fill,[par(x,arr([5],int))],[var(a,float),var(x,float),assign(a,5.9),call(init,[x])]),proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[i]),ele(a,[i]))]),proc(main,[],[call(fill,[a])])] cái i đó là 1 expr( variable) đó bạn, ko phải String đâu. x[i] và a[i] là element nên ko lỗi j cả. cái element nó định nghĩa chỗ toán tử [ ] đó bạn"
Nhất Tiếu nại Hà,1,11/6/2011,Re:cac bạn Test cái này xem.,ah conf chổ gọi hàm mình có thể Null đc ko? vd: procedure main(); begin fill(); end;
Sieutoc,1,11/6/2011,Re:cac bạn Test cái này xem.,"[var(a,arr([5],int)),proc(fill,[par(x,arr([5],int))],[var(a,float),var(x,float),assign(a,5.9),call(init,[x])]),proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[i]),ele(a,[i]))]),proc(main,[],[call(fill,[a])])]"
Bruce Wayne,1,11/6/2011,Re:cac bạn Test cái này xem.,"Nhất Tiếu nại Hà  wrote: ah conf chổ gọi hàm mình có thể Null đc ko? vd: procedure main(); begin fill(); end; Ý của bạn có phải là null danh sách tham số ko. [proc(main,[],[call(fill,[])])]"
Sieutoc,1,11/6/2011,Re:cac bạn Test cái này xem.,uh.đúng rồi...mìh mới check lại :D...cho phép Null
Nhất Tiếu nại Hà,1,11/6/2011,Re:cac bạn Test cái này xem.,Cho mình hỏi:. Có vài bạn nói là trong đặc tả có nói là xuất ra <eof> mà minh tìm ko thấy. Bạn nào biết chỗ nào chỉ giùm mình. Cảm ơn.
meo_lac,1,11/24/2011,grade tut 4,"Em là Cao Tiến Định, mssv 50900581. Em học nhóm thứ 3, tiết 11-12, phòng 211b1. Em có đi học, làm bài đầy đủ và nộp bài, chỉ k đc gọi lên bảng làm bài nhưng điểm lại là 0/10. Mong thầy xem lại giúp em. Em xin cảm ơn."
meo_lac,1,11/24/2011,Re:grade tut 4,"Vo Thanh Hung wrote: Em được 10, do sai sót lúc TA nhập điểm. Đã điều chỉnh, em kiểm tra lại. Em cảm ơn thầy"
James Blunt,1,11/6/2011,Re:cac bạn Test cái này xem.,"T.D.N  wrote: Cái bảng cuối cùng trong file Assignment_1.0.pdf đó bạn Cảm ơn bạn. Thì ra nó ở trong Assignment_1.0.pdf, hèn gì mình tìm hoài trong CrazySpec ko thấy"
Sieutoc,1,11/6/2011,Re:cac bạn Test cái này xem.,thêm 1 test nào:D:D: procedure init(x:array[5] of integer); begin var i:integer; //block variable i:=0; x[true]:=a[i]; // a is global var. end;
Nhat Nguyen,1,11/6/2011,Re:cac bạn Test cái này xem.,"kq cua minh ne: [proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[true]),ele(a,[i]))])]"
Bruce Wayne,1,11/6/2011,Re:cac bạn Test cái này xem.,"[proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[true]),ele(a,[i]))])]"
Nhat Nguyen,1,11/6/2011,Re:cac bạn Test cái này xem.,cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k?
Nhất Tiếu nại Hà,1,11/6/2011,Re:cac bạn Test cái này xem.,Scala ^^  wrote: cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k? Minh ra unexpected token 'a'
Nhat Nguyen,1,11/7/2011,Re:cac bạn Test cái này xem.,T.D.N  wrote: Scala ^^  wrote: cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k? Minh ra unexpected token 'a' Mình cũng thế
Nhất Tiếu nại Hà,1,11/7/2011,Re:cac bạn Test cái này xem.,"khi mà test cái này, mình để hàm show xuất ra result.toString thì thấy nó bắt lỗi ngay dấu ' bắt đầu string trong array, tại array k nhận string. mấy bạn thử coi đi, theo tớ thì line 1:10: unexpected token: ' mới đúng cho tớ hỏi thêm procedure main(); begin a:=not-not 5; end; ra gì? mình ra [proc(main,[],[assign(a,bnot(bnot(bnot(5))))])] - ở đây 1 ngôi nên là bnot"
Nhat Nguyen,1,11/7/2011,cac bạn Test cái này xem.,"[proc(main,[],[assign(a,bnot(sub(bnot(5))))])]"
Tran Hoang,1,11/27/2011,grade tut 4,"Em tên là Trần Minh Hoàng, MSSV 50900939, học TUT ngày thứ 5 tiết 9-10. Hôm đó em có đi học và làm bài đầy đủ, lúc lên bảng em có làm sai vài chỗ nhưng em cũng không nghĩ mình xứng đáng với điểm 0. Mong các thầy coi lại."
Tran Hoang,1,11/28/2011,grade tut 4,"Dạ điểm em đã được sửa rồi, cám ơn anh."
Nhất Tiếu nại Hà,1,11/7/2011,cac bạn Test cái này xem.,"Nhất Tiếu nại Hà  wrote: [proc(main,[],[assign(a,bnot(sub(bnot(5))))])] Đúng rùi."
Hieu Pham Le,1,11/24/2011,Re:Thắc mắc điểm tut3 (post vào đây),"Thầy ơi, em có đi học tut3 và nộp bài đầy đủ, nhưng không biết tại sao điểm tut3 của em lại là 0/10. Thầy có thể xem lại giúp em không ạ ? Tên: Phạm Lê Hiếu MSSV: 50900826"
abc,1,11/24/2011,Re:Thắc mắc điểm tut3 (post vào đây),Em chào thầy em tên là Võ Minh Tùng MSSV : 50802555 em không rõ ở tut3 em làm được gần hết có sai ở 1 vài câu(sai khá nhiều) nhưng không hiểu sao em bị 0 điểm mong thầy kiểm tra lại em học các tiết tut và lab vào thứ 3 (từ 2h- 4h) lớp KSTN (em đã post ở topic kia rồi nên em xin chuyển vào đây đễ dễ xem xét và cập nhật )
TV,1,11/24/2011,Re:Thắc mắc điểm tut3 (post vào đây),MSSV: 50903391 Họ và tên: Nguyễn Quốc Vương Thầy xem lại thử tại sao e lại 0/10 vậy ạh? Cảm ơn thầy nhiều.
Tuan Nguyen,1,11/25/2011,Thắc mắc điểm tut3 (post vào đây),"Họ tên: Nguyễn Hoàng Tuân MSSV: 50903059 Em có đi học tiết 9-10 chiều thứ 3 ,có làm và nộp tut3 nhưng không hiểu sao em lại bị 0/10.Mong thầy xem xét lại,em chân thành cảm ơn"
Nhan Tran Van,1,11/25/2011,Thắc mắc điểm tut3 (post vào đây),"Họ tên: Trần Văn Nhàn MSSV: 50901782 Em có đi học, có làm và nộp tut3 nhưng không hiểu sao em lại bị 0/10. Mong thầy xem xét lại,em chân thành cảm ơn"
Huỳnh Tiến Tài,1,11/25/2011,Re:Thắc mắc điểm tut3 (post vào đây),"Em cũng như các bạn, có đi học và làm bài đầy đủ nhưng cũng bị 0đ tut 3. Tên: Huỳnh Tiến Tài, MSSV: 50902307. Mong thầy xem xét lại. Em xin cảm ơn thầy!"
Đặng Toàn Trí,1,11/26/2011,Re:Thắc mắc điểm tut3 (post vào đây),Đặng Toàn Trí MSSV: 50902919 Em cũng như các bạn. Hình lớp của tụi em: MT09KHTN đều bị điểm 0 rất nhìu.
Forever Alone,1,12/10/2011,Thắc mắc điểm lab5,Thầy cho em hỏi là bài lab5 của em tại sao lại bị 5 điểm vậy ạ? MSSV của em là 50902263. Em cám ơn.
Hoang 1417,1,11/25/2011,Re:Thắc mắc điểm lab4 (post vào đây),"Thưa thầy, em là Lê Hoàng ( MSSV: 50900905 ) , lớp thứ 5 tiết 78 Hôm học lab4 em học bù qua thứ 6 tiết 11-12, em có nộp bài và thầy có gọi kiểm tra bài chạy thử nhưng hiện tại thấy lab4 bị 0 điểm Mong thầy xem lại giùm, cám ơn thầy"
Hoang 1417,1,12/1/2011,Re:Thắc mắc điểm lab4 (post vào đây),"vâng, cám ơn thầy"
_Đào_Hoa_Đảo_Chủ_,1,12/19/2011,Thi cuối kỳ,Thầy cho em hỏi cuối kỳ thi đề đóng hay mở. Em thích đóng^^
Nhan Nguyen Van,1,12/19/2011,Re:Thi cuối kỳ,Vote cho đề đóng
Nguyen Hoang,1,12/20/2011,Re:Thi cuối kỳ,Thi đề đóng đi thầy.
thinh van,1,12/23/2011,Re:Thi cuối kỳ,"em cũng ủng hộ đề đóng, hì, đem tài liệu zô dở có kịp hok, muk đề mở lại khó nữa"
BKIT 09,1,12/25/2011,Re:Thi cuối kỳ,Cái này ở lớp thầy đã trả lời rồi. Đề mở
Vinh Thọt,1,12/25/2011,Bài 5 solution Tut5,Cho mình ở câu 5a tut 5 sao gọi đệ quy mà không có trường function value trả về zậy mấy bạn.. trong solution của thầy áh.
MFC.Maximus,1,12/25/2011,Re:Bài 5 solution Tut5,"s là kết quả trả về, đây là procedure thôi chứ không phải là function, bạn xem kỹ lại đề :)"
Vinh Thọt,1,12/25/2011,Re:Bài 5 solution Tut5,tk ban
Kuno ␛ϟ,1,11/18/2011,Kết quả assignment 1 - stage 2,"Thưa thầy, em có sai sót trong phần nộp bài, do không xem kĩ trong phần Notice, nên em đã đổi tên file nộp lại là crazy2011.scala(viết thường) dẫn đến thầy không nhận được file. Mong thầy xem bài lại dùm em. 

Em cảm ơn thầy.



MSSV: 50900041	

HT  : Bùi Tuấn Anh"
Tin Bui,1,12/23/2011,Hỏi về sol TuT 5 và tut 3,"Cho mình hỏi bài tut 5 câu số 1 cái passed- by-name : After 3rd swap value : 2 list: {3, 2, 1, 7, 9} Mình ko hiểu là tại sao swap ra mà value vẫn = 2? phải là 5 mới đúng chứ còn bài tut3, câu số 3/b phần Global của cái sub2 gọi lần thứ 2 có a(Main). b(Main) . Sub1. trong khi mục Non-Local a(Main). b(Sub3) .c(Sub3).Sub1.Sub2.Sub3. Làm sao có đến 2 cái b đc . Mình nghĩ cái b( Main) trong global phải xóa đi Có ai biết chỉ mình cái nhé, Thank"
MFC.Maximus,1,12/25/2011,Re:Hỏi về sol TuT 5 và tut 3,"1 chút góp ý về pass by name, during 3rd swap, swap(value, list[value]); void swap(int a, int b) { int temp; temp = a; ( temp = value = 1;) a = b; ( value = list[value] = list[1] = 2 -> value = 2 ) b = temp; ( list [value] = temp = 1 (value = 2) -> list[2] = 1 ) } after 3rd swap value = 2 list[value] = 1"
MFC.Maximus,1,12/25/2011,Re:Hỏi về sol TuT 5 và tut 3,bài 3b tut3 dynamic referencing environments chứ không phải static referencing environments
Tin Bui,1,12/25/2011,Re:Hỏi về sol TuT 5 và tut 3,Cảm ơn bạn mình hiểu bài pass-by-name của tut5 và tut3 rồi! ^^
librastar,1,12/25/2011,Miss Lab6 grade?,Thưa thầy chưa có điểm lab6 phải không ạ? Vì em có điểm lab7 rồi mà điểm lab6 vẫn chưa thấy? MSSV: 50800922.
none none,1,11/18/2011,Kết quả assignment 1 - stage 2,em là trần mạnh hoàng mssv 50800726. khi nộp bài em thấy trênn sakai báo nộp file crazy.scala viết thường nên em đã nộp file name là crazy.scala viết thường. mong thầy xem xét lại bài của e.
free_love,1,11/18/2011,Re:Kết quả assignment 1 - stage 2,
facebook.com,1,11/18/2011,Kết quả assignment 1 - stage 2,"Em tên là: Đoàn Phúc Hiến MSSV: 50900789 Thưa thầy, do nhớ lộn tên file mà em nộp nhầm file crazy2011.scala. Mong thầy xem xét lại cho chúng em. Em xin chân thành cảm ơn!"
Vo Quoc Hieu,1,11/18/2011,Re:Kết quả assignment 1 - stage 2,"Thầy cho em hỏi trong result của em có rất nhiều case Test bị lỗi này , cho em hỏi lỗi này là sao a ? Test 8 failed

Correct result compares with your result

1c1

< line 3:8: unexpected token: booLean

\ No newline at end of file

---

> line 3:8: unexpected token: booLean

***************************"
Pham  Van Giang,1,11/18/2011,Kết quả assignment 1 - stage 2,"Em tên là : Phạm Văn Giang MSSV: 50900679 Thưa thầy, do lúc nộp trên sakai e thấy tên file ghi la crazy2011.scala nên em đã đổi lại tên file. Kết quả là không tìm thấy bài làm của em.mong thầy xem xét lại cho em. Em xin chân thành cảm ơn"
Bruce Wayne,1,11/18/2011,Re:Kết quả assignment 1 - stage 2,"Vo Quoc Hieu wrote: Thầy cho em hỏi trong result của em có rất nhiều case Test bị lỗi này , cho em hỏi lỗi này là sao a ? Test 8 failed

Correct result compares with your result

1c1

< line 3:8: unexpected token: booLean

\ No newline at end of file

---

> line 3:8: unexpected token: booLean

*************************** Em cũng bị lỗi giống như bạn này: Test 3 failed

Correct result compares with your result

1c1

< line 1:5: unexpected token: A

\ No newline at end of file

---

> line 1:5: unexpected token: A 

\ No newline at end of file

***************************



Mong thầy giải đáp!"
Kuno ␛ϟ,1,11/19/2011,Re:Kết quả assignment 1 - stage 2,"Thưa thầy, nếu có thể xin thầy chấm lại cho trường hợp đổi tên file nộp (chữ thường) sớm hơn được không thầy, vì các bài này chưa được chấm qua máy, không biết có các lỗi UTF-8 hoặc các lỗi khác để thắc mắc kịp thời hạn của thầy. Em cám ơn"
Nguyen Hai Dang,1,11/10/2011,Danh sách cấm thi và quy định 5 con 0.,Thưa thầy em có một vài thắc mắc về vấn đề này mong thầy giải đáp. Hồi đầu năm học em có nghe thầy hướng dẫn trên lớp có thông báo về quy trình tính điểm môn học như sau: + Final test: 40% + Middle test: 20% + Assignment: 30% ( 2 bài) + Tut + Lab: 10% Trong đó 5 con 0 chỉ tính các buổi TUT + LAB và không nhắc tới các buổi điểm danh trên lớp học lý thuyết. Xét về các môn học trước như Kỹ Thuật Lập Trình và Cấu Trúc Dữ Liệu thì em thấy các con 0 này cũng chỉ tính điểm TUT + LAB nên việc tính các buổi điểm danh trên lớp đã gây không ít bất ngờ cho em vào nhiều bạn khác. Điều này dẫn đến nhiều người đã vượt qua mốc 5 theo thông báo của thầy. Còn theo quan điểm của em thì việc tính luôn các buổi điểm danh trên lớp có phần không được hợp lý. Em được biết là sinh viên khoa mình rất chủ động trong việc đi làm thêm bên ngoài vì đặc tính chuyên ngành CNTT. Đặc biệt là sinh viên từ năm 3 trở đi. Vì thế để có thể tham gia đầy đủ các buổi học lý thuyết là rất khó thực hiện. Còn xét về mặt bằng chung thì SV Bách Khoa có tinh thần tự học và tự nghiên cứu là rất cao nên việc điểm danh các buổi lý thuyết là không được hợp lý. Nhưng em cũng không phủ nhận lợi ích các buổi học lý thuyết là vô cùng to lớn nhưng theo ý kiến cá nhân của em thì các buổi học lý thuyết nên mang tính tự do hơn cho sinh viên. Mong thầy xem xét.
Binh Nguyen Van,1,12/27/2011,thi cuối kì,theo quán tính kết quả làm tròn lên 3 diểm rớt khỏi tay. huhu :((
hoang nguyen,1,11/19/2011,Re:Kết quả assignment 1 - stage 2,Chào anh. Em ten : Nguyễn Giang Phương Hoàng MSSV : 50800709 Em đã chỉnh lại file là crazy.scala nên kết quả nộp là không tìm thấy file. Mong anh xem lại vì lúc nộp em không cẩn thận . em cảm ơn anh
Huỳnh Tiến Tài,1,11/19/2011,Re:Kết quả assignment 1 - stage 2,Em đã hiểu đc lỗi sai của mình: line 1:5 : unexpected token: A line 1:5 : unexpected token: A Tuy nhiên em chỉ muốn hỏi là không biết có thể du di cho chúng em được không? Vì định dạng xuất ra sai mà mất 40% test case rồi! :( Chúng em đều đã cố gắng và có thể nói kết quả đều đúng nhưng chỉ sai ở chỗ định dạng output! Mong a xem xét!
free_love,1,11/21/2011,Re:Kết quả assignment 1 - stage 2,em cũng bị như bạn...mong anh châm trước cho :( mssv 50801987
huongcuibap,0,11/21/2011,Re:Kết quả assignment 1 - stage 2,"Test 39 failed

Correct result compares with your result

1d0

< line 3:16: unexpected token: 9.8

\ No newline at end of file





Em bị lỗi này hầu hết. Mong thầy xem xét.



Nguyễn Quốc Toản

MSSV: 50602564"
Kuno ␛ϟ,1,12/14/2011,Re:Kết quả assignment 1 - stage 2,
Thanh Pham Minh,1,11/10/2011,Danh sách cấm thi và quy định 5 con 0.,Em nhớ có lần thầy cho làm bài trong giờ lý thuyết và có nói thêm là để thầy xem các em tiếp thu được đến đâu để điều chỉnh việc giảng dạy cho phù hợp. Lần đó em lên bảng làm nên lúc xuống không nộp lại giấy (không kịp làm vô giấy). Thầy cho em hỏi em có bị tính là vắng buổi đó không ạ? Mã số sinh viên của em là 50902476. Em cảm ơn ạ.
Cơn Mưa Tình Yêu,1,11/10/2011,Danh sách cấm thi và quy định 5 con 0.,"1. Aims: - Learn important principles of programming languages - Learn basic components of programming languages - Learn programming language paradigms - Improve programming and software engineering skills 2. Course outline: Language design principles. Syntax and basic semantics. Data types. Control structures. Abstract data types and modules. Object-oriented programming. Functional programming. Logic programming. Parallel programming. 3. Learning outcomes: On completion of this course, students should be able to: Knowledge: - construct regular expressions to formally describe lexical of a programming language - write context free grammars to formall describe gramar of a programming language - have a working knowledge of formal language specification - understand components of a programming language - distinguide programming language paradigms Skills: - write scanners, parsers, semantic analysers using Scala - specify formally the lexical and syntax of a language - use the data structures and algorithms employed within an interpreter - write large functional programs using Scala 4. Students who have 5 zeros tut/lab at the end of the semester will be banned from final exam 5. midterm: 20% Final: 40% Lab/tut: 10% Assignment: 30% Hài! Mình mới vắng có bữa tut. Giờ tự nhiên ở đâu ra thêm 2 con zero từ trên trời rơi xuống! Thanh Pham Minh wrote: Em nhớ có lần thầy cho làm bài trong giờ lý thuyết và có nói thêm là để thầy xem các em tiếp thu được đến đâu để điều chỉnh việc giảng dạy cho phù hợp. Em cảm ơn ạ. Khi thầy bảo thế mình nghĩ việc nộp bài hay không không quan trọng nên cũng chả thèm nộp. Nói đúng ra là cả hai buổi đó mình đều có mặt cả! Còn việc điểm danh là thầy mới nói hôm thứ hai (7/11) sau khi đã thu bài xong. Nếu vậy thì thầy chỉ được phép tính số lượng vắng lý thuyết từ buổi học tiếp theo (14/11) mà thôi! // Vắng Tut thì mình cũng đi học bù chui mà đâu có nộp bài đâu!"
.duc hoang,1,11/11/2011,Re:Danh sách cấm thi và quy định 5 con 0.,"Bất ngờ và rất chi là bất ngờ!!! Đáng lý ra đầu học kỳ phải thông báo luật trước cho chúng em, rõ ràng. Hôm nay thấy có luật mới này, té 1 cái bụp."
Nguyen Hai Dang,1,12/26/2011,Khiếu nại điểm lab 6.,"Họ và tên: Nguyễn Hải Đăng. MSSV: 50900556. Thưa thầy lab 6 học bù ngày 23/12/11 tiết 11-12 phòng 103C6 em có đi học và nộp bài đầy đủ. Bài làm em đã làm được 5/6 bài nhưng điểm lab 6 lại được 0/10. Mong thầy xem lại, vì nếu lab 6 được 0/10 là con 0 thứ 5 của em rồi. Cảm ơn thầy."
Nguyen Ngoc Xuan Quang,1,11/15/2011,Re:Danh sách cấm thi và quy định 5 con 0.,"hay cái ""điều 12 khoản 1 điểm c"" la quy định ""5 điểm 0 tut/ lab thi bị cấm thi""? nếu vậy cái quy định ""bài làm trên lớp cũng là tut/ lab"" nó nằm ỏ điều nào, khoản nào, điểm nào? sao thầy không thông báo luôn đi. Ít ra để tụi em tra lần này, học ky sau trở đi chẳng ai phạm vào cái lỗi ngớ ngẩn này nữa."
meo_lac,1,11/20/2011,Re:Danh sách cấm thi và quy định 5 con 0.,"Mình thấy tốt nhất các bạn đừng nên cố gắng tranh cãi nữa. Vì càng làm nhưng vậy các bạn tự đặt mình và các thầy vào thế khó, sẽ càng bị thiệt thòi hơn thôi. Tốt nhất là những bạn nào đã bị cảnh báo (dù thuộc diện cấm thi hay chưa) từ nay đến thi cuối kì cố gắng đi học cho đầy đủ, đến đó biết đâu thầy sẽ xem xét lại. Vì dù sao thầy cũng đã thông báo rất rõ ràng rồi, danh sách chỉ mang tính chất cảnh báo, có cấm thi hay không thì cuối kì mới quyết định chính thức. Điều đó có nghĩa là vẫn còn cơ hội đó."
Nguyen Vo,1,11/20/2011,Re:Danh sách cấm thi và quy định 5 con 0.,"Nói chung là cái này mình nghĩ chả trách j đc các thầy. Kể cả các thầy có k nói về chuyện 5 điểm 0 mà cứ điểm danh xong cấm thi thì cũng chả nói j đc. Tại vì cái luật vắng 20% số buổi học trên lớp sẽ bị cấm thi thì ngay khi nhập học năm nhất đã đc phổ biến. Chứ các bạn cứ ý kiển như kiểu trách móc thế này, lỡ cuối kỳ các thầy ra cho cái đề khó thì có cấm thi hay k cũng thế thôi ^^!"
Lê Quang Liêm,0,12/26/2011,Re:Khiếu nại điểm lab 6.,"Họ và tên : Huỳnh Minh Bảo MSSV : 50900133. Thưa thầy lab 6 em có đi học và nộp bài vào ngày 6/12/2011, ở phòng máy c6, nhóm 6, nhưng em 0/10. Xin thầy xem lại ạ, đó cũng là con 0 thứ 5 của em. Cám ơn thầy ạ."
Hai Dang Nguyen,1,12/27/2011,Re:Khiếu nại điểm lab 6.,"Em cũng tên Nguyễn Hải Đăng, mssv 50700510. Giờ học bù lab 6 ngày 22/ 12 em có đi học nhưng lại nhận 0 đ. Mong anh xem lại cho em vì đây cũng là con 0 thứ 5 nếu không tính giờ bài tập trên lớp :|"
Hai Dang Nguyen,1,12/30/2011,Khiếu nại điểm lab 6.,"Vo Thanh Hung wrote: Đã kiểm tra lại bài của em, em được 10d, đã cập nhật, em kiểm tra lại nhé Thầy cho em hỏi trường hợp của em và bạn Bảo thì sao ạ. Xin thầy thông báo để em được biết ..!"
Lê Quang Liêm,0,1/4/2012,Re:Khiếu nại điểm lab 6.,"Còn em sao thầy? Em là Huỳnh Minh Bảo, 50900133"
Lê Quang Liêm,0,1/4/2012,Re:Khiếu nại điểm lab 6.,"Có rồi, 5 điểm rồi, cám ơn thầy ạ."
The An Bui,1,12/8/2011,Danh sách cấm thi và quy định 5 con 0.,Chí lí.
Tin Bui,1,12/23/2011,Re:Danh sách cấm thi và quy định 5 con 0.,VẤn đề làm bài trên lớp gọi là điểm danh. Trường có quy định vắng trên 20% số buổi học gọi là cấm thi mà. Dù sao đi đủ Tut & Lab thì vắng 2 buổi trên lớp cũng ko sao. Hehe
hoc dot,0,12/28/2011,"Re: Danh sách đề nghị cấm thi của thầy Trần Vĩnh Tân - Đúng qui định, nhưng đã hợp lí và công bằng?!","Em chào Thầy Cô. Em không có ý kiến về đề nghị cấm thi của thầy Trần Vĩnh Tân, vì Thầy làm đúng theo qui định của môn học và của qui chế học vụ. Em chỉ xin trình bày quan điểm riêng của em về vấn đề này ở những khía cạnh là qui định như thế có thật sự khách quan và đạt hiệu quả như quí thầy mong đợi chưa?! - Về vấn đề vắng từ 5 buổi Lab/Tut trở lên sẽ nhận điểm 0 cho môn học này: Em thấy qui định như thế là chưa khách quan và có phần phủ nhận mọi cố gắng của những người như em (trường hợp em do cách học chưa hợp lí nên môn này em học không tốt dù thời gian em dành tự học là không ít, và khả năng sẽ phải học lại), em bị liệt vào danh sách vắng với 6 buổi thực hành, em xác nhận mình đã không nộp bài trong 6 buổi đó, nhưng em chỉ vắng mặt từ 2-3 buổi. Dù không làm được bài, em vẫn muốn đến lớp để hy vọng mình sẽ hiểu tốt hơn, vậy việc phải giải được bài trước và sau khi học thực hành có quan trọng lắm không và có đạt được mục tiêu của buổi thực hành? tất nhiên những bạn đã làm bài trước xứng đáng được điểm tốt, trong khi đó thầy phụ trách thì chỉ có điểm danh vắng thông qua bài nộp, vậy là em bị điểm 0 và bị gán là vắng mặt?! - Qui định cấm thi như thế đã vô tình tạo ra hiện tượng mượn bài làm của nhau hoặc của bạn đã làm rồi để copy và nộp cho thầy, tuy không phải là số đông,nhưng cũng không phải là số nhỏ. Điều đó càng cho thấy rõ sự thiếu khách quan trong qui định này, và đồng thời nó tạo ra 1 áp lực không đáng có để rồi có người cũng phải gác đi ""lòng tự trọng"" của bản thân để ""đối phó"", 1 hình ảnh như thế thì thật là tệ trong môi trường giáo dục nói chung, môi trường ĐH nói riêng, đặc biệt là ĐH Bách Khoa. - Em chưa bao giờ đồng tình với qui định này của quí thầy cô, nhưng đã là qui định thì em phải chấp nhận. Em hiểu rằng đó cũng là cách tạo áp lực từ phía thầy cô có ý tốt để tụi em phải cố gắng học, nhưng hiệu quả của nó giống như "" con dao 2 lưỡi"" vậy?! Em nghĩ rằng không 1 sinh viên nào thuộc khoa mình lại không có ý thức chuyện học của mình, chỉ vì lí do này nọ mà mỗi người mỗi khác, thế nên 1 sự bắt buộc như thế thì thật sự không có nhiều ý nghĩa lắm. Thực tế nếu tụi em không tự làm được những bài thực hành này thì làm sao tụi em làm được 90% còn lại của môn học này, và khả năng tụi em rớt môn học này là 95%, còn 5% còn lại em nghĩ đó phải là sự may mắn khá lớn mới qua nổi, thế mà cái 10% ở trên lại quyết định rằng tụi em sẽ bị nhận điểm 0 cho toàn bộ môn học này, thật sự rất ức chế đối với em, dù em chưa đủ khả năng để đạt điểm 5, nhưng với những gì cố gắng em cũng mong mình ít nhất cũng được 2, 3 điểm gì đó, đành rằng cũng rớt, nhưng dù sao cũng là sự cố gắng của bản thân em, nó không giống với con 0 nếu mà em phải nhận. Lớp học thì cũng có người giỏi, người dỡ, người trung bình, 1 qui đinh như thế không tạo được sự phấn đấu cho những bạn nằm ở ""top"" dưới. - Hy vọng thầy cô hãy nhìn nhận tụi em đã là những người trưởng thành, đã ý thức được những gì mình làm, và phải chịu trách nhiệm với những điều đó. Tụi em biết định liệu cho kế hoạch học tập của riêng mình. Ba-rem điểm cho từng phần đã có, đã hợp lí thì cứ để  tụi em theo đó mà học, còn nếu chưa hợp lí thì thay đổi lại, sao cứ phải ""theo sát"" tụi em như học sinh phổ thông như vậy?! Nếu thầy cô thật sự quan tâm đến sinh viên và mong muốn việc dạy hiệu quả hơn, hy vọng thầy cô tìm hiểu thêm nhiều cách dạy thực tế hơn nữa, cuốn hút hơn nữa, dễ hiểu hơn nữa cho tụi em đỡ vất vả, thế đã là niềm ""hung đúc"" tinh thần rất lớn cho tụi em rồi! Vài nhận định của em xin chia sẻ, chắc sẽ có nhiều người không thích những ý nghĩ này, nhưng em cũng muốn biết quan điểm của quí thầy cô về vấn đề này 1 cách khách quan và hợp tình hợp lí nhất. Cảm ơn quí thầy cô, và các bạn đã đọc qua, nói thật là văn của em dỡ, lại dài dòng nên có gì mọi người ""châm chước"" dùm. Trân trọng!"
Jakul KID,1,2/6/2012,Điểm tut/lab,"Thầy ơi, em hỏi điểm tut và lab được tính là tổng lại hết và chia 10 chứ, tại vì em nhớ là như vậy, vì có bonus 1 hoặc 2 buổi. Nếu không đúng thì thôi, em cảm ơn."
Miss Miss (Huynh Xuan),1,12/28/2011,"Re: Danh sách đề nghị cấm thi của thầy Trần Vĩnh Tân - Đúng qui định, nhưng đã hợp lí và công bằng?!","Mình cũng có trường hợp như bạn, có hôm không làm được bài Lab, không mò ra và không biết viết gì vào giấy luôn! Nhưng mình vẫn đi học để mong vào lớp TA giảng và sửa + hỏi han một số bạn làm được để nhờ chỉ. Kết quả là sau hôm thực hành đó mình đã hiểu bài và mình nhận được 0d vì không có bài nộp. Có một số bạn bảo: sao không mượn những người làm được và chép đại để có nộp. Mình thấy rất ngại vì đó không phải là bài mình giải.. với lại mở miệng làm sao để xin copy bài từ công sức của người khác! hic! Thế là 0d, nhưng hên, mình không bị 5 con 0. Mà lên đây đọc nhiều bài viết của nhiều bạn, đúng sai mình không nhận xét nhưng mình thấy thương cho Thầy lý thuyết lắm! Thầy giảng bài rất tận tình và đầy tâm huyết để mong cho sinh viên học + hiểu. Đúng là không có gì có thể tuyệt đối toàn vẹn và hoàn hảo được. Thấy khổ cho Thầy...có nhìu con quá!"
hieu nguyen,1,2/7/2012,Up điểm lên AAO account,Thưa thầy Tân. Em tên : Nguyễn Hữu Hiếu MSSV : 50500871 Mong các thầy up điểm lên AAO account sớm để em kịp nhận giấy chứng nhận tốt nghiệp tạm thời ạh. Tại vì theo lịch của phòng đào tạo thì ngày 13/02 là phát giấy chứng nhận rồi. Cảm ơn các thầy rất nhiều !
Vinh Ngo Dang,0,12/30/2011,"Re: Danh sách đề nghị cấm thi của thầy Trần Vĩnh Tân - Đúng qui định, nhưng đã hợp lí và công bằng?!","Thưa thầy Tân, em là Ngô Đăng Vinh, MSSV là 50903294, có bài Lab 2 em có đi học, em nhớ hôm đó là T3, có thầy và 1 cô nữa cùng dạy hôm đó và em cũng đã nộp bài, chỉ bỏ 2 câu cuối. Giờ học của em là vào ngày thứ 3, nhưng em đã xin chuyển qua thứ 5, có 1 số bữa do kẹt thời gian nên em có vào lớp khác học, em không biết là có phải do em học nhiều lớp quá nên bài em thất lạc không, mong thầy giúp em xem lại. Còn những buổi học bù thường thì em làm thêm vào thứ 7 ở xa TP nên không tham dự được, em lại hiểu nhầm là trên 5 con 0 mới bị cấm nên không chú ý. Nếu có thể xin thầy châm chước cho em. Em xin cảm ơn thầy."
Nguyen Ngoc Xuan Quang,1,2/3/2012,Điểm thi cuối kì,Thấy thầy thông báo là có điểm cuối kì trong gradebook rồi mà sao mình vào không thấy nhỉ? Có bạn nào thấy được điểm chưa?
n0b0dy,1,1/2/2012,"Re: Danh sách đề nghị cấm thi của thầy Trần Vĩnh Tân - Đúng qui định, nhưng đã hợp lí và công bằng?!","Mình thấy phân điểm khá là hợp lý .(ít nhất đối với các trường đại học ở VN ) 10 % tutlab 30 % bài tập lớn Như vậy 4/10 điểm bài tập , như vậy cũng đã là khá cao so với mặt bằng chung đại học ở VN hiện nay . Tuy nhiên để bằng cấp ĐH BK được công nhận trên thế giới thì em e rằng cần xem lại : 1. Tuyên bố xanh rờn của thầy dạy TRR2 học kì trước : Chú trọng Lý thuyết như hiện nay là hợp lý (!?) vẫn làm em nhớ mãi và hoàn toàn ko đồng ý . 2. Nhà trường nên xem lại cơ cấu các môn học . 1 trường học ở Châu Âu 1 hk học bao nhiêu chỉ ? Và họ học những gì . Và ở trường BK ta chúng ta học những gì . Kiến thức lí thuyết của chúng ta gấp mấy lần họ nhưng hiệu quả thì nên xem lại . -> Theo em nếu muốn đc công nhận tương đương với 1 trường đại học Hoa Kì nhà trường hãy bỏ bớt những môn học ko cần thiết hay ít nhất giảm nhẹ việc học những môn đó lại . Tập trung vào các môn chuyên ngành và chú trọng với việc tạo ra 1 sản phẩm thực sự chứ ko phải là bài thi giữa kì hay cuối kì . Phải cho người ta thấy rằng những sinh viên ra trường họ làm đc gì . Chứ ko phải cho thấy rằng sv ra trường nắm 1 đống lí thuyết ."
it.scofield,1,1/3/2012,"Re: Danh sách đề nghị cấm thi của thầy Trần Vĩnh Tân - Đúng qui định, nhưng đã hợp lí và công bằng?!","Em không có ý kiến gì về việc cấm thi 5 con 0 nhưng em có một góp ý nho nhỏ về việc ra đề Tut/Lab. Do trong quá trình học lý thuyết sinh viên vẫn chưa hiểu kỉ, nên khi đụng tới Tut/Lab một số bạn sẽ không hiểu mình nên làm gì và làm như thế nào, trong khi đọc đề Tut/Lab thì mỗi người hiểu theo mỗi cách và làm rất mơ hồ. Hầu như thường hay đắng đo mình hiểu như thế có đúng ý thầy chưa, và trình bày như thế nào thì hợp lý. Em thuyết nghĩ và mong rằng khi ra đề Tut/Lab các thầy nên có đầu tư và ghi chú hợp lý để sinh viên dể làm hơn, chứ theo em thấy thì một số bài Tut/Lab là lấy trong một số cuốn sách nước ngoài và không có chỉnh sữa gì thêm. nếu có thể thì các thầy nên ra đề sớm hơn và gợi ý làm bài nhiều hơn, với học kì này thì em gặp rất nhiều khó khăn về Tut/Lab vì học lý thuyết là chiều thứ 2 và làm Tut/Lab thì chiều thứ 3. Trong một đêm để hiểu và làm được một bài Tut/Lab như thế là một điều khó khăc đối với sinh viên tụi em. Cũng vì sợ cấm thi mà em đã phải đi học những bữa học thứ 3 chỉ để hiểu làm thế nào và sau đó đi học bù vào hôm sau, tuy biết đó là đối phó với các thầy nhưng em đã cố gắng làm nhưng không được thì em đành phải làm vậy. Mong các thầy hãy xem lại, nếu đã có quy định là cấm thi 5 điểm 0 thì các thầy cũng nên giúp sinh viên một ít trong phần đề của các bài Tut/Lab để sinh viên chúng em vẫn hoàn thành tốt khóa học của mình và qua những gợi ý trong đề Tut/Lab đó các em có thể nắm bắt thêm những điều mà các thầy muốn chúng em hiểu trong nội dung lý thuyết. Trân Trọng."
n0b0dy,1,1/3/2012,"Re: Danh sách đề nghị cấm thi của thầy Trần Vĩnh Tân - Đúng qui định, nhưng đã hợp lí và công bằng?!","Em không có ý kiến gì về việc cấm thi 5 con 0  nhưng em có một góp ý nho nhỏ về việc ra đề Tut/Lab. Do trong quá trình  học lý thuyết sinh viên vẫn chưa hiểu kỉ, nên khi đụng tới Tut/Lab một  số bạn sẽ không hiểu mình nên làm gì và làm như thế nào, trong khi đọc  đề Tut/Lab thì mỗi người hiểu theo mỗi cách và làm rất mơ hồ. Hầu như  thường hay đắng đo mình hiểu như thế có đúng ý thầy chưa, và trình bày  như thế nào thì hợp lý. Em thuyết nghĩ và mong rằng khi ra đề Tut/Lab  các thầy nên có đầu tư và ghi chú hợp lý để sinh viên dể làm hơn, chứ  theo em thấy thì một số bài Tut/Lab là lấy trong một số cuốn sách nước  ngoài và không có chỉnh sữa gì thêm. nếu có thể thì các thầy nên ra đề  sớm hơn và gợi ý làm bài nhiều hơn, với học kì này thì em gặp rất nhiều  khó khăn về Tut/Lab vì học lý thuyết là chiều thứ 2 và làm Tut/Lab thì  chiều thứ 3. Trong một đêm để hiểu và làm được một bài Tut/Lab như thế  là một điều khó khăc đối với sinh viên tụi em. Cũng vì sợ cấm thi mà em  đã phải đi học những bữa học thứ 3 chỉ để hiểu làm thế nào và sau đó đi  học bù vào hôm sau, tuy biết đó là đối phó với các thầy nhưng em đã cố  gắng làm nhưng không được thì em đành phải làm vậy. Mong các thầy hãy  xem lại, nếu đã có quy định là cấm thi 5 điểm 0 thì các thầy cũng nên  giúp sinh viên một ít trong phần đề của các bài Tut/Lab để sinh viên  chúng em vẫn hoàn thành tốt khóa học của mình và qua những gợi ý trong  đề Tut/Lab đó các em có thể nắm bắt thêm những điều mà các thầy muốn  chúng em hiểu trong nội dung lý thuyết. Trân Trọng."
Tin Bui,1,2/3/2012,Re:Điểm thi cuối kì,Mình cũng chưa thấy? thầy cho em hỏi là chưa post hay có trục trặc gì ko ah?
M.U.,1,2/3/2012,Re:Điểm thi cuối kì,"mừng quá, pass dc môn này rồi T___T"
Peter,1,2/3/2012,Re:Điểm thi cuối kì,Đã nộp điểm cho phòng đạo tạo chưa Thầy ? Có được phúc khảo lại bài trực tiếp với Thầy như giữa kì ko ạ ?
I love you,1,2/3/2012,Điểm thi cuối kì,"Tân Trần Vĩnh wrote: Tôi đã phổ biến từ đầu học kỳ và công khai trên website này từ đầu năm rồi đó. Nếu em cần chi tiết hơn nữa thì đây. Lab+tut: 10% Assignment 1 - Stage 1: 7.5% Assignment 1 - Stage 2: 7.5% Assignment 2: 15% Mid-term: 20% End-term: 40% Em nghe thầy Hùng nói, Ass 1 : stage 1 chiếm 0.25% còn stage 2 là 0.75%. Sao giờ lại đổi thành 50& - 50% vậy thầy :D"
M.U.,1,2/3/2012,Điểm thi cuối kì,"Christian Enzo wrote: Tân Trần Vĩnh wrote: Tôi đã phổ biến từ đầu học kỳ và công khai trên website này từ đầu năm rồi đó. Nếu em cần chi tiết hơn nữa thì đây. Lab+tut: 10% Assignment 1 - Stage 1: 7.5% Assignment 1 - Stage 2: 7.5% Assignment 2: 15% Mid-term: 20% End-term: 40% Em nghe thầy Hùng nói, Ass 1 : stage 1 chiếm 0.25% còn stage 2 là 0.75%. Sao giờ lại đổi thành 50& - 50% vậy thầy :D tỷ lệ thầy Hùng đưa ra hợp lý hơn, vì trọng lượng stage 1 và stage 2 chênh lệch nhau rất nhìu, với lại làm stage 2 dc sửa lại những gì của stage 1 chưa hoàn chỉnh"
Manh Huy Nguyen,1,2/3/2012,Điểm thi cuối kì,"M.U.  wrote: Christian Enzo wrote: Tân Trần Vĩnh wrote: Tôi đã phổ biến từ đầu học kỳ và công khai trên website này từ đầu năm rồi đó. Nếu em cần chi tiết hơn nữa thì đây. Lab+tut: 10% Assignment 1 - Stage 1: 7.5% Assignment 1 - Stage 2: 7.5% Assignment 2: 15% Mid-term: 20% End-term: 40% Em nghe thầy Hùng nói, Ass 1 : stage 1 chiếm 0.25% còn stage 2 là 0.75%. Sao giờ lại đổi thành 50& - 50% vậy thầy :D tỷ lệ thầy Hùng đưa ra hợp lý hơn, vì trọng lượng stage 1 và stage 2 chênh lệch nhau rất nhìu, với lại làm stage 2 dc sửa lại những gì của stage 1 chưa hoàn chỉnh Theo mình thì tỉ lệ của thầy Tân một phần nào giúp điểm các bạn sẽ cao hơn, do điểm thi giữa kỳ của nhiều người khá thấp, mà điểm Stage1 của Assignment 1 sẽ cao hơn Stage 2 ( nếu bạn làm được Stage 2 cao thì Stage 1 chắc là cũng sẽ cao rồi ) do đó cách tính của thầy Tân sẽ nới lỏng tay hơn cho nhiều bạn."
Quái,1,2/3/2012,Re:Điểm thi cuối kì,"Em nghĩ đâu nhất thiết phải làm tròn điểm tổng kết đâu thầy,,, điểm là 7.2 hay 7.8 vẫn được mà thầy. Tốt nhất cho tụi em là chỉ có làm tròn lên mà không làm tròn xuống khi nộp cho aao..."
Vinh Nguyễn,1,2/3/2012,Điểm thi cuối kì,"Manh Huy Nguyen wrote: M.U.  wrote: Christian Enzo wrote: Tân Trần Vĩnh wrote: Tôi đã phổ biến từ đầu học kỳ và công khai trên website này từ đầu năm rồi đó. Nếu em cần chi tiết hơn nữa thì đây. Lab+tut: 10% Assignment 1 - Stage 1: 7.5% Assignment 1 - Stage 2: 7.5% Assignment 2: 15% Mid-term: 20% End-term: 40% Em nghe thầy Hùng nói, Ass 1 : stage 1 chiếm 0.25% còn stage 2 là 0.75%. Sao giờ lại đổi thành 50& - 50% vậy thầy :D tỷ lệ thầy Hùng đưa ra hợp lý hơn, vì trọng lượng stage 1 và stage 2 chênh lệch nhau rất nhìu, với lại làm stage 2 dc sửa lại những gì của stage 1 chưa hoàn chỉnh Theo mình thì tỉ lệ của thầy Tân một phần nào giúp điểm các bạn sẽ cao hơn, do điểm thi giữa kỳ của nhiều người khá thấp, mà điểm Stage1 của Assignment 1 sẽ cao hơn Stage 2 ( nếu bạn làm được Stage 2 cao thì Stage 1 chắc là cũng sẽ cao rồi ) do đó cách tính của thầy Tân sẽ nới lỏng tay hơn cho nhiều bạn. Hjx, vậy hóa ra mình là trường hợp hiếm có điểm stage 2 > điểm stage 1 đến 2.5 điểm à :(. Và sau khi mình tính toán thì chênh lệch điểm cũng đáng kể (do có làm tròn) @@"
Peter,1,1/3/2012,"Re:Danh sách đề nghị cấm thi của thầy Trần Vĩnh Tân - Đúng qui định, nhưng đã hợp lí và công bằng?!",Thầy yên tâm là nếu thầy con dạy môn này thì năm sau "rất có thể" em còn gặp lại thầy . ( Mặc dù em ko phải thuộc diện cấm thi ) ;)
TAM NGOC,1,2/4/2012,Điểm thi cuối kì,"Theo em thì nên để tỷ lệ điểm stage 1 và stage 2 trong Assignment 1 như anh Hùng đã nói, rất hợp lý. Ngay từ đầu anh Hùng đã nói như vậy rồi, mọi người đều đã biết và không phản đối. Vậy nên không nên thay đổi."
_Trung_Than_Thong,1,2/4/2012,Điểm thi cuối kì,"TAM NGOC wrote: Theo em thì nên để tỷ lệ điểm stage 1 và stage 2 trong Assignment 1 như anh Hùng đã nói, rất hợp lý. Ngay từ đầu anh Hùng đã nói như vậy rồi, mọi người đều đã biết và không phản đối. Vậy nên không nên thay đổi. Sao màmọi người phức tạp vậy. Thầy Tân đưa ra vậy cũng được rồi. Cách nào cũng không chênh lệnh nhiều, thầy đã đưa ra từ đầu năm học sao phải bàn cãi"
Sieutoc,1,2/6/2012,Điểm Course_Grade,Thưa thầy Tân Em là Phạm Quốc Việt MSSV: 50903277 Sau khi em tự tính điểm từ các thành phần của em xong thì được 7.29. Nhưng mà trong Course_Grade của thầy em chỉ được 7.2. Vậy có phải điểm trên AAO của em sẽ bị giảm xuống còn 7.0 không vậy thầy. Nếu thật như vậy thì em hơi buồn vì 7.29 rất gần với 7.3. Mong thầy xem xét. Em cảm ơn thầy.
Thanh Pham Minh,1,2/6/2012,Điểm Course_Grade,Mình tưởng điểm trong course_grade là đã làm tròn 0.5 rồi. Thầy kiểm tra giúp em với. Em tự tính được 9.1 (9.125) nhưng trong course_grade chỉ ghi 9. Nếu đó là điểm đã làm tròn 0.5 thì sao điểm của bạn Việt lại là 7.2 mà không phải là 7.0 hoặc 7.5 ạ? Tên: Phạm Minh Thành MSSV: 50902476
Thong Nguyen,1,2/6/2012,Điểm Course_Grade,Nguyễn Tấn Thông 50902652 Mong thầy tính lại điểm của em. Em tính assignment 1 stage 2: 7.5% thì ra kết quả khác. Cảm ơn thầy.
pham van trang,1,2/6/2012,Điểm Course_Grade,"Tân Trần Vĩnh wrote: Điểm đã được cập nhật thành 7.5. Có một lỗi nhỏ trong công thức làm chênh lệnh khoảng 0.05. Nhờ các em báo sớm, tôi đã kiểm lại tất cả các trường hợp khác. Thầy Tân cho em hỏi. vậy nếu điểm tính ra 6.77 có làm tròn lên 6.8 không thầy."
facebook.com,1,2/6/2012,Điểm Course_Grade,Em là Đoàn Phúc Hiến MSSV 50900789 Em tự tính thì được 7.2966 (trường hợp giống bạn Việt). Mong thầy xem xét lại cho em.
Phuc Ly,1,2/3/2012,Xem lại bài thi cuối kì.,Thầy xem lại bài thi cuối kì giúp em. Tên: Lý Tiến Phúc. MSSV: 50902005. Em xin cảm ơn.
nguyen,1,2/6/2012,Điểm Course_Grade,"Em tự tính được là 6.025, nhưng trong course_grade là 5.9 vậy thầy. MSSV: 50902720"
Forever Alone,1,2/6/2012,Re:Điểm Course_Grade,"Thầy cho em hỏi điểm của em tính ra là 7,09 làm tròn đáng ra phải là 7,1 chứ ạ. Ko hiểu sao điểm TB là 7 MSSV của em là 50902263"
Linh Nguyen Thanh,1,2/6/2012,Re:Điểm Course_Grade,"Nguyễn Thanh Linh Mssv : 50901393 Em tính được là 7.525 , nhưng trong course_grade là 7.4. Mong thầy xem xét lại."
I love you,1,2/6/2012,Re:Điểm Course_Grade,"2. There will be a slight scale based on average score's basis, and your AAO account may be greater than raw score. Vậy là ko cộng thêm à thầy :D"
cong thanh,1,2/7/2012,Re:Điểm Course_Grade,Lê Văn Công Thành 50902464 em tính điểm TB là 8.28 tức là có được làm tròn thành 8.3 không thưa thầy sao điểmCourse_Grade của em chỉ là 8.2. Mong thầy xem xét dùm em
Thanh Pham Minh,1,2/3/2012,File kết quả Assignment 2,"Thưa thầy, Trong Gradebook đã có điểm Assignment 2 nhưng trong mục Assignment vẫn chưa có file chấm bài. Mong thầy upload file chấm bài Assignment 2 trước khi nộp điểm tới phòng đào tạo. Em cảm ơn."
abc,1,2/3/2012,Re:Xem lại bài thi cuối kì.,thầy xem lại bài thi cuối kì giúp em. Tên: Võ Minh Tùng MSSV: 50802555 Em xin cảm ơn.
Minh Nguyen,1,2/3/2012,Xem lại bài thi cuối kì.,Bạn em mới nhập viện nên nhờ em đăng ký xin thầy xem lại bài thi cuối kỳ ạ. Tên: Phạm Trần Xuân Minh MSSV: 50901582 Em xin cảm ơn.
Hoai Phong Tran Ngoc,1,2/3/2012,Re:Xem lại bài thi cuối kì.,Thầy xem lại bài thi cuối kỳ giúp em ạ. Trần Ngọc Hoài Phong MSSV 50601773 Em cảm ơn.
Lê Quốc Nam,1,2/3/2012,Re:Xem lại bài thi cuối kì.,Thầy cũng xem lại bài cuối kì giúp em với ạ. Tên: Lê Quốc Nam MSSV: 50901614
V For,1,2/3/2012,Re:Xem lại bài thi cuối kì.,Em nữa thầy ạ Trần Ngọc Đức 50900655
thanh tam,1,2/4/2012,Re:File kết quả Assignment 2,"- Thưa thầy, trong Gratebook điểm ass2 của e là 0/10, trong mục assignment2 e chưa nhận được return, trước khi nộp điểm aao , xin thầy cho e biết rõ điểm ass2 được bao nhiêu được ko ạh?Em xin cảm ơn thầy."
ngo hoang minh,1,2/4/2012,Re:File kết quả Assignment 2,Mình cũng vậy. Mong thầy xem lại.
facebook.com,1,2/4/2012,File kết quả Assignment 2,"Em là Đoàn Phúc Hiến. MSSV 50900789 Em cũng bị giống trường hợp bạn Thanh Tâm, trong GradeBook em bị điểm 0/10, còn trong Assignment thì chưa có file return. Em thấy mình làm bài này cũng được, nhưng không hiểu sao lại bị điểm 0/10 như vậy. Mong thầy xem xét lại và cho em biết lý do. Em xin chân thành cảm ơn."
thanh tam,1,2/4/2012,Re:File kết quả Assignment 2,Em tên: Nguyễn Thị Thanh Tâm MSSV của e là : 50902352.
Thanh Pham Minh,1,2/6/2012,File kết quả Assignment 2,Thầy cho em hỏi bài của em được bao nhiêu test bắt buộc và bao nhiêu test bonus ạ? Em cảm ơn! Tên: Phạm Minh Thành MSSV: 50902476
thanh tam,1,2/6/2012,Re:File kết quả Assignment 2,"Thưa thầy, bài của e bị lỗi import file not found, kính mong thầy cho e được chấm lại được ko ạh?Em xin chấp nhận mọi hình thức trừ % test case mà e có."
Forever Alone,1,2/6/2012,Re:File kết quả Assignment 2,Thầy cho em hỏi là bài của em được bao nhiêu test bonus và test bắt buộc luôn ạ. Em tên Đinh Trần Thái Sơn MSSV : 50902263
facebook.com,1,2/6/2012,File kết quả Assignment 2,Rất cám ơn thầy đã cho em biết nguyên nhân vì sao em bị điểm 0. Nhưng thầy có thể cho em được chấm lại bài được không? Em xin chịu mọi hình thức trừ điểm. Em xin chân thành cảm ơn. Em là Đoàn Phúc Hiến MSSV: 50900789
Hoang 1417,1,2/8/2012,File kết quả Assignment 2,Em tên Lê Hoàng MSSV 50900905 Em cũng không có điểm ass2 và file return Xin thầy cho em biết nguyên nhân bị 0 điểm ạ?
facebook.com,1,2/8/2012,File kết quả Assignment 2,Xin thầy cho chúng em một cơ hội mà chấm lại bài cho chúng em. Em xin chân thành cảm ơn!
librastar,1,2/3/2012,Re:Xem lại bài thi cuối kì.,Thầy xem lại bài cuối kì giúp em. Tên: Vũ Thế Khanh MSSV: 50800922
Peter,1,2/4/2012,Re:Xem lại bài thi cuối kì.,Thầy xem lại bài giúp em: Mai Trung Hiếu MSSV: 50900807
_Trung_Than_Thong,1,2/4/2012,Re:Xem lại bài thi cuối kì.,Thầy xem lại bài thi giúp em với: Tên: Nguyễn Văn Định MSSV: 50900584
50902155,1,2/4/2012,Re:Xem lại bài thi cuối kì.,Thầy xem lại bài thi giúp em với: Tên: Trịnh Bảo Quân MSSV: 50902155
New,1,2/4/2012,Xem lại bài thi cuối kì.,em cũng mong thầy xem lại giúp em: Tên: Nguyễn Đăng Thắng MSSV: 50902545
TV,1,2/4/2012,Xem lại bài thi cuối kì.,New  wrote: Mong thầy xem lại bài thi của e: Họ và tên: Nguyễn Quốc Vương MSSV: 50903391. Chân thành cảm ơn thầy.
Duy Khuong Ton That,1,2/5/2012,Re:Xem lại bài thi cuối kì.,Xin thầy cũng xem lại bài cuối kì giúp em Tên: Tôn Thất Duy Khương Mssv : 50901294 Xin chân thành cảmơn thầy
Phúc Trí,1,2/5/2012,Re:Xem lại bài thi cuối kì.,Xin thầy xem lại bài thi cuối kì giúp em. Tên: Huỳnh Phúc Trí MSSV: 50902923. Em xin cảm ơn.
Vinh Thọt,1,2/6/2012,Re:Xem lại bài thi cuối kì.,Xin thầy xem lại bài thi cuối kì giúp em. Tên: Hứa Quốc Vinh MSSV: 50903289. Em xin cảm ơn.
Duy Khuong Ton That,1,2/7/2012,Re:Xem lại bài thi cuối kì.,Thưa thầy em có thể xin xem lại bài thi của em koạ. Tên: Tôn Thất Duy Khương Mssv: 50901294 Em cảm thấy trong bài thi của em có lẽ thầyđã chấm 1 tờ thôi có thể là do lý do thất lạc hay nhầm lẫn nênđiểm em rất thấp nay em xin phép thầy cho em xem lại bài thiđể kiểm chứngạ Em cảmơn thầy
mr. Ben,0,9/25/2011,worry,"thu 3 hoc lab roi ma gio van chua co lab 2, hix...."
Cơn Mưa Tình Yêu,1,9/25/2011,worry,"Quoc Anh Nguyen Bui wrote: thu 3 hoc lab roi ma gio van chua co lab 2, hix.... Thầy Hùng đúng hay! Chắc là lên SAKAI thấy bạn đề cập lab 2 nên nhanh tay post lên . Nếu không thì hết tuần sau chắc cũng chả có cái lab nào! Chắc sau lần này thày sẽ rút kinh nghiệm! Mà bây giờ làm sao kịp đây trời. Thứ ba học lab rồi..."
mr. Ben,0,9/25/2011,worry,"ac ac, bit zay minh im lun de thu 3 khoi hoc lab"
Why So Serious,1,9/25/2011,worry,"Quoc Anh Nguyen Bui wrote: ac ac, bit zay minh im lun de thu 3 khoi hoc lab +1 :D"
MFC.Maximus,1,9/26/2011,Re:worry,"mấy huynh cho mình hỏi bài 1 câu a: comment trong string là /*   */ thì nó chấp nhận những điều kiện gì , mình đọc mãi mà không hiểu :("
tran danh hung,1,9/18/2011,tut1,mấy bạn cho mình hỏi b|a+ có độ ưu tiên ko? tức là (b|a)+ hay b|(a+) ?
Phúc Trí,1,9/18/2011,tut1,"tran danh hung wrote: mấy bạn cho mình hỏi b|a+ có độ ưu tiên ko? tức là (b|a)+ hay b|(a+) ? b|a+ thì + chỉáp dụng cho a,b|a+ = b|(a+). (b|a)+ thì ap dung cho ca (b|a)"
Thanh Pham Minh,1,9/21/2011,Re:tut1,"Tương tự cho mình hỏi, câu 5.a: (ab)*(ba)*|aa* thì nghĩa là ((ab)*(ba)*) | aa* hay (ab)* ((ba)*|aa*)"
Nhat Nguyen,1,9/21/2011,Re:tut1,"Thanh Pham Minh wrote: Tương tự cho mình hỏi, câu 5.a: (ab)*(ba)*|aa* thì nghĩa là ((ab)*(ba)*) | aa* hay (ab)* ((ba)*|aa*) theo mình nghĩ nó là (ab)*((ba)*|a)a*"
Thanh Pham Minh,1,9/21/2011,Re:tut1,"Nhat Nguyen wrote: Thanh Pham Minh wrote: Tương tự cho mình hỏi, câu 5.a: (ab)*(ba)*|aa* thì nghĩa là ((ab)*(ba)*) | aa* hay (ab)* ((ba)*|aa*) theo mình nghĩ nó là (ab)*((ba)*|a)a* Oh, cảm ơn bạn nhiều nhé. Mấy khoảng trắng dễ gây nhầm lẫn quá!"
Forever Alone,1,9/21/2011,Re:tut1,"Nhat Nguyen wrote: Thanh Pham Minh wrote: Tương tự cho mình hỏi, câu 5.a: (ab)*(ba)*|aa* thì nghĩa là ((ab)*(ba)*) | aa* hay (ab)* ((ba)*|aa*) theo mình nghĩ nó là (ab)*((ba)*|a)a* mình lại nghĩ nó là ((ab)*(ba)*) | aa* chứ nhỉ ? Thấy nó in xa nhau vậy mà :-?"
Hoai Phong Tran Ngoc,1,9/21/2011,Re:tut1,"►D.T. T.S◄ wrote: Nhat Nguyen wrote: Thanh Pham Minh wrote: Tương tự cho mình hỏi, câu 5.a: (ab)*(ba)*|aa* thì nghĩa là ((ab)*(ba)*) | aa* hay (ab)* ((ba)*|aa*) theo mình nghĩ nó là (ab)*((ba)*|a)a* mình lại nghĩ nó là ((ab)*(ba)*) | aa* chứ nhỉ ? Thấy nó in xa nhau vậy mà :-? mình cũng nghĩ như bạn này^^"
Thanh Pham Minh,1,9/22/2011,tut1,Bài giảng không nói gì về thứ tự ưu tiên cả. Giả sử thứ tự ưu tiên là Kleene Star>Union>Concatenation thì rõ ràng cách hiểu của bạn Nhat Nguyen (ab)*((ba)*|a)a* là chính xác. Còn nếu Kleene Star>Concatenation>Union thì kết quả là ((ab)*(ba)*)|(aa*). Nhưng thứ tự ưu tiên này có vẻ không hợp lý như thứ tự ở trên.
n0b0dy,1,9/30/2011,Exe 2,"Các Thầy làm ơn up E2 lên nhanh nhanh để tụi em làm , chứ như tuần vừa rồi chắc tụi em lâm bệnh nặng ."
MFC.Maximus,1,10/15/2011,hỏi 1 chút về solution tut1,"cho mình hỏi bài 3 câub: mình không hiểu từ q1 -> q5 có cần thiết ko, bạn nào giải thích giúm mình tại sao có trường hợp này cho mình hỏi thêm có chấp nhận "" 1 diagram NFA, DNF chấp nhận chuỗi không đúng với mô tả không"". ví dụ trong trong solution bài 5 câu b mình có 1 chuỗi aba không giống với mô tả ((a*b*a*)*b)* của đề bài nhưng lại thỏa mãn solution"
nguyen dung,1,10/10/2011,Re:Lab 3,"Mấy dấu ""("" "")"" bạn thêm vào trong quá trình transform. KQ ra chắc thầy viết lộn ,ra thế này chứ nhỉ (3 - (4 * 5))"
.duc hoang,1,10/13/2011,"Lab 3, một số vấn đề trong Scala cần chỉ giáo!!!","Đọc dòng code Scala choáng hết cả đầu, search vào scala org thì nó list 1 mớ không hiểu gì. Nhã ý nhờ anh em ai biết chỉ giúp mình tí chút mấy cái sau: Ví dụ trong Lab3 có code: def expr: Parser[Any] = term ~ opt((""+"" | ""-"") ~ expr). vậy: 1. cái :Parser[Any] ý nghĩa là gi??? tại sao lúc define cái gì gì lại có thứ đó 2. cái dấu ~ là gì? ??và ý nghĩa??? 3. cái opt là của scala hay sao??? 4. cái dấu ^^ là ý nghĩa gì nhỉ, làm assignment nhưng không cần hiểu nó vẫn làm tốt. Mong mọi người giúp mình tí chút! Chân thành cám ơn anh em!"
Quái,1,10/13/2011,"Lab 3, một số vấn đề trong Scala cần chỉ giáo!!!",".duc hoang wrote: Đọc dòng code Scala choáng hết cả đầu, search vào scala org thì nó list 1 mớ không hiểu gì. Nhã ý nhờ anh em ai biết chỉ giúp mình tí chút mấy cái sau: Ví dụ trong Lab3 có code: def expr: Parser[Any] = term ~ opt((""+"" | ""-"") ~ expr). vậy: 1. cái :Parser[Any] ý nghĩa là gi??? tại sao lúc define cái gì gì lại có thứ đó 2. cái dấu ~ là gì? ??và ý nghĩa??? 3. cái opt là của scala hay sao??? 4. cái dấu ^^ là ý nghĩa gì nhỉ, làm assignment nhưng không cần hiểu nó vẫn làm tốt. Mong mọi người giúp mình tí chút! Chân thành cám ơn anh em! theo mình thì 1. expr : Parse[Any] có nghĩa là expr có kiểu trả về là một kiểu Parse[Any] ( có thể hiểu là sẽ phân tích cú pháp của thằng Any, nếu là Parse[Expr] sẽ phân tích cú pháp của thằng Expr... chỗ này không chắc lắm) 2. '~' là dấu nối, nghĩa là term xong rồi sẽ đến opt.... 3. opt là do mình tự định nghĩa. 4. dấu ^^ tạm hiểu là sẽ nối cái cú pháp của mình với thằng sẽ giải quyết nó, ví dụ: regex(""([a-z])([a-zA-Z])*"".r) ^^ { processIdent(_) } có nghĩa là mình sẽ xử lý những chuỗi vào có regex thỏa [a-z])([a-zA-Z])* bằng thằng  processIdent(_) Ý của mình là thế."
Why So Serious,1,10/13/2011,"Lab 3, một số vấn đề trong Scala cần chỉ giáo!!!","Bổ sung tí (ý kiến của mình, ko biết đúng ko @@): - opt(X) -> X có thể có hoặc không (optional) - rep(X) -> X có thể lặp lại nhiều lần (repeat)"
Bruce Wayne,1,10/13/2011,"Lab 3, một số vấn đề trong Scala cần chỉ giáo!!!","Just A Tee wrote: Bổ sung tí (ý kiến của mình, ko biết đúng ko @@): - opt(X) -> X có thể có hoặc không (optional) - rep(X) -> X có thể lặp lại nhiều lần (repeat) Cái này có nói rõ trong slide bài giảng mà bạn"
Why So Serious,1,10/14/2011,"Lab 3, một số vấn đề trong Scala cần chỉ giáo!!!","Qủy Lệ  wrote: Just A Tee wrote: Bổ sung tí (ý kiến của mình, ko biết đúng ko @@): - opt(X) -> X có thể có hoặc không (optional) - rep(X) -> X có thể lặp lại nhiều lần (repeat) Cái này có nói rõ trong slide bài giảng mà bạn Hic, ngại quá, thank bạn! (Bữa giờ ko đi học @@)"
Cơn Mưa Tình Yêu,1,10/17/2011,Solution Tut2,"Chào thầy Hùng. Bây giờ là 13h15' ngày 17/10, tức chỉ còn vài ngày nữa là thi môn NLNNLT, chúng em đang đợi solution của tut2. Kính mong thầy up gấp! Thanks thầy nhiều!"
Quái,1,10/17/2011,Re:Solution Tut3,tut3 chưa học mà..
MFC.Maximus,1,10/17/2011,Re:Solution Tut3,chắc là tut2 với lab3 :|
Cơn Mưa Tình Yêu,1,10/17/2011,Re:Solution Tut3,"Rec4rx  wrote: tut3 chưa học mà.. sr, mình nhầm, tut 2 mới đúng, để đính chính lại, sáng thi KTMT về lú lẩn."
Tin Bui,1,10/17/2011,hỏi 1 chút về solution tut1,"MFC.Maximus wrote: cho mình hỏi bài 3 câub: mình không hiểu từ q1 -> q5 có cần thiết ko, bạn nào giải thích giúm mình tại sao có trường hợp này cho mình hỏi thêm có chấp nhận "" 1 diagram NFA, DNF chấp nhận chuỗi không đúng với mô tả không"". ví dụ trong trong solution bài 5 câu b mình có 1 chuỗi aba không giống với mô tả ((a*b*a*)*b)* của đề bài nhưng lại thỏa mãn solution Chuẩn quá bạn ! mình vừa đọc xong cũng thấy lạ câu 5b, mình nghĩ cái vòng tròn trong q3 phải vẽ trong q4 mới phải, chuỗi abab là chuẩn rồi mà lại ko đc chấp nhận mà phải quay vòng về q0 mới đc chấp nhận"
Cơn Mưa Tình Yêu,1,11/5/2011,//SEAGAMES 2011 EXCEL,"chào các bạn! sau đây là 2 link LTĐ bóng đá nam SEAGAMES 2011 do mình làm trên EXCEL. Tính năng của nó khá đơn giản khi chúng ta có thể biết được kết quả xếp hạng, đội vô địch,... chỉ với việc nhập kết quả trận đấu. Với lịch thi đấu này thì sẽ thuận tiện hơn trong việc theo dõi giải đấu. Các bạn có thể down về dùng: http://www.mediafire.com/?9lx7v6xkakq472n http://www.mediafire.com/?47z9q5y676hggmh Ai tải về rồi thì cho ý kiến! Cám ơn! //parse chưa xong mà đi làm cái này"
librastar,1,11/7/2011,Re://SEAGAMES 2011 EXCEL,nice.:)
facebook.com,1,11/8/2011,Console lab 4,Em chưa hiểu cái này cho lắm! mong thầy giải đáp giúp 1. Put following code to console: Press Ctrl + Z cái Console của Eclipse đâu có cho phép nhập đâu mà nhập...
Bruce Wayne,1,11/8/2011,Console lab 4,Bạn Run rồi mới nhập được.
facebook.com,1,11/8/2011,Console lab 4,Thanks
hoc dot,0,11/13/2011,Học nhóm!,"Chào các bạn, cũng hơi bất thường khi mình phải đăng thông tin này lên đây, heee. Mình học khóa 08, nhưng cũng chia sẽ với các bạn là thời gian vừa qua mình học ""không ổn chút nào"", giờ gần như mình học lại chung với các bạn khóa 09. HK này mình đăng kí cũng khá nhiều môn(Nglý lập trình, CTDL>, HĐH, mạng Máy tính), do vậy mình cũng không thể tự đáp ứng đủ lượng kiến thức để có thể học tốt các môn hiện tại dù đã cố gắng... Chính vì thế mình hy vọng thông qua thông tin này, những ai có nhu cầu học nhóm thì tụi mình sẽ cùng nhau học, chỉ với 1 điều mong mỏi là chúng ta có thể hỗ trợ nhau cùng tiến bộ, đặt biệt là các bạn hiện học chưa tốt như mình, vì như thế sẽ dễ thông cảm cho nhau hơn dù lúc đầu chắc sẽ nhiều vất vả?! Với những bạn học tốt, tất nhiên nếu các bạn chịu tham gia thì đó là 1 điều rất ""cảm kích"" của riêng mình với các bạn, vì biết chắc rằng các bạn sẽ ""cực"" nhiều lắm, heee... và trong đó có cả ""hành động"" giúp đỡ từ các bạn nữa... Đối với những bạn không thích việc này hoặc ý nghĩ này của mình thì cũng vui lòng đừng chỉ trỏ hay soi mói. Nếu bạn nào có ý tham gia thì vui lòng để lại comment hoặc nếu ai đó còn ngại thì liên hệ với mình qua private messages hoặc YM & mail: dop_solution@yahoo.com ...Cảm ơn các bạn đã đọc qua!!! (topic này được submit ở cả 4 tab của 4 môn mình đang học, giống spam quá hả?! hehe, mong các bạn thông cảm!!!)"
Cơn Mưa Tình Yêu,1,10/9/2011,Thi Giữa Kỳ???,"Thầy Hùng cho em hỏi: Hôm nay là 9/10 tức còn 12 ngày nữa là bước vào kỳ thi giữa kỳ. Vậy nội dung thi là gì? Trong đê thi có phần nào bắt buộc phải viết chương trình sử dụng ngôn ngữ Scala không? Khi thi có được sử dụng tài liệu không? Với lại nếu có đề mẫu các năm trước, thầy có thể post lên SAKAI cho các bạn cùng học hỏi được không ạ? Thanks thầy nhiều!"
Đỗ Sỹ Hưng,1,11/6/2011,Một số vấn đề trong Lab4,"Có một sô đoạn code mà mình không hiểu cho lắm, mong thầy với các bạn giải đáp, cụ thể: 1. assert() 2. Toán tử ::: 3. scala.Function.tupled { ... }"" trong hàm typeof()"
n0b0dy,1,9/27/2011,Lab 2,"Cho em hỏi lab 2 câu 5 . Code ví dụ của các thầy bị sai thì làm sao mà làm ạ . Lấy ví dụ như em new 1 Symbol mới thì nó cũng ko so sánh đc . Xin thầy cho em giải đáp . val symbolList = List[Symbol(""x"", 5), Symbol(""y"", 7)] -> Error val symbolList = List( new Symbol(""x"", 5), new Symbol(""y"", 7)) symbolList.find(_ == (""x"",5)) cũng ko ra Some"
Tin Bui,1,9/19/2011,Xin hỏi về cách cài Scala,"Em đã download và chạy đc eclipse.exe, nhưng lúc vào Install new solfware và nhập Location là http://download.scala-ide.org/releases/2.0.0-beta vào thì lúc nó load 3 solfware packagesthì máy báo lỗi không load đc từ web. http://nc3.upanh.com/b4.s4.d4/59d5c0ef295b75bb74850e04098ea7ae_35374773.noname.bmp Em mong thầy chỉ giúp"
Long Hoang Ngoc,0,9/19/2011,Xin hỏi về cách cài Scala,Bạn thử lại vào lúc khác xem. Mình vừa thử xong vẫn thấy bình thường mà ;)
Tuan Vu Quang,0,9/26/2011,Xin hỏi về cách cài Scala,"Cho em hỏi về cách chỉnh biến môi trường Máy em đã cài eclipse nhưng mà ko có thư mục java. Em mới cop cái thư mục java từ trường về, trong đó gồm có jdk1.6.0_20 và jre6, giờ em cần làm gì để có thể chạy được scala"
Nguyen Vo,1,11/7/2011,Re:Một số vấn đề trong Lab4,assert program: xac nhan chuong trinh. assert(boolean expression) OK neu expressiong true. neu khong exception java.lang.assertion....... neu expression false. con 2 cai con lai thi ko biet.
MFC.Maximus,1,9/27/2011,Re:Lab 2,"hinh nhu cai class symbol cua scala ko co dinh dang string, int"
n0b0dy,1,9/27/2011,Re:Lab 2,Class này mình tự defined bạn :)
MFC.Maximus,1,9/27/2011,Re:Lab 2,minh cung tu define class nhung khi dugn class do thi no lai la class cua thagn scala @@
MFC.Maximus,1,9/27/2011,Re:Lab 2,"ah nhan tien cho minh hoi bai 6, minh ko ro kieu tra ve cua cai ham deriv, neu tra ve kieu Poly thi man hinh xuat ra cai gi @@"
n0b0dy,1,9/27/2011,Re:Lab 2,Có bảo xuất đâu . Bảo mình định nghĩa nó sao cho giống thôi . :)
MFC.Maximus,1,9/27/2011,Re:Lab 2,"vay trong class X() cua ban co bien x nao do ko, vi du case class X(x : String) chang han"
n0b0dy,1,9/27/2011,Re:Lab 2,Ko bạn :)
MFC.Maximus,1,9/27/2011,Re:Lab 2,vay ban dinh nghia class sum the nao =.=!
n0b0dy,1,9/27/2011,Re:Lab 2,Mình viết thêm cho class Poly operation + và *
thanhnghi_py,1,9/27/2011,Lab 2,Mỗi class mình phải tạo một file mới hay là viết chung trong cùng một file với hàm main(args: Array[String]) vậy
MFC.Maximus,1,9/27/2011,Re:Lab 2,thank cau minh da lam ra :">
Tuan Vu Quang,0,10/5/2011,Xin hỏi về cách cài Scala,"Bữa nay, hình như do update và cài ko đúng nên eclipse em ko chạy được nữa. Anh Hùng có thể hướng dấn lại cách cài cho em được ko ạ"
V For,1,10/2/2011,điểm tut1 (2),"Thưa thầy, tuần vừa rồi em có đi học tiết tut 1, có nộp bài tut, có được thầy gọi lên bảng làm bài và làm đúng. Nhưng không hiểu sao điểm tut1 của em lại là 5/10. Mong thầy xem xét lại xem có nhầm lẫn gì không ? Em xin cảm ơn !"
V For,1,10/3/2011,Re:điểm tut1 (2),"Dạ vâng, em cảm ơn. MSSV cua e la 50900655"
Cơn Mưa Tình Yêu,1,10/5/2011,Re:điểm tut1 (2),mình cầu được tối đa 4 con 0 là vui lắm rồi chứ còn lại 5 hay 10 cũng được...
Nhan Nguyen Van,1,11/6/2011,Lab4,"Bai 1:cho minh hoi Trong ubuntu Ctrl + z thi khong co hien tuong gi xay ra het, minh hoi mot so nguoi dung windows thi ok. Vay la sao nhi?"
Nguyen Vo,1,11/7/2011,Re:Một số vấn đề trong Lab4,"cam on ban. Bạn cho mình hỏi cái cái param.zip(....) dùng làm gì vậy. Mình xem giải thích của nó mà không hiểu gì hết. Đặc tả của nó. def zip[A1 >: A, B, That](that: GenIterable[B])(implicit bf: CanBuildFrom[Repr, (A1, B), That]): That = { val b = bf(repr) val these = this.iterator val those = that.iterator while (these.hasNext && those.hasNext) b += ((these.next, those.next)) b.result } chị có lòng tốt giải thích em các thông số của nó luôn nhé. ps: cái này em tìm hiểu rồi mà vẫn chưa rõ. cám ơn chị."
.duc hoang,1,11/10/2011,Re:Một số vấn đề trong Lab4,Cho mình hỏi tí chút: cái x => x._1 là ý nghĩa gì ấy nhỉ??? nhiều bài gặp cái dấu _ đi kèm số mà không hiểu???
Cơn Mưa Tình Yêu,1,9/30/2011,Re:Lab 2,"chúng ta đang học lập trình hàm mà sao qua hướng đối tượng nhanh thế! quả thật mình vẫn chưa hiểu lắm cái lab 2( đã khó hiểu mà còn trình bày bằng tiếng Anh ). Ở đây có ai giải thích giùm mình mấy cái thuật ngữ như Object Main, extend, class, case class,... thanks nhiều! Sr! Em là K10 nên trình độ còn non lắm ... // Nói thiệt: ức chế lab 2 lắm rồi đó: ra muộn, đề dài, khó hiểu, ..."
n0b0dy,1,9/30/2011,Re:Lab 2,"Em là nam hay nữ . Nếu là nữ thì anh bày cho , còn nếu là nam thì miễn :"">"
Cơn Mưa Tình Yêu,1,9/30/2011,Re:Lab 2,"Guest User wrote: Em là nam hay nữ . Nếu là nữ thì anh bày cho , còn nếu là nam thì miễn :""> Em nghĩ anh đừng nói câu trên thì hơn! Ai mà đọc được chắc cười chết! Thông báo cho anh biết hiện tại K2010 có 3 bạn nữ . Nhưng tiếc là các bạn này hiện định cư hoàn toàn ở Dĩ An rồi. Chắc mấy bạn đó sẽ rất vui nếu năm 3 được lên Lý Thường Kiệt và gặp được những người ""hết lòng"" như anh."
n0b0dy,1,10/1/2011,Lab 2,"Ko ai cười đâu em , máu dê ngấm vô máu con trai bk rồi :))"
FirstName LastName,1,10/6/2011,Re:Lab 2,"Có mỗi mìnhảnh dê màảnh kêu cả cái BK dê, vơđũa quá :))"
silverit,1,10/8/2011,Lab 2,Câu 1: a) với solution. Hình như không test đc trường hợp này /***/
Nguyen Van An,1,9/27/2011,Điểm tut1,"Thưa thầy, tuần vừa rồi em có đi học buổi tut1, có nộp bài và TA có kêu em lên bảng làm bài. Nhưng điểm tut1 của em là 0. Nhờ thầy kiểm tra lại có sai sót gì không ạ? Tên: Nguyễn Văn An MSSV: 50900027 Lớp: phòng 302C5, tiết 11-12, thứ 5"
Huỳnh Trọng Khiêm,1,9/27/2011,Re:Điểm tut1,Tổng cộng mình có bao nhiu bài lab và tut vậy thầy? sao chưa có điểm lab nhỉ.
nguyen dung,1,11/6/2011,Re:Lab4,"Nếu nó không dùng Ctrl+Z được thì bạn đọc từ file, chữa cháy cũng được đó, new Input...(new FileInput... (new File(""path""))"
Nhan Nguyen Van,1,11/6/2011,Re:Lab4,"nguyen dung wrote: Nếu nó không dùng Ctrl+Z được thì bạn đọc từ file, chữa cháy cũng được đó, new Input...(new FileInput... (new File(""path"")) Thanks ban... chay OK"
n0b0dy,1,11/7/2011,Lab4,Đề nghị các thầy viết code để vào 1 file riêng để sinh tiện chỉnh sửa :)
.duc hoang,1,11/8/2011,Re:Lab4,Có ai Ctrl + Z nó bung ra lỗi không ??? không chạy ra gì cả??? xổ ra 1 loạt thê này: [4.1] failure: `{' expected but end of source found ^ Exception in thread "main" java.lang.RuntimeException: No result when parsing failed at scala.sys.package$.error(package.scala:27) at scala.util.parsing.combinator.Parsers$NoSuccess.get(Parsers.scala:141) at scala.util.parsing.combinator.Parsers$NoSuccess.get(Parsers.scala:130) at Main$.main(q1.scala:207) at Main.main(q1.scala)
librastar,1,11/9/2011,Re:Lab4,.duc hoang wrote: Có ai Ctrl + Z nó bung ra lỗi không ??? không chạy ra gì cả??? xổ ra 1 loạt thê này: [4.1] failure: `{' expected but end of source found ^ Exception in thread "main" java.lang.RuntimeException: No result when parsing failed at scala.sys.package$.error(package.scala:27) at scala.util.parsing.combinator.Parsers$NoSuccess.get(Parsers.scala:141) at scala.util.parsing.combinator.Parsers$NoSuccess.get(Parsers.scala:130) at Main$.main(q1.scala:207) at Main.main(q1.scala) run -> nhập input -> enter -> Ctrl + Z. Thực hiện từng bước như vậy sẽ ok.
.duc hoang,1,11/9/2011,Re:Lab4,@ librastar : Cảm ơn bạn nha! đã chạy ok theo chỉ dẫn của bạn. Thanks!
Nguyen Vinh,1,11/9/2011,Re:Lab4,"www.mediafire.com/ cho mình hỏi lỗi này là sao, mình copy nguyên code của thầy mà ,:(("
Đỗ Sỹ Hưng,1,11/9/2011,Re:Lab4,"Bạn phải tạo 1 package có tên là sl2, trong package đó bạn tạo 1 file Scala Object, rồi copy code lab4 vào file Scala Object là xong."
pham luk,1,11/9/2011,Re:Lab4,cau 2Write the grammar for SL2 (EBNF) la lam gi vay moi nguoi
Nguyen Vinh,1,11/9/2011,Re:Lab4,"Đỗ Sỹ Hưng  wrote: Bạn phải tạo 1 package có tên là sl2, trong package đó bạn tạo 1 file Scala Object, rồi copy code lab4 vào file Scala Object là xong. mình làm đc rồi, thank bạn!"
Nguyen Van An,1,11/10/2011,Re:Lab4,pham luk wrote: cau 2Write the grammar for SL2 (EBNF) la lam gi vay moi nguoi Viết văn phạm EBNF cho ngôn ngữ SL2
facebook.com,1,11/10/2011,Lab4,Còn câu 4 thì sao? What is reported as the type of triple? How do you know it? The type is written as a complex SLFun expression. Translate it back into a SL2 type of the form (paramTypes)=>returnType mình đọc mãi mà chẳng hiểu nổi yêu cầu...
Ngan Tuyet,1,10/8/2011,Re:Lab 2,Đúng rùi đó. Hình như cái solution câu 1a của thầy có j nhầm lẫn. Mong thầy giải đáp Mình thì làm thế này :"(/\\*([^\\*]|(\\*)+[^/])*\\**\\*/)"
Thanh Pham Minh,1,10/8/2011,Re:Lab 2,"Ngan Tuyet wrote: Đúng rùi đó. Hình như cái solution câu 1a của thầy có j nhầm lẫn. Mong thầy giải đáp Mình thì làm thế này :""(/\\*([^\\*]|(\\*)+[^/])*\\**\\*/)"" Cách của bạn có xót một trường hợp: val comment1 = new Regex(""(/\\*([^\\*]|(\\*)+[^/])*\\**\\*/)"") comment1.findAllIn("" /**** * 1st comment. ****/ code1(); /* * 2nd comment */ code2(); "").toList Kết quả: List[String] = List(/**** * 1st comment. ****/ code1(); /* * 2nd comment */) Lẽ ra kết quả phải là: List[String] = List(/**** * 1st comment. ****/, /* * 2nd comment */) Mình nghĩ đáp án này chính xác hơn :) val comment = new Regex(""""""/\*([^*]|(\*+[^*/]))*\*+/"""""")"
silverit,1,10/9/2011,Lab 2,Đáp án bạn thành đã giải quyết trường hợp /***/. new Regex("""/\*([^*]|(\*+[^*/]))*\*+/""") new Regex("""/\*([^*]|(\*+[^*/]))*\**/""") Hai cái này chắc là giống nhau!
silverit,1,10/9/2011,Lab 2,Nhầm Cái này chắc nó tiết kiệm hơn new Regex("""/\*([^*]|(\*+[^*/]))*\*\*/""")
silverit,1,10/9/2011,Lab 2,Sau một hồi test thì new Regex("""/\*([^*]|(\*+[^*/]))*\*+/""") code này của bạn Thành là tốt nhất. Thanks bạn Thành nhá!
n0b0dy,1,10/10/2011,Lab 2,"Với điều kiện đề đúng , đề sai tè le hột me thì sv sẽ có kinh nghiệm debug ppl professional >:) Đôi khi ko debug đc máu dồn lên não và bại não mà chết =))"
librastar,1,10/14/2011,Re:Lab 2,Thế nào là đề sai tè le nhỉ? liệt kê ra cho mình xem với;)
aa a,0,10/20/2011,Re:Lab 2,cho mình hỏi trong solution lab 2 bài 1 a cóval regex = new Regex( """ /\*((\*[^/])|[^*])*\*/ """ ) 3 dấu ngoặc kép liên tiếp dùng để làm gì vậy
Nguyen Van An,1,9/27/2011,Re:Điểm tut1,Em đã kiểm tra lại. Cảm ơn thầy!
Binh Nguyen Van,1,9/27/2011,Re:Điểm tut1,"mssv:50903431 tên: Nguyễn Văn Bình phòng 302C5 tiet 10-12 tuần hoc tut 1 vừa rồi em làm bài nộp đầy đủ và gọi lên bảng làm bài đúng mà kết quả tut 1 được 5, mong thầy xem xét lại."
Binh Nguyen Van,1,9/28/2011,Re:Điểm tut1,"Vo Thanh Hung wrote: Binh Nguyen Van wrote: mssv:50903431 tên: Nguyễn Văn Bình phòng 302C5 tiet 10-12 tuần hoc tut 1 vừa rồi em làm bài nộp đầy đủ và gọi lên bảng làm bài đúng mà kết quả tut 1 được 5, mong thầy xem xét lại. Chào em, Đây là câu trả lời từ TA phụ trách lớp em: chưa làm hoàn chỉnh câu  5 (vẽ NFA). Bài tut này vẽ DFA khó hơn còn vẽ NFA dễ hơn nên nếu làm  chưa hoàn chỉnh câu 5 thì không chấm 10. cảm ơn thầy, TA có nhầm lẫn rồi ạ, em làm câu 4b) chứ không phải câu 5. câu 4 dễ nhưng làm đúng. TA cũng nói vậy mà"
minh tuan huynh,1,9/29/2011,Re:Điểm tut1,Thưa thầy tuần vừa rồi ngày 22/9/2011 em có đi học tut1 và có lên bảng làm bài tập sao điểm tut1 cua em bị điểm 0. TÊN: HUỲNH MINH TUẤN MSSV: 50903083 em học tiết 11-12 phòng 302C5
Binh Nguyen Van,1,9/29/2011,Re:Điểm tut1,"Vo Thanh Hung wrote: Ý của TA là làm bài 5 ở trong giấy nộp đó em. Ok, thanks anh hung va TA"
Nam Giang,1,10/15/2011,Điểm Lab2,"Thưa thầy, buổi lab 2 em có làm bài và thầy cũng đã chấm bài. Nhưng em lại nhận 0 điểm. Mong thầy xem xét lại cho em. Em cám ơn thầy. MSSV của em: 50801303."
meo_lac,1,10/17/2011,Solution tut 2,Xin thầy up solution tut 2 để tụi em tham khảo ôn thi. Cảm ơn thầy
n0b0dy,1,11/29/2011,Tut 5 ,Bạn nào giải thích hộ các câu hỏi trong tut 5 trong mình đc ko =.= Đọc chả hiểu đề hỏi gì cả .
BKIT 09,1,12/5/2011,Tut 5 ,n0b0dy  wrote: Bạn nào giải thích hộ các câu hỏi trong tut 5 trong mình đc ko =.= Đọc chả hiểu đề hỏi gì cả . Khả năng không có ai giải thích giúp bạn "siêu máy chém" là rất cao. Thành thật chia buồn cùng bạn !!!
James Blunt,1,11/9/2011,Điểm lab 3,"thưa thầy, Lab 3 em có xin đi học bù tiết 11,12 chiều thứ 6 và nộp bài đầy đủ không hiểu sao lại đc 0/10. Mong thầy xem lại giùm em. SV:Hoàng Văn Nhật Vũ MSSV:50903336"
Quái,1,11/2/2011,Ý kiến về câu 2 kì thi giữa kì...,"Thưa thầy, em có chút ý kiến về câu số 2 đề thì giữa kì như sau. Theo em được biết thì, một văn phạm được coi là nhập nhằng khi tồn tại một phát biểu mà theo phát biểu đó tồn tại hai hoặc nhiều hơn hai cây cú pháp. Vậy điều kiện đầu tiên để một văn phạm có thể coi là nhập nhằng phải là ""tồn tại một phát biểu""... Nhưng theo như văn phạm trong câu 2 đề thi, thì rõ ràng chẳng tồn tại một phát biểu nào cho văn phạm đó hết, vậy nên việc chứng minh văn phạm đó nhập nhằng là không thể.. Ý kiến của em là vậy, mong thầy góp ý nếu em hiểu sai gì đó. Cám ơn thầy."
Thanh Pham Minh,1,11/2/2011,Ý kiến về câu 2 kì thi giữa kì...,"Rec4rx  wrote: Thưa thầy, em có chút ý kiến về câu số 2 đề thì giữa kì như sau. Theo em được biết thì, một văn phạm được coi là nhập nhằng khi tồn tại một phát biểu mà theo phát biểu đó tồn tại hai hoặc nhiều hơn hai cây cú pháp. Vậy điều kiện đầu tiên để một văn phạm có thể coi là nhập nhằng phải là ""tồn tại một phát biểu""... Nhưng theo như văn phạm trong câu 2 đề thi, thì rõ ràng chẳng tồn tại một phát biểu nào cho văn phạm đó hết, vậy nên việc chứng minh văn phạm đó nhập nhằng là không thể.. Ý kiến của em là vậy, mong thầy góp ý nếu em hiểu sai gì đó. Cám ơn thầy. Đồng ý với ý kiến của bạn :D Đề thi nên rõ ràng, chặt chẽ chứ không nên có những chỗ ""tự hiểu là phải bỏ qua""."
Linh Nguyen Thanh,1,11/2/2011,Re:Ý kiến về câu 2 kì thi giữa kì...,"mình cũng có cùng ý kiến. Theo mình, để chứng minh 1 văn phạm là nhập nhằng, trước hết ta phải đưa ra 1 dẫn xuất trước đã, mà trong dẫn xuất đó phải toàn là kí hiệu kết thúc , sau đó mới vẽ cây cho dẫn xuất này. Đề bài câu 2 ta không thể đưa ra 1 dẫn xuất toàn kí hiệu kết thúc được rồi.. Như thế là không thể chứng minh nhập nhằng được . Trong khi làm bài , mình có thêm kí tự kết thúc vào ( mình lúc đó mình nghĩ là đề thiếu sót gì rồi) . rồi vẽ 2 cây cho phát biểu mới . cũng không biết như vậy có điểm không nữa."
Quái,1,11/5/2011,Re:Ý kiến về câu 2 kì thi giữa kì...,Thầy không nói gì luôn :(
Thanh Pham Minh,1,11/1/2011,Tut 3,"Thưa thầy, Question 4, Tut 3 yêu cầu chuyển đổi giữa số thập phân và chuỗi nhị phân theo chuẩn IEEE 754. Tuy nhiên em không tìm thấy tài liệu nào về biểu diễn số với 9 bits theo chuẩn trên cả. Mong thầy nói rõ hơn: Với một số 1.abc * 2^d Phần exponent 3 bit lưu d hay d+bias. Nếu là d+bias thì bias là 3 phải không ạ? Phần value 5 bit cuối lưu value hay fraction: 1.abc hay là abc? Em cảm ơn."
Long Hoang Ngoc,0,11/2/2011,Tut 3,"Ở đây có này bạn: http://www.ddth.com/showthread.php/94558-Đổi-số-thập-phân-theo-sang-chuẩn-IEEE-754?p=1176264#post1176264 Phần exponent lưu d+bias, bias là 3 như bạn nói (=2^2-1). 5 bit cuối lưu abc. Bạn có thể xem thêm trên Wiki: http://en.wikipedia.org/wiki/IEEE_754-1985"
Thanh Pham Minh,1,11/2/2011,Re:Tut 3,"Cảm ơn bạn Long Hoang Ngoc . Ý mình là tài liệu nói về chuẩn IEEE 754 với 9 bits . Có hai khả năng: Một là IEEE 754 chỉ quy định các dạng: binary16, binary32, binary64, binary128, decimal32, decimal64, decimal128. Nếu vậy không có chuẩn 9bits ở đây. Hai là IEEE 754 quy định luật chung và từ đó chỉ rõ phương pháp tính ra cách biểu diễn được cho mọi số lượng bit cần thiết. Nếu vậy tại sao những tài liệu (mình tìm được và cả của bạn) không nói về cách tính đó? Tại sao bias bằng 3 :) Mình không thấy có tài liệu nào nói bias = 2^ExponentBitsCount-1 -1. Mình thì đoán mò dựa trên hai dạng chuẩn binary32, binary64. Thậm chí chuẩn còn quy định số bit dành cho phần exponent là [4*log2(k)]-13. Nếu thay k = 9 thì exponent bằng 3? Chính vì không tìm thấy tài liệu nên mình nghi ngờ về bias và chữ ""value"" (chiếm 5 bits cuối). Nếu đã theo chuẩn thì phải triệt để, nếu không, phải đặc tả rõ!"
mr. Ben,0,11/19/2011,lab 5,thầy ơi up lab 5 sớm đi thầy
thinh van,1,11/20/2011,Re:lab 5,"cho mình hỏi xí, cái dấu gạch dưới trong bài 3 để chi vậy? val integerFinder = allMatches(""[+-]?[0-9]+"") _"
Đỗ Sỹ Hưng,1,11/20/2011,Re:lab 5,"mấy bạn biết câu 5 làm gì không?? Mình chép nguyên code của thầy vô chạy ok luôn mà, không biết làm gì với cái hàm min hết >""<"
thinh van,1,11/20/2011,Re:lab 5,
Cơn Mưa Tình Yêu,1,11/22/2011,Re:lab 5,Ui! Lab5 đã up lên rồi vậy mà chẳng có một thông báo nào cả. Kiểu này cũng có người như mình tưởng tuần này nghỉ lab. Chắc thầy Hùng đang bận giải quyết khiếu nại assignment nên quên.
_Trung_Than_Thong,1,11/7/2011,Phân biệt SUB và NOT,"Mọi người cho hỏi làm sao phân biệt xuất ra sub và not như thế nào là đúng. Hôm trước có bạn hỏi rồi nhưng vẫn không rõ, mong thầy giải đáp. ví dụ: procedure f(); begin var x:real; x := 1 - - - 2; end; Output sẽ như thế nào? Dấu trừ đầu tiên luôn hiểu là sub thì các dấu còn lại sẽ thế nào?"
BT Lớn,1,11/7/2011,Re:Phân biệt SUB và NOT,procedure a(); begin x[i]:= -not 4; end; còn nếu x[i] := not not 4; x[i] := - not not 4; x[i] := not - not 4; x[i] := - - not 4; x[i] := - - 4; x[i] := 2- - -4; thì đáp án là gì vậy thầy . chỗ này em không hiểu rõ lắm mong thầy giải đáp...
Lê Quốc Nam,1,11/7/2011,Re:Phân biệt SUB và NOT,"Kết quả đầu tiên [proc(f,[],[var(x,float),assign(x,sub(1,sub(sub(2))))])] Kết quả sau: [proc(a,[],[assign(ele(x,[i]),sub(bnot(4)))])] Tương tự mấy cái còn lại."
Tan Phat,1,11/7/2011,Phân biệt SUB và NOT,"_Trung_Than_Thong  wrote: Mọi người cho hỏi làm sao phân  biệt xuất ra sub và not như thế nào là đúng. Hôm trước có bạn hỏi rồi  nhưng vẫn không rõ, mong thầy giải đáp. ví dụ: procedure f(); begin var x:real; x := 1 - - - 2; end; Output sẽ như thế nào? Dấu trừ đầu tiên luôn hiểu là sub thì các dấu còn lại sẽ thế nào? Output: [proc(f,[],[var(x,float),assign(x,sub(1,sub(sub(2))))])] Dấu - luôn là sub, chỉ có điều là sub 1 ngôi hay sub 2 ngôi (có code trong file PT có đ/n sub 1 ngôi đó). Sub 1 ngôi có độ ưu tiên ngang với not. Thứ tự thực hiện cứ theo độ ưu tiên trong bảng file đặc tả mà thực hiện thôi."
_Trung_Than_Thong,1,11/7/2011,Re:Phân biệt SUB và NOT,"Hoa Vô Khuyết wrote: Kết quả sau: [proc(a,[],[assign(ele(x,[i]),sub(bnot(4)))])] Tương tự mấy cái còn lại. Sao lại ra sub rồi not được? Đặc tả: <expr> (+ | -) <expr> Của mình: [proc(a,[],[assign(ele(x,[i]),bnot(bnot(4)))])] .................... còn cái test trên của mình phải hiểu đặc tả như thế nào để ra được sub hết? vì output có thể xét dấu - đầu tiên là sub sau đó là not ( vì sau sub là 1 expression, 1 expression lại có thể là not <expr>....)"
V For,1,11/7/2011,Re:Phân biệt SUB và NOT,"_Trung_Than_Thong  wrote: Hoa Vô Khuyết wrote: Kết quả sau: [proc(a,[],[assign(ele(x,[i]),sub(bnot(4)))])] Tương tự mấy cái còn lại. Sao lại ra sub rồi not được? Đặc tả: (+ | -) Của mình: [proc(a,[],[assign(ele(x,[i]),bnot(bnot(4)))])] .................... còn cái test trên của mình phải hiểu đặc tả như thế nào để ra được sub hết? vì output có thể xét dấu - đầu tiên là sub sau đó là not ( vì sau sub là 1 expression, 1 expression lại có thể là not ....) ==> test lai di ban, trường hợp này sub là 1 ngôi và result se la: [proc(a,[],[assign(ele(x,[i]),sub(bnot(4)))])]"
M.U.,1,11/7/2011,Re:Phân biệt SUB và NOT,"thanks mấy bạn, fix dc thêm lỗi này."
Sieutoc,1,11/7/2011,Trường hợp break và continue,"Thầy Hưng ơi tuy thầy nói trong assignment 1 này chưa xét đến break và continue không dc nằm ngoài loop và while. Nhưng nếu em đã hiện thực luôn thì có tính là bị sai không vậy thầy. Trong trường hợp này em mong là testcase sẽ né đc mâu thuẫn này. input: procedure main(); begin while 1 do begin end break; end; output [proc(main,[],[while(1,[]),break(null)])] hoặc line 4:2: unexpected token: break"
Sieutoc,1,11/7/2011,Re:Trường hợp break và continue,"Còn một trường hợp chưa thống nhất nữa là truy xuất mảng rỗng Khi khai báo mãng rỗng thì chắc chắn là sai, nhưng khi truy xuất mảng rỗng thì có một số bạn truy xuất dc va một số bạn không truy xuất dc. input procedure main(); begin a[]:=0; end; output [proc(main,[],[assign(a,0)])] hoặc line 3:4: unexpected token: ]"
Sieutoc,1,11/7/2011,Re:Trường hợp break và continue,Mong thầy thống nhất lại hoặc testcase sẽ không rơi vào các trường hợp trên. Cảm ơn thầy.
Nhất Tiếu nại Hà,1,11/7/2011,Re:Trường hợp break và continue,kết quả là vầy đó bạn: line 3:7: unexpected token: ] link: https://elearning.cse.hcmut.edu.vn/portal/site/9cf20d39-0ddd-4c8e-bc4f-5dd11b4ae97a
M.U.,1,11/7/2011,Re:Trường hợp break và continue,"procedure main(); begin while 1 do begin end break; end; vậy trường hợp này báo lỗi hay pars ra dc vậy, mình làm ra báo lỗi line 4:5: unexpected token: break"
BT Lớn,1,11/7/2011,Re:Trường hợp break và continue,"M.U.  wrote: procedure main(); begin while 1 do begin end break; end; vậy trường hợp này báo lỗi hay pars ra dc vậy, mình làm ra báo lỗi line 4:5: unexpected token: break par đc chứ bạn..."
M.U.,1,11/7/2011,Re:Trường hợp break và continue,"BT Lớn wrote: M.U.  wrote: procedure main(); begin while 1 do begin end break; end; vậy trường hợp này báo lỗi hay pars ra dc vậy, mình làm ra báo lỗi line 4:5: unexpected token: break par đc chứ bạn... cám ơn bạn, do input thiếu dấu ; sau end nên nó báo lỗi :D pars dc rùi, tắt máy đi ngủ, thí điểm lab ngày mai roài T__T"
Why So Serious,1,11/7/2011,Re:Phân biệt SUB và NOT,"tran ngoc duc wrote: ==> test lai di ban, trường hợp này sub là 1 ngôi và result se la: [proc(a,[],[assign(ele(x,[i]),sub(bnot(4)))])] Làm gì có sub 1 ngôi ta???"
V For,1,11/7/2011,Re:Phân biệt SUB và NOT,"Just A Tee wrote: tran ngoc duc wrote: ==> test lai di ban, trường hợp này sub là 1 ngôi và result se la: [proc(a,[],[assign(ele(x,[i]),sub(bnot(4)))])] Làm gì có sub 1 ngôi ta??? Bạn có thể hiểu như sau: sub(a, b) ---> a - b (biểu thức) sub(b)  --- > - b (số âm)"
Why So Serious,1,11/7/2011,Re:Phân biệt SUB và NOT,"tran ngoc duc wrote: Bạn có thể hiểu như sau: sub(a, b) ---> a - b (biểu thức) sub(b)  --- > - b (số âm) À, thì ra là vậy :D"
huongcuibap,0,11/8/2011,Re:Phân biệt SUB và NOT,Tks Tan Phat
Nguyễn Đức Huy,1,9/27/2011,Hỏi về nhận dạng array ở stage 1,"anh Hùng ơi, trong test2 có đoạn: const h = [23;45;2]; được phân tích thành: identifier h `=' `[' 23 `;' 45 `;' 2 `]' `;' Có nghĩa là ở Stage 1, không cần nhận dạng Array phải không ạ?"
huongcuibap,0,11/6/2011,Re:Hỏi về nhận dạng array ở stage 1,"Khi test : const h = [23]; bên TOKEN => `const' identifier h `=' [23 `]' `;' EOF ben PARSER = > màn hình console trống trơn , không lỗi, không kêt quả các bạn biết vì sao không? ^^"
Long Nguyễn,1,11/6/2011,Re:Hỏi về nhận dạng array ở stage 1,"coffee cafe wrote: Khi test : const h = [23]; bên TOKEN => `const' identifier h `=' [23 `]' `;' EOF ben PARSER = > màn hình console trống trơn , không lỗi, không kêt quả các bạn biết vì sao không? ^^ Mình đoán là bạn làm sai cái regex của real (vì mình đã từng bị như vậy) do dấu '.' được hiểu là ""any character"" => sửa lại ""\\.""."
huongcuibap,0,11/6/2011,Re:Hỏi về nhận dạng array ở stage 1,"@ Long Potter: mình sai chỗ phần real, nên mât' tong stage 1 :((. pm: tks bạn"
huongcuibap,0,11/6/2011,Re:Hỏi về nhận dạng array ở stage 1,"nhưng còn trường hợp : ben PARSER = > màn hình console trống trơn , không lỗi, không kêt quả mình không biêt bắt mạch sao luôn"
Long Nguyễn,1,11/6/2011,Hỏi về nhận dạng array ở stage 1,"Cái này thì bó tay, lẽ ra nó phải ra Error message chứ nhỉ?"
meo_lac,1,11/6/2011,Re:Hỏi về nhận dạng array ở stage 1,"theo mình thì kết quả đúng sẽ là thế này [const(h,[23])] ^^. Còn lý do console k xuất ra nội dung j có thể là do bạn chưa parse ConsPT (trong file PT) nên nó bị null => xuất null => suy ra console trắng."
Đỗ Sỹ Hưng,1,11/6/2011,Re:Hỏi về nhận dạng array ở stage 1,"trong phần Failure(msg, next) trong hàm show(), bạn thay chuỗi """" thành result.toString để xem lỗi trong quá trình viết parse sau này xử lí chỗ Failure(msg, next) sau."
Tri,1,11/7/2011,Hỏi về nhận dạng array ở stage 1,"Long Potter wrote: Cái này thì bó tay, lẽ ra nó phải ra Error message chứ nhỉ? Mình nghĩ chỗ này parser thành công chứ nhỉ ? class ArrayLiteralPT(val ele: List[LiteralPT]) extends LiteralPT {   override def toString = ""["" + (if (!ele.isEmpty) (ele.head.toString /: ele.tail)(_ + "";"" + _) else """") + ""]"" } //đâu có nhận ident"
n0b0dy,1,11/4/2011,Chat nhóm thảo luận PPL - Assignment,"Hiện tại mình đang mở 1 channel IRC bàn luận về bài tập PPL , bạn nào hứng thú thì tham gia nha . channel irc.freenode.net/ppl nếu bạn nào ko rành về chat IRC thì có thể dùng cách sau đây . Vào trang http://webchat.freenode.net/ Gõ nickname = tên gì gì đó của bạn channel: ppl bạn gõ capcha để trang web xác thục rồi connect :) Các bạn vào đây cùng bàn luận và giúp đỡ nhau . Lưu ý là ko share code để tránh bị chém ^^ à , ai vào khai tên ra hộ mình để mình quản lý cho dễ nhé ^^"
n0b0dy,1,11/4/2011,Chat nhóm thảo luận PPL - Assignment,Nãy giờ ko thấy bạn nào trên sakai vào :(
Clapika,1,11/7/2011,Thắc mắc về output của String,"Thầy cho em hỏi là lúc output chuỗi String có cần phải bỏ 2 dấu ' ở 2 đầu String không ạ. Ví dụ như: const a='a'; thì output là [(const,a)] hay là [(const,'a')] ạ Em không thấy trong đặc tả có nói về phần output này ạ."
BT Lớn,1,11/7/2011,Thắc mắc về output của String,"Lenh Ho Xung wrote: Thầy cho em hỏi là lúc output chuỗi String có cần phải bỏ 2 dấu ' ở 2 đầu String không ạ. Ví dụ như: const a='a'; thì output là [(const,a)] hay là [(const,'a')] ạ Em không thấy trong đặc tả có nói về phần output này ạ. [(const,'a')] cái này thầy đã nói rõ trong phần notice bạn vào đó xem cho rõ..."
Quái,1,11/7/2011,Re:Thắc mắc về output của String,nếu theo như vậy thì testsol 2 của thầy còn đúng không ta?
LAV,1,11/8/2011,Thắc mắc về output của String,"Lenh Ho Xung wrote: Thầy cho em hỏi là lúc output chuỗi String có cần phải bỏ 2 dấu ' ở 2 đầu String không ạ. Ví dụ như: const a='a'; thì output là [(const,a)] hay là [(const,'a')] ạ Em không thấy trong đặc tả có nói về phần output này ạ. Sửa lại nha bạn: [const(a,'a')] chứ ko phải [(const,'a')]"
BT Lớn,1,11/8/2011,Thắc mắc array const !!!,"Thầy cho em hỏi về stage2 của assignment 1 đã kiểm tra kiểu của array const chưa vậy..! ví dụ : function main():real; begin a:=[1;4;true]; end; đáp án là :line 3:9: unexpected token: true hay là :[func(main,[],float,[assign(a,[1;4;true])])]"
BT Lớn,1,11/8/2011,Re:Thắc mắc array const !!!,"Scala ^^  wrote: ass1 này k kiểm tra kiểu bạn ơi, vấn đề này đã nói trên sakai rất nhìu lần, bạn chỉ cần chịu khó đọc 1 chút là dc mà ^^ ừ thank bạn nha :D ! tại đọc nhiều quá rối hết cả lên nên hỏi mọi người cho chắc"
BKIT 09,1,11/8/2011,Chat nhóm thảo luận PPL - Assignment,n0b0dy  wrote: Nãy giờ ko thấy bạn nào trên sakai vào :( Poor Sang =))
Quái,1,11/6/2011,Hỏi về việc chia sẻ regex,"Thưa thầy, nếu regex của mình chưa chuẩn, stage2 này mình có được phép dùng regex của những bạn được full điểm Stage1 để sử dụng không?"
BT Lớn,1,11/6/2011,Hỏi về việc chia sẻ regex,"Rec4rx  wrote: Thưa thầy, nếu regex của mình chưa chuẩn, stage2 này mình có được phép dùng regex của những bạn được full điểm Stage1 để sử dụng không? nghe mọi người nói thầy đi Thái Lan rồi bạn..."
Quái,1,11/7/2011,Re:Hỏi về việc chia sẻ regex,amen!
Quái,1,11/7/2011,Re:Hỏi về việc chia sẻ regex,Thầy confirm giúp em với ạ!
Crazy Boy,1,11/7/2011,Hỏi về việc chia sẻ regex,"Hòi chju đy học hỏi Thầy, thầy kêu phải tự viết lại, các bạn mà lấy của nhau thỳ lúc máy chấm tự động có thể sẽ báo gian lận...:))"
I love you,1,11/7/2011,Re:Hỏi về việc chia sẻ regex,Viết lại mà không đúng thì lại bị mất testcase step 2
Quái,1,11/7/2011,Re:Hỏi về việc chia sẻ regex,cám ơn mấy bạn! Chiều nghĩ là deadline nên nghỉ học để ở nhà test nốt. Mấy bạn cho mình hỏi thầy còn dạy tiết lý thuyết nào tuần này nữa không để mình đi học bù...
Why So Serious,1,11/7/2011,Hỏi về việc chia sẻ regex,regex thì người nào cũng gần gần giống nhau vậy thì chấm gian lận kiểu gì???
ngocquang45 ngocquang45,1,11/1/2011,Statements-IfStatement,"Mình đang hiện thực phần IfStatement như sau: def ifStmt: Parser[IfStmtPT] =(""if"" ~>(""("" ~> expr <~"")"") ~ ""then"" ~ rep(oneStmt) ~ opt(""else"" ~rep(oneStmt))) ^^{ case a ~ b ~ c=> new IfStmtPT(a, b, c) } thì bị báo lỗi ở dòng case a ~ b ~ c=> new IfStmtPT(a, b, c ) . Các bạn giúp mình với"
Long Nguyễn,1,11/1/2011,Statements-IfStatement,cái opt(...) thì lúc có lúc ko nên ko để c vậy được. bạn phải chia trường hợp: case a ~ b ~ Some(c) => ... case a ~ b ~ None => ...
Bruce Wayne,1,11/2/2011,Re:Statements-IfStatement,Cho mình hỏi 2 cú pháp sau cú pháp nào đúng vậy: if a=3 then return 3 else return 0; if a=3 then return 3 ; else return 0;
Long Nguyễn,1,11/2/2011,Statements-IfStatement,if expression then statement else statement mà A return statement starts with keyword return followed by an expression and ends with a semicolon .
Phạm Nguyên Trình,1,11/8/2011,Re:Hỏi về việc chia sẻ regex,Vấn đề là hok biết sai ở đâu để mà sửa T_T Mà sửa lại cứ sợ sai nhiều hơn T_T
librastar,1,11/2/2011,Re:Statements-IfStatement,"Qủy Lệ  wrote: Cho mình hỏi 2 cú pháp sau cú pháp nào đúng vậy: if a=3 then return 3 else return 0; if a=3 then return 3 ; else return 0; Không có cái nào đúng, '3' hay '3;' chỉ là expr ko phải statement"
walk alone,1,11/2/2011,Re:Statements-IfStatement,"librastar  wrote: Qủy Lệ  wrote: Cho mình hỏi 2 cú pháp sau cú pháp nào đúng vậy: if a=3 then return 3 else return 0; if a=3 then return 3 ; else return 0; Không có cái nào đúng, '3' hay '3;' chỉ là expr ko phải statement return expr là statement,          ................... sao lại không có cái nào đúng."
librastar,1,11/3/2011,Re:Statements-IfStatement,"walk alone wrote: librastar  wrote: Qủy Lệ  wrote: Cho mình hỏi 2 cú pháp sau cú pháp nào đúng vậy: if a=3 then return 3 else return 0; if a=3 then return 3 ; else return 0; Không có cái nào đúng, '3' hay '3;' chỉ là expr ko phải statement return expr là statement,          ................... sao lại không có cái nào đúng. uhm, sorry. Không đọc kĩ, sót mất chữ return."
ngocquang45 ngocquang45,1,11/4/2011,Statements-IfStatement,"thank Long Potter, mình đã sửa được lỗi"
50902440,1,11/6/2011,Statements-IfStatement,if (a+3) then return 3 else return 0 các bạn cho mình hỏi cái này có đúng ko ?
Long Nguyễn,1,11/6/2011,Statements-IfStatement,"be be wrote: if (a+3) then return 3 else return 0 các bạn cho mình hỏi cái này có đúng ko ? Lỗi vì thiếu ; sau return, nếu đủ thì parse được."
huongcuibap,0,11/6/2011,Re:Statements-IfStatement,"vẫn bị lỗi kiểu ở case a ~ b ~ c => new IfStmtPT( a, b, c ) a là cái ExprPT kiểu được trả về từ IfStmtPT , vậy sao lại báo lỗi, mình vẫn còn nhập nhằng chỗ kiểu này quá. bạn nào giúp mình với."
BT Lớn,1,11/6/2011,Re:Statements-IfStatement,"coffee cafe wrote: vẫn bị lỗi kiểu ở case a ~ b ~ c => new IfStmtPT( a, b, c ) a là cái ExprPT kiểu được trả về từ IfStmtPT , vậy sao lại báo lỗi, mình vẫn còn nhập nhằng chỗ kiểu này quá. bạn nào giúp mình với. bạn k post code lên thì k biết sai chỗ nào đâu..."
Thanh Cao,1,11/7/2011,Re:Statements-IfStatement,ủa mọi người cái statement trong câu lệnh if then else là oneStmt hay stmt thế
Nhất Tiếu nại Hà,1,11/7/2011,vấn đề thầy nói hơi mâu thuẫn...???,"theo thầy nói: const a='a'; procedure main(); begin x := 'test'''' prog""""ram '; end; Cấu trúc PT sinh ra là: [const(a,'a'),proc(main,[],[assign(x, 'test'''' prog""""ram' )])] nhưng trong testsol thứ hai: const d = 1.23e-1; const e = 12; const f = 'qeqwe''qwrqwr' ; const g = true; const h = [23;45;2]; thầy lại cho kết quả: [const(d,1.23e-1),const(e,12),const(f, qeqwe'qwrqwr ),const(g,true),const(h,[23;45;2])] vậy quá mâu thuẫn...thầy giải thik zum tụi em vs....?????????"
Nguyen Thanh Tam,1,11/7/2011,vấn đề thầy nói hơi mâu thuẫn...???,Anh hùng đã nói là sol có thể sai. Toàn bộ string giữ nguyên ko biến đổigif nữa cả
Phúc Trí,1,11/7/2011,vấn đề thầy nói hơi mâu thuẫn...???,"Nhất Tiếu nại Hà  wrote: theo thầy nói: const a='a'; procedure main(); begin x := 'test'''' prog""""ram '; end; Cấu trúc PT sinh ra là: [const(a,'a'),proc(main,[],[assign(x, 'test'''' prog""""ram' )])] nhưng trong testsol thứ hai: const d = 1.23e-1; const e = 12; const f = 'qeqwe''qwrqwr' ; const g = true; const h = [23;45;2]; thầy lại cho kết quả: [const(d,1.23e-1),const(e,12),const(f, qeqwe'qwrqwr ),const(g,true),const(h,[23;45;2])] vậy quá mâu thuẫn...thầy giải thik zum tụi em vs....????????? thầy đã đính chính trong phần Noticed, cứ thế mà làm"
Nhất Tiếu nại Hà,1,11/7/2011,Re:vấn đề thầy nói hơi mâu thuẫn...???,cảm ơn thầy nhiều..!:D:D
tuong vo,1,11/7/2011,Re:Testcase cho stage 2,output? procedure main(); begin a[true] := 1; a['crazy']:=2; a[(1+2)]:=3; end;
BKIT 09,1,11/7/2011,Re:Testcase cho stage 2,"Guest User wrote: output? procedure main(); begin a[true] := 1; a['crazy']:=2; a[(1+2)]:=3; end; Mình ra là: [proc(main,[],[assign(ele(a,[true]),1),assign(ele(a,['crazy']),2),assign(ele(a,[add(1,2)]),3)])]"
tuong vo,1,11/7/2011,Re:Testcase cho stage 2,"cho mình hỏi : lúc mình khai báo kiểu mảng thì các phàn tử là intLiteral thôinhư vậy thì element of array chỉ chấp nhậnphần tử là intLiteral thôi chứ ,sao nó lại chấp nhận cả realLiteral , booleanLiteral, stringLiteral nữa chứ"
BKIT 09,1,11/7/2011,Re:Testcase cho stage 2,"Guest User wrote: cho mình hỏi : lúc mình khai báo kiểu mảng thì các phàn tử là intLiteral thôinhư vậy thì element of array chỉ chấp nhậnphần tử là intLiteral thôi chứ ,sao nó lại chấp nhận cả realLiteral , booleanLiteral, stringLiteral nữa chứ Theo mình lúc khai báo mảng, intLiteral đó là số chiều của mảng thôi bạn à, còn các phần tử trong mảng thì không bắt buộc chỉ là intLiteral chẳng hạn trong đặc tả của thầy có VD: procedure init(x: array [5] of integer ); begin var i:=0; x[i]:=a[i]; // a is global var. i: integer ; //block variable end ;"
tuong vo,1,11/7/2011,Re:Testcase cho stage 2,vì đó là phần tử thứ i của mảng mà
vanhoa,1,11/7/2011,Testcase cho stage 2,Bước này chưa kt kiểu.
Phạm Nguyên Trình,1,11/8/2011,Re:Testcase cho stage 2,"Chạy bộ testcase mới update của vanhoa Giống toàn bộ trừ test11 KQ of mình: [const(myIntConst,5),const(myRealConst,5.3e4),const(myBoolConst1,true),const(myBoolConst2,false),const(myStringConst,'abc'),const(myArrayConst1,[1;3;4]),const(myArrayConst2,[[1;2];[true;false]]),const(myArrayConst3,[1;false;3.5]),const(myArrayConst4,[[2;4];3;true]),func(testExpr,[par(a,float),par(b,arr([3,2,1],float)),par(c,arr([3,2,1],float)),par(d,arr([3,2,1],float))],arr([1,2,3],float),[assign(v0,add(call(func,[]),add(call(func,[1]),add(call(func,[1,2]),call(func,[sub(1,2),3]))))),assign(v1,add(1,add(true,add(false,add('abc',add([1;2;3],add(a,add(ele(a,[0]),ele(a,[0,1]))))))))),assign(v2,add(1,add(times(2,3),add(4,ele(c,[5]))))),assign(v3,times(add(1,2),add(3,times(4,ele(c,[5]))))),assign(v4,sub(1,sub(sub(2,sub(sub(sub(sub(4)))))))),assign(v5,sub(add(1,sub(2)))),assign(v6,sub(times(1,2))),assign(v7,bnot(bor(bor(1,2),bor(3,bnot(bnot(bnot(bnot(4)))))))),assign(v8,bnot(bor(bor(1,2),bor(3,4)))),assign(v9,eql(ge(1,2),ne(le(3,4),eql(5,eql(greater(6,greater(7,greater(8,9))),10))))),assign(v10,pow(1,pow(2,pow(3,times(4,5))))),assign(vtotal,pow(idiv(greater(0,le(1,2)),eql(3,4)),pow(greater(5,6),pow(add(idiv(7,times(eql(bor(8,9),10),11)),add(idiv(12,rdiv(13,idiv(14,times(le(15,ge(16,17)),imod(18,times(eql(19,20),idiv(21,idiv(eql(22,23),rdiv(24,rdiv(ge(25,less(26,27)),times(greater(28,29),greater(30,less(31,ge(32,greater(33,34))))))))))))))),35)),pow(add(idiv(eql(36,bor(37,38)),imod(39,rdiv(less(40,41),42))),43),pow(sub(rdiv(le(44,le(45,bor(46,47))),times(less(48,49),idiv(ge(50,ge(51,52)),53))),sub(idiv(54,rdiv(le(55,less(56,57)),greater(58,less(bor(59,60),61)))),rdiv(greater(62,greater(63,64)),rdiv(ge(65,66),idiv(less(bor(67,68),greater(69,70)),eql(71,le(72,ge(73,bor(74,75))))))))),pow(add(rdiv(76,77),sub(ne(78,79),add(times(80,81),sub(rdiv(bor(82,83),le(84,le(85,86))),eql(ge(87,88),89))))),sub(rdiv(le(90,91),imod(less(92,greater(93,94)),greater(95,96))),sub(times(less(97,98),99),100))))))))),assign(vtotal0,pow(times(0,times(1,2)),pow(times(eql(3,4),times(eql(5,bor(6,7)),ne(bor(8,9),greater(10,11)))),add(12,add(idiv(ge(13,14),le(15,greater(16,17))),sub(18,sub(imod(less(19,less(20,less(21,ge(22,23)))),24),sub(ge(25,bor(26,27)),sub(28,add(idiv(29,imod(bor(30,31),idiv(eql(le(32,33),34),35))),sub(le(36,37),add(38,add(39,times(greater(40,ge(41,le(42,43))),rdiv(44,times(45,rdiv(greater(46,47),rdiv(48,eql(49,50))))))))))))))))))),assign(vtotal1,pow(sub(0,idiv(ge(1,2),3)),add(rdiv(ne(greater(4,5),le(6,7)),rdiv(le(8,bor(9,10)),ge(bor(11,12),13))),sub(ge(14,15),add(ge(16,17),sub(idiv(18,imod(greater(bor(19,20),21),22)),sub(23,sub(times(24,idiv(less(25,26),rdiv(27,times(less(28,bor(29,30)),rdiv(ge(31,bor(32,33)),34))))),sub(less(35,36),sub(rdiv(37,ne(bor(38,39),40)),add(41,add(42,add(ne(43,44),add(45,add(46,add(eql(47,48),greater(49,50))))))))))))))))),assign(vtotal2,pow(add(greater(0,1),imod(2,greater(bor(3,4),5))),pow(add(imod(6,7),sub(8,add(bor(9,10),11))),pow(add(rdiv(12,rdiv(13,rdiv(14,ge(15,16)))),add(17,eql(greater(18,bor(19,20)),21))),pow(times(22,imod(23,imod(bor(24,25),idiv(bor(26,27),idiv(28,rdiv(ge(29,ge(30,greater(31,ge(bor(32,33),le(34,35))))),rdiv(36,rdiv(37,times(ne(le(38,39),40),ne(le(bor(41,42),43),bor(44,45))))))))))),add(46,ge(47,le(48,less(49,50))))))))),assign(vtotal3,pow(bor(0,1),pow(rdiv(le(2,3),times(eql(greater(4,5),greater(6,7)),rdiv(8,rdiv(ge(9,le(10,11)),less(12,less(13,ge(bor(14,15),16))))))),pow(imod(bor(17,18),19),add(rdiv(20,less(21,bor(22,23))),sub(rdiv(eql(ge(24,ge(25,26)),ne(27,less(28,bor(29,30)))),rdiv(31,idiv(less(32,33),rdiv(34,eql(35,ge(36,37)))))),sub(38,sub(times(39,40),sub(rdiv(41,ne(42,43)),add(times(44,times(45,46)),rdiv(47,rdiv(greater(48,49),50)))))))))))),assign(vtotal4,pow(add(ne(0,ne(1,2)),add(imod(ne(3,4),5),6)),pow(sub(7,add(times(ge(8,9),10),times(greater(11,greater(12,13)),imod(ne(le(14,15),16),imod(17,rdiv(18,idiv(19,20))))))),pow(sub(bor(21,22),add(eql(less(23,24),bor(25,26)),add(27,add(rdiv(28,rdiv(29,idiv(ne(30,le(bor(31,32),33)),idiv(ge(34,35),imod(less(36,37),38))))),sub(times(39,times(40,times(bor(41,42),43))),sub(ne(44,45),46)))))),sub(times(47,48),add(49,50)))))),assign(vtota l5,pow(sub(0,times(1,2)),pow(sub(rdiv(le(3,4),imod(5,rdiv(6,ge(7,8)))),add(rdiv(eql(greater(bor(9,10),less(11,12)),eql(13,ne(14,ge(bor(15,16),less(17,greater(18,19)))))),imod(eql(le(20,bor(21,22)),bor(23,24)),imod(ne(less(25,26),eql(27,less(bor(28,29),30))),eql(less(31,greater(bor(32,33),34)),35)))),sub(times(eql(36,less(37,38)),ge(39,bor(40,41))),42))),rdiv(le(43,44),idiv(ge(45,46),rdiv(47,rdiv(bor(48,49),50))))))),assign(vtotal6,pow(sub(times(greater(0,1),2),idiv(ge(3,4),5)),pow(add(imod(ne(6,greater(7,le(bor(8,9),10))),11),rdiv(eql(less(12,13),less(14,bor(15,16))),17)),pow(add(idiv(ne(18,19),ne(less(20,21),eql(22,le(23,24)))),sub(imod(25,rdiv(eql(26,27),28)),add(less(29,30),bor(31,32)))),pow(imod(33,le(bor(34,35),36)),pow(idiv(37,greater(38,39)),add(times(eql(40,41),42),add(le(43,bor(44,bor(45,46))),sub(47,imod(ne(48,49),50)))))))))),assign(vtotal7,pow(sub(le(0,1),2),pow(add(idiv(greater(3,4),rdiv(ge(5,6),7)),add(rdiv(8,greater(9,10)),sub(rdiv(ge(11,12),ne(13,14)),sub(15,eql(bor(16,17),le(18,19)))))),pow(sub(bor(20,bor(21,22)),add(rdiv(eql(bor(23,24),25),idiv(ge(26,less(27,28)),times(29,idiv(30,31)))),add(less(32,33),34))),pow(sub(idiv(le(35,36),imod(less(37,38),imod(ne(39,40),41))),42),pow(rdiv(43,44),pow(45,eql(less(46,ge(47,48)),bor(49,50))))))))),assign(vtotal8,pow(rdiv(greater(0,1),idiv(bor(2,3),times(bor(4,5),6))),pow(7,pow(rdiv(bor(8,9),times(le(10,11),rdiv(12,imod(13,times(14,imod(eql(15,16),ge(17,greater(18,19)))))))),pow(rdiv(20,times(ne(21,ge(bor(22,23),24)),imod(eql(25,26),idiv(27,bor(28,29))))),pow(30,pow(sub(imod(eql(31,ge(32,33)),34),rdiv(35,36)),pow(times(le(37,38),39),add(idiv(40,imod(41,times(42,43))),rdiv(less(bor(44,45),bor(46,47)),imod(48,times(49,50)))))))))))),assign(vtotal9,pow(sub(imod(ne(0,ge(1,ge(2,3))),bor(4,5)),times(bor(6,7),bor(8,9))),pow(ne(10,11),pow(ne(12,13),pow(add(14,sub(imod(bor(15,16),bor(bor(17,18),19)),sub(idiv(ne(20,21),times(22,ge(23,24))),add(idiv(25,26),sub(imod(27,less(28,29)),rdiv(greater(30,31),greater(32,ge(33,34)))))))),pow(sub(35,idiv(eql(le(36,37),eql(38,39)),40)),pow(41,add(42,sub(43,sub(idiv(ge(44,45),imod(bor(46,47),le(48,49))),50)))))))))),assign(vtotal10,pow(sub(rdiv(eql(0,1),times(greater(2,bor(3,4)),imod(5,imod(6,7)))),imod(eql(bor(8,9),10),idiv(11,times(12,idiv(13,imod(14,15)))))),pow(add(idiv(ge(16,17),times(18,idiv(19,imod(greater(20,21),times(eql(22,23),imod(ge(24,25),ge(26,27))))))),eql(less(bor(bor(28,29),30),less(bor(31,32),33)),ne(bor(34,35),36))),sub(37,add(imod(38,times(bor(39,40),le(41,42))),idiv(ge(bor(43,44),le(45,46)),greater(47,ge(bor(48,49),50)))))))),assign(vtotal11,sub(idiv(greater(0,le(1,2)),ne(3,4)),sub(idiv(le(5,6),rdiv(le(7,greater(8,le(9,10))),idiv(11,imod(12,13)))),add(idiv(le(14,ge(15,16)),17),sub(imod(18,rdiv(19,eql(20,21))),add(imod(greater(22,less(23,greater(bor(24,25),26))),less(bor(27,28),bor(29,30))),sub(idiv(31,idiv(less(32,33),idiv(ge(34,35),idiv(36,imod(37,idiv(greater(38,39),idiv(40,ne(less(41,42),ne(less(43,44),less(45,46)))))))))),times(47,greater(48,ge(49,50)))))))))),assign(vtotal12,pow(sub(idiv(eql(0,less(1,2)),rdiv(ne(less(3,4),bor(5,6)),idiv(ge(bor(7,8),9),10))),sub(rdiv(11,idiv(12,ne(13,ge(14,ge(15,16))))),sub(idiv(bor(17,18),rdiv(19,rdiv(20,21))),add(greater(22,23),imod(ge(bor(24,25),bor(26,27)),idiv(bor(28,29),ne(30,ne(31,32)))))))),pow(rdiv(ne(ge(33,ge(bor(34,35),36)),eql(37,bor(38,39))),40),sub(idiv(ge(41,bor(42,43)),44),imod(45,times(less(46,47),times(ge(48,49),50))))))),assign(vtotal13,pow(sub(idiv(eql(less(bor(0,1),greater(2,3)),4),rdiv(5,6)),sub(7,sub(times(greater(bor(8,9),10),idiv(le(11,12),greater(13,14))),add(times(15,16),sub(17,18))))),pow(add(imod(19,rdiv(20,imod(le(21,le(22,bor(23,24))),eql(25,26)))),imod(bor(27,bor(28,29)),30)),add(31,add(rdiv(32,33),add(idiv(ge(34,35),36),add(imod(37,rdiv(38,imod(ne(39,40),imod(41,ge(42,greater(43,44)))))),idiv(45,times(greater(46,47),times(48,idiv(49,50))))))))))),assign(vtotal14,pow(add(bor(0,1),sub(times(ne(ge(2,3),ge(4,5)),6),times(7,rdiv(8,idiv(9,eql(10,eql(11,12))))))),pow(add(idiv(13,ne(less(14,15),16)),add(imod(bor(17,18),rdiv(19,times(20,21))),add(eql(ge(22,2 3),le(24,bor(25,26))),sub(idiv(eql(bor(27,28),29),times(less(30,31),imod(less(32,33),34))),add(eql(35,le(36,37)),sub(idiv(38,idiv(bor(39,bor(40,41)),42)),add(43,44))))))),pow(times(45,times(eql(46,47),times(48,49))),50)))),assign(vtotal15,pow(sub(rdiv(0,idiv(greater(bor(1,bor(2,3)),4),5)),sub(imod(eql(6,7),rdiv(8,idiv(ge(9,less(10,11)),12))),sub(ne(13,le(14,15)),times(16,idiv(17,idiv(18,19)))))),pow(add(rdiv(20,bor(21,22)),add(eql(greater(bor(23,24),25),26),sub(27,sub(28,times(greater(bor(29,30),31),rdiv(ge(bor(32,33),less(bor(34,bor(35,36)),37)),greater(bor(38,39),40))))))),sub(ne(bor(41,42),less(43,greater(44,45))),add(46,idiv(47,ge(48,ge(49,50)))))))),assign(vtotal16,pow(imod(0,eql(bor(1,2),le(3,bor(4,bor(5,6))))),pow(ne(less(7,8),eql(less(9,10),11)),pow(sub(12,eql(13,ge(14,bor(15,16)))),pow(sub(17,add(idiv(greater(18,ge(19,20)),greater(21,greater(22,23))),rdiv(24,greater(25,greater(26,27))))),pow(add(eql(28,bor(29,30)),add(31,greater(32,33))),sub(times(34,idiv(eql(ge(bor(35,36),37),38),imod(greater(bor(39,40),greater(41,greater(42,43))),eql(le(44,less(45,46)),47)))),times(48,ge(49,50))))))))),assign(vtotal17,pow(add(0,sub(imod(1,times(greater(2,3),4)),add(greater(bor(5,6),bor(7,8)),sub(idiv(9,eql(bor(10,11),bor(12,13))),sub(rdiv(14,idiv(15,16)),sub(rdiv(eql(greater(17,bor(18,19)),ne(le(20,21),le(22,greater(bor(23,24),25)))),rdiv(less(26,27),28)),29)))))),pow(30,add(rdiv(bor(31,32),rdiv(33,34)),times(ge(35,36),imod(greater(37,greater(bor(38,39),le(40,greater(41,less(42,43))))),imod(bor(44,45),idiv(46,imod(47,eql(48,ge(49,50))))))))))),assign(vtotal18,pow(add(idiv(ge(0,le(1,2)),greater(3,4)),rdiv(5,times(ne(6,7),8))),pow(sub(rdiv(le(9,10),rdiv(11,idiv(eql(12,eql(13,14)),15))),add(times(bor(16,17),times(bor(18,19),eql(20,eql(21,22)))),times(greater(23,24),rdiv(ge(25,bor(26,27)),imod(eql(28,bor(29,30)),rdiv(31,idiv(eql(32,less(33,bor(34,35))),36))))))),sub(idiv(ge(bor(37,38),bor(39,40)),eql(41,42)),sub(imod(43,idiv(ne(44,45),bor(46,47))),eql(48,bor(49,50))))))),assign(vtotal19,pow(eql(0,ne(ge(1,2),3)),pow(add(4,add(times(le(5,6),7),sub(rdiv(le(bor(8,9),10),11),add(ne(bor(12,13),greater(14,le(15,bor(16,17)))),sub(bor(18,19),sub(imod(less(20,less(21,22)),23),idiv(less(24,25),idiv(eql(greater(26,27),greater(28,29)),times(less(30,le(31,greater(32,33))),times(ge(34,ge(bor(35,bor(36,37)),38)),idiv(39,rdiv(40,41)))))))))))),sub(rdiv(bor(42,43),44),idiv(bor(45,46),times(47,ne(48,less(49,50)))))))),assign(vtotal20,pow(sub(0,add(1,add(2,sub(rdiv(3,ne(greater(4,bor(bor(5,6),7)),eql(8,9))),sub(10,imod(11,times(12,bor(13,14)))))))),pow(sub(rdiv(15,idiv(bor(16,17),18)),sub(imod(19,imod(20,ne(21,22))),le(23,24))),pow(idiv(ne(ge(25,26),eql(less(bor(27,28),29),30)),ge(bor(31,32),33)),pow(idiv(ne(ge(34,bor(35,36)),37),imod(ne(38,bor(39,40)),41)),sub(ne(42,43),rdiv(less(bor(44,45),46),imod(ge(47,48),bor(49,50))))))))),assign(vtotal21,pow(sub(times(greater(0,1),rdiv(bor(2,3),idiv(4,eql(5,6)))),sub(7,times(8,bor(9,10)))),pow(idiv(11,imod(ne(bor(12,13),14),15)),pow(rdiv(greater(bor(16,17),18),times(ne(le(19,20),eql(greater(21,less(22,23)),24)),times(25,imod(26,27)))),pow(28,pow(sub(bor(29,30),add(less(31,le(32,greater(33,less(34,35)))),add(rdiv(36,imod(less(37,ge(38,39)),le(40,41))),42))),imod(43,eql(less(bor(44,45),46),ne(47,ne(le(48,49),50)))))))))),assign(vtotal22,pow(add(rdiv(less(0,1),idiv(bor(2,bor(3,4)),idiv(eql(5,less(6,less(7,ge(8,9)))),imod(ge(10,11),times(eql(12,13),less(14,15)))))),add(16,rdiv(le(17,18),times(le(19,20),times(ge(21,22),23))))),pow(sub(idiv(24,eql(25,bor(26,27))),sub(idiv(28,times(bor(29,30),times(31,idiv(32,ne(33,less(34,35)))))),bor(36,37))),pow(add(38,39),pow(imod(greater(40,41),le(42,greater(bor(43,bor(44,45)),46))),pow(imod(47,48),pow(49,50))))))),assign(vtotal23,pow(add(bor(0,1),sub(eql(2,3),add(rdiv(ge(4,5),rdiv(greater(6,le(7,8)),9)),sub(times(10,bor(11,bor(12,13))),times(14,imod(15,greater(16,17))))))),pow(add(ne(18,eql(le(19,bor(20,21)),eql(22,eql(23,24)))),sub(times(25,idiv(26,27)),add(idiv(28,29),add(rdiv(30,greater(31,greater(32,33))),times(eql(34,eql(35,36)),times(bor(37,38),rdiv(ne(le(39,greater(40,41 )),42),eql(43,44)))))))),pow(ge(45,46),sub(47,ge(48,le(49,50))))))),assign(vtotal24,pow(add(imod(0,idiv(1,times(less(2,3),idiv(4,imod(eql(bor(5,6),7),rdiv(eql(8,9),10)))))),add(ge(11,ge(12,greater(13,greater(14,15)))),eql(ge(16,17),18))),pow(add(rdiv(ne(19,le(bor(20,bor(21,22)),23)),idiv(ge(bor(bor(24,25),26),ge(27,le(28,29))),ne(le(30,31),32))),add(rdiv(33,ge(34,bor(35,36))),eql(le(37,bor(38,39)),40))),pow(add(41,times(42,eql(43,44))),imod(45,idiv(46,rdiv(47,eql(bor(48,49),50)))))))),assign(vtotal25,pow(add(idiv(greater(0,1),ge(2,3)),sub(4,imod(ge(5,bor(6,7)),eql(le(8,bor(9,10)),ne(11,12))))),pow(add(bor(13,14),add(rdiv(15,rdiv(16,17)),sub(idiv(18,greater(19,20)),idiv(le(21,22),idiv(ge(23,24),imod(bor(25,26),rdiv(27,28))))))),pow(add(times(ne(less(29,greater(bor(30,31),32)),33),bor(34,bor(35,36))),add(bor(37,38),39)),times(40,idiv(less(41,42),imod(43,imod(greater(44,bor(45,46)),imod(47,eql(48,le(49,50))))))))))),assign(vtotal26,pow(add(idiv(0,greater(1,less(2,3))),sub(times(4,idiv(eql(ge(5,6),7),times(ge(8,bor(9,10)),le(bor(11,12),greater(13,14))))),rdiv(15,rdiv(16,times(17,times(ge(18,19),idiv(greater(20,ge(21,le(22,23))),rdiv(24,imod(ne(25,26),eql(27,28)))))))))),pow(29,pow(sub(30,sub(31,sub(32,sub(rdiv(33,eql(less(34,ge(35,ge(36,37))),eql(38,eql(le(39,40),eql(41,42))))),idiv(greater(43,44),imod(45,times(46,idiv(47,le(48,49))))))))),50)))),assign(vtotal27,pow(sub(eql(0,ne(1,2)),sub(3,add(4,idiv(5,times(ge(bor(6,7),8),rdiv(bor(9,10),rdiv(11,ne(12,13)))))))),pow(add(idiv(14,15),add(bor(16,17),sub(18,times(le(19,le(20,greater(21,ge(22,ge(23,24))))),greater(25,26))))),pow(sub(idiv(less(27,28),eql(29,greater(30,31))),32),pow(sub(imod(eql(33,34),times(bor(35,36),rdiv(greater(37,38),times(39,imod(ne(40,41),times(eql(42,less(43,44)),le(45,bor(46,47)))))))),sub(48,49)),50))))),assign(vtotal28,pow(imod(ne(bor(0,1),eql(2,ne(3,ne(bor(4,5),greater(6,bor(7,8)))))),9),pow(idiv(bor(10,11),times(less(bor(12,13),14),15)),pow(add(times(greater(bor(16,17),greater(18,ge(bor(19,20),21))),22),add(rdiv(23,rdiv(24,eql(25,26))),imod(bor(27,28),greater(29,less(30,greater(31,ge(32,33))))))),pow(rdiv(34,times(le(35,ge(bor(36,bor(37,38)),39)),bor(40,41))),sub(times(bor(42,43),rdiv(44,ge(45,46))),sub(ne(47,48),eql(49,50)))))))),assign(vtotal29,pow(add(idiv(0,imod(1,times(ne(2,3),4))),add(times(5,ge(6,7)),times(8,times(9,10)))),pow(times(eql(11,bor(12,13)),rdiv(greater(14,ge(15,le(16,17))),18)),pow(sub(19,sub(imod(ne(20,21),less(22,less(23,le(bor(24,bor(25,26)),27)))),28)),add(idiv(29,30),sub(eql(ge(31,less(32,le(33,34))),35),add(idiv(le(36,37),le(38,less(39,40))),add(rdiv(ne(bor(41,42),bor(43,44)),ne(45,greater(46,greater(bor(47,48),49)))),50)))))))),assign(vtotal30,pow(add(idiv(0,less(1,2)),sub(rdiv(3,imod(greater(4,5),times(bor(6,7),imod(less(8,9),imod(10,rdiv(le(11,le(12,13)),imod(14,imod(less(15,16),less(17,18))))))))),bor(19,bor(20,21)))),add(times(le(22,23),idiv(bor(24,25),imod(26,times(27,bor(28,29))))),sub(rdiv(30,times(31,idiv(less(32,33),ne(greater(34,greater(35,greater(36,37))),le(38,bor(39,40)))))),sub(times(41,times(42,times(ne(43,ge(44,greater(45,46))),times(47,48)))),bor(49,50)))))),assign(vtotal31,pow(idiv(ne(0,1),2),pow(sub(3,sub(ne(le(4,greater(5,6)),ne(le(7,8),9)),sub(times(ne(less(10,bor(11,12)),eql(13,ge(14,le(15,16)))),17),sub(imod(eql(18,ne(19,20)),21),sub(ne(22,ge(23,24)),sub(greater(25,26),add(ge(27,ge(28,ge(29,ge(bor(30,bor(bor(31,32),33)),34)))),sub(less(35,le(36,37)),38)))))))),pow(ne(bor(39,40),41),sub(rdiv(greater(42,43),rdiv(ne(44,45),ge(46,greater(47,48)))),add(49,50)))))),assign(vtotal32,pow(sub(idiv(0,1),add(2,add(idiv(3,ne(4,less(5,le(6,bor(7,8))))),sub(rdiv(ne(9,10),rdiv(greater(11,ge(12,13)),rdiv(ne(14,eql(15,eql(16,greater(17,18)))),ne(bor(19,20),ge(21,22))))),sub(le(23,24),sub(rdiv(25,idiv(eql(26,bor(27,28)),rdiv(29,imod(30,idiv(31,rdiv(ge(bor(32,bor(33,34)),35),36)))))),37)))))),pow(sub(le(38,39),times(less(40,bor(41,bor(42,43))),bor(44,45))),pow(46,add(47,eql(48,bor(49,50))))))),assign(vtotal33,pow(add(idiv(0,idiv(1,rdiv(2,ne(3,eql(less(4,less(bor(5,6),7)),le(bor(8,9),greater(10,greater(11,12)))))))),add(les s(13,14),rdiv(15,16))),pow(add(rdiv(17,idiv(ne(ge(18,greater(19,20)),21),rdiv(ne(less(22,le(23,24)),less(25,le(26,27))),times(ne(28,ne(bor(29,30),31)),32)))),times(33,imod(34,greater(35,bor(36,37))))),pow(rdiv(38,ge(39,40)),sub(imod(ne(41,42),rdiv(43,le(44,45))),sub(le(bor(46,47),greater(48,49)),50)))))),assign(vtotal34,pow(sub(imod(greater(bor(0,1),2),imod(ne(ge(3,4),le(5,6)),7)),8),pow(ne(9,10),pow(sub(idiv(11,imod(eql(bor(12,13),less(14,15)),times(16,times(17,rdiv(ge(18,less(19,20)),less(21,ge(22,23))))))),ne(less(24,25),26)),pow(sub(times(bor(27,28),idiv(eql(29,eql(30,eql(le(31,bor(32,33)),34))),le(35,36))),imod(le(37,38),idiv(ne(39,ne(40,bor(41,42))),less(43,greater(bor(44,45),46))))),idiv(eql(47,48),bor(49,50))))))),assign(vtotal35,pow(add(rdiv(less(0,1),times(2,imod(3,idiv(4,5)))),add(rdiv(ge(6,greater(7,8)),eql(9,greater(10,11))),add(12,eql(13,eql(14,ne(15,16)))))),add(idiv(17,imod(18,rdiv(ne(greater(bor(19,20),21),bor(22,23)),times(greater(24,25),bor(26,27))))),add(times(28,idiv(ne(29,greater(30,31)),times(ge(32,33),34))),sub(times(ne(35,36),imod(37,38)),add(idiv(39,ne(40,ge(41,42))),add(eql(43,eql(less(44,greater(bor(45,46),47)),48)),idiv(49,50)))))))),assign(vtotal36,pow(sub(0,add(imod(eql(less(1,bor(bor(2,3),4)),5),6),imod(7,8))),add(rdiv(9,eql(10,11)),sub(idiv(12,times(greater(13,bor(14,15)),imod(greater(16,17),rdiv(18,times(eql(bor(19,20),21),ne(le(22,23),bor(24,25))))))),sub(26,sub(ge(27,less(28,29)),add(rdiv(ge(30,less(31,32)),33),add(times(greater(34,35),times(eql(36,ne(le(37,less(38,less(39,40))),41)),42)),add(eql(43,bor(44,45)),sub(imod(46,47),add(le(48,49),50))))))))))),assign(vtotal37,pow(imod(0,1),pow(idiv(less(2,3),idiv(le(4,5),less(6,7))),pow(bor(8,9),pow(sub(times(ge(bor(10,11),12),imod(eql(13,ge(bor(14,15),16)),times(less(17,bor(18,19)),20))),sub(times(21,22),sub(rdiv(less(23,24),times(25,26)),ge(27,28)))),add(29,sub(rdiv(30,31),sub(32,add(times(less(33,le(34,less(35,bor(36,37)))),imod(eql(greater(38,greater(39,40)),eql(41,greater(42,43))),44)),sub(45,add(46,add(bor(47,48),rdiv(49,50))))))))))))),assign(vtotal38,pow(add(le(0,1),times(ge(2,3),idiv(ge(4,less(5,6)),idiv(7,ne(8,9))))),pow(sub(times(10,times(11,12)),add(rdiv(13,imod(ge(14,15),rdiv(16,imod(eql(17,18),rdiv(19,20))))),add(21,less(22,le(23,24))))),pow(sub(idiv(less(25,ge(26,ge(27,bor(28,bor(29,30))))),times(greater(31,32),times(greater(33,34),35))),ne(36,bor(37,38))),pow(39,pow(add(40,idiv(41,imod(42,bor(43,44)))),sub(rdiv(45,less(46,47)),imod(ne(48,49),50)))))))),assign(vtotal39,pow(sub(idiv(0,imod(1,rdiv(2,3))),sub(greater(4,le(5,6)),ne(7,less(8,bor(9,10))))),pow(sub(ge(11,greater(bor(12,13),14)),15),pow(rdiv(16,imod(ne(17,18),19)),pow(idiv(le(bor(bor(20,21),22),23),imod(ne(24,bor(25,26)),ge(27,28))),pow(add(imod(29,le(30,31)),add(32,times(33,le(34,35)))),pow(rdiv(greater(36,37),less(38,39)),pow(add(less(bor(40,41),42),sub(imod(43,le(44,bor(45,46))),47)),pow(48,imod(49,50)))))))))),assign(vtotal40,pow(imod(le(0,bor(1,2)),imod(3,imod(greater(bor(4,5),greater(6,7)),imod(8,imod(ge(9,10),11))))),pow(add(12,add(less(13,greater(14,greater(15,16))),sub(idiv(ge(17,18),idiv(19,rdiv(bor(20,21),22))),add(23,24)))),pow(rdiv(25,26),pow(sub(times(27,greater(28,29)),le(bor(30,31),32)),pow(add(rdiv(33,idiv(34,ge(35,36))),times(bor(37,bor(38,39)),times(40,41))),pow(times(42,idiv(bor(43,44),idiv(45,ge(46,47)))),eql(48,bor(49,50))))))))),assign(vtotal41,pow(less(0,1),pow(add(times(eql(2,3),4),ne(5,eql(6,7))),pow(add(8,add(eql(9,eql(greater(10,11),bor(12,13))),sub(14,rdiv(15,16)))),pow(add(imod(17,ne(18,eql(19,eql(20,eql(21,22))))),sub(times(ne(23,eql(bor(24,25),eql(26,ne(ge(27,28),bor(29,30))))),rdiv(31,32)),33)),pow(ge(34,35),pow(times(less(36,37),38),add(rdiv(bor(39,40),le(41,42)),add(times(ne(43,44),less(45,less(46,le(47,48)))),sub(49,50)))))))))),assign(vtotal42,pow(0,pow(sub(imod(ne(1,bor(2,bor(3,4))),eql(ge(bor(5,6),less(7,le(8,9))),ne(10,le(11,12)))),sub(imod(le(13,14),times(15,rdiv(bor(16,17),18))),times(19,20))),pow(sub(idiv(bor(21,22),23),sub(imod(24,25),times(greater(26,bor(27,28)),idiv(eql(greater(29,30),greater(31,32)),rdiv(ne(33,le(34,ge(35 ,bor(36,bor(37,38))))),ge(39,40)))))),pow(add(41,rdiv(42,rdiv(eql(43,le(44,45)),less(46,ge(47,48))))),eql(49,50)))))),assign(vtotal43,pow(sub(imod(ne(0,1),rdiv(le(2,le(3,bor(4,5))),eql(le(6,less(7,8)),9))),add(imod(le(10,11),eql(ge(bor(12,13),le(14,15)),16)),idiv(17,18))),pow(add(idiv(19,imod(eql(20,ne(21,22)),times(ne(23,greater(24,25)),bor(26,27)))),idiv(less(28,29),rdiv(bor(30,31),times(32,imod(33,times(bor(34,35),times(less(36,le(37,38)),idiv(ne(less(39,40),41),less(42,greater(43,44)))))))))),pow(times(eql(45,46),imod(47,48)),rdiv(49,50))))),assign(vtotal44,pow(add(times(bor(0,1),bor(2,3)),add(times(ne(4,5),le(6,7)),sub(rdiv(8,imod(ge(9,10),rdiv(11,eql(less(12,13),14)))),sub(times(eql(less(15,bor(16,17)),18),ge(19,less(20,le(21,22)))),add(idiv(23,bor(24,25)),sub(imod(eql(ge(26,27),le(28,29)),imod(30,31)),sub(times(32,less(33,greater(34,35))),add(36,add(bor(37,38),39))))))))),sub(times(ne(40,41),rdiv(less(42,le(43,44)),imod(ge(45,46),47))),rdiv(48,bor(49,50))))),assign(vtotal45,pow(add(rdiv(le(0,1),imod(2,idiv(3,ne(4,greater(5,6))))),ne(7,ne(8,bor(9,10)))),pow(add(11,add(idiv(12,idiv(13,rdiv(14,idiv(15,imod(eql(less(16,ge(17,18)),le(19,20)),imod(21,22)))))),add(23,24))),pow(imod(less(25,26),times(27,less(28,greater(29,30)))),pow(times(greater(31,32),rdiv(33,rdiv(34,idiv(greater(35,36),greater(37,38))))),add(idiv(ge(39,greater(bor(40,bor(41,42)),43)),44),times(45,imod(46,bor(bor(47,bor(48,49)),50))))))))),assign(vtotal46,pow(sub(0,add(eql(1,ge(2,3)),rdiv(4,ge(5,6)))),pow(sub(rdiv(bor(7,8),9),add(10,idiv(bor(11,12),times(le(13,ge(14,15)),rdiv(16,eql(bor(17,18),ge(19,20))))))),sub(times(21,imod(22,ne(23,24))),rdiv(eql(ge(25,26),eql(27,ne(bor(28,29),eql(bor(30,31),32)))),imod(33,rdiv(eql(34,less(bor(35,36),37)),rdiv(eql(bor(38,39),greater(40,41)),imod(le(bor(42,43),44),idiv(45,rdiv(46,idiv(47,ne(48,bor(49,50)))))))))))))),assign(vtotal47,pow(sub(imod(eql(le(0,bor(1,2)),3),4),5),pow(sub(idiv(6,times(ge(7,8),idiv(9,times(ge(10,11),times(12,idiv(less(13,14),imod(15,times(eql(16,17),eql(18,19))))))))),add(20,add(21,times(22,times(23,times(24,idiv(25,idiv(ne(le(26,bor(27,28)),ge(29,30)),idiv(31,ne(32,33)))))))))),pow(imod(ge(34,35),rdiv(eql(36,37),38)),pow(sub(imod(39,40),sub(le(bor(41,bor(42,43)),44),times(greater(45,46),le(47,48)))),imod(49,50)))))),assign(vtotal48,pow(add(imod(0,rdiv(less(1,2),idiv(3,times(4,idiv(5,6))))),add(idiv(le(7,8),9),sub(imod(less(10,ge(11,12)),13),sub(14,add(times(greater(15,bor(16,17)),idiv(le(18,19),rdiv(20,times(21,ge(bor(22,23),24))))),times(25,26)))))),pow(27,pow(add(rdiv(ge(28,bor(29,30)),31),add(32,times(33,34))),pow(add(35,sub(imod(36,37),add(38,greater(39,bor(40,41))))),add(ne(42,eql(43,le(44,greater(45,less(46,47))))),ne(48,ge(49,50)))))))),assign(vtotal49,pow(sub(idiv(eql(bor(0,1),2),times(less(3,bor(4,5)),idiv(6,rdiv(7,eql(less(8,9),eql(10,11)))))),sub(12,idiv(greater(13,14),15))),pow(imod(16,imod(17,18)),pow(sub(rdiv(19,20),times(eql(bor(21,22),greater(23,le(24,ge(25,le(26,27))))),idiv(28,bor(29,30)))),pow(idiv(less(bor(31,32),33),rdiv(less(bor(34,35),36),ne(37,le(bor(38,39),40)))),pow(41,idiv(eql(le(42,43),less(44,less(45,46))),times(ge(47,48),times(49,50))))))))),assign(vtotal50,pow(add(0,add(rdiv(eql(greater(1,greater(2,less(3,4))),5),6),add(7,times(eql(8,ne(less(9,10),11)),12)))),pow(idiv(13,times(less(14,15),le(16,17))),pow(add(rdiv(18,bor(19,20)),add(rdiv(le(21,22),imod(greater(23,24),rdiv(ne(le(25,less(bor(26,27),28)),eql(29,le(30,greater(bor(bor(31,32),bor(33,34)),35)))),imod(ne(ge(36,37),38),imod(39,ne(40,41)))))),add(less(42,43),sub(44,45)))),eql(bor(46,bor(47,48)),ne(49,50)))))),assign(vtotal51,pow(rdiv(0,1),pow(sub(idiv(2,idiv(less(3,4),ne(5,less(6,ge(7,8))))),add(rdiv(less(9,10),times(ne(11,12),13)),sub(14,15))),pow(sub(rdiv(bor(16,17),ne(18,19)),add(ne(20,greater(21,22)),sub(times(eql(23,24),times(25,rdiv(less(26,27),28))),add(ne(bor(29,30),31),add(imod(ne(le(32,33),34),le(bor(35,36),37)),idiv(ne(38,less(39,40)),41)))))),pow(idiv(less(42,43),idiv(less(44,45),times(46,le(47,less(48,49))))),50))))),assign(vtotal52,pow(times(eql(0,1),rdiv(2,3)),pow(sub(4,ne(le(5,6),less(7,8) )),pow(idiv(le(bor(9,bor(10,bor(11,12))),ge(13,14)),idiv(eql(15,less(bor(16,17),ge(18,19))),imod(less(20,less(21,le(22,23))),24))),pow(25,add(imod(26,times(less(27,greater(28,le(29,30))),idiv(bor(31,32),33))),idiv(eql(ge(34,35),greater(36,37)),idiv(ne(38,eql(39,ge(bor(40,41),42))),times(less(43,ge(44,45)),times(ge(46,less(47,48)),bor(49,50))))))))))),assign(vtotal53,pow(add(times(0,times(ge(bor(1,2),le(3,4)),rdiv(5,ne(6,bor(7,8))))),times(le(9,10),11)),pow(eql(12,13),pow(imod(greater(14,15),16),pow(add(17,bor(18,19)),pow(add(imod(eql(20,21),times(22,23)),add(imod(24,imod(greater(bor(25,26),27),28)),29)),pow(sub(imod(30,times(31,times(32,times(33,times(34,35))))),rdiv(36,bor(37,38))),sub(times(39,40),add(41,times(42,rdiv(less(43,greater(44,45)),times(46,times(greater(47,48),bor(49,50)))))))))))))),assign(vtotal54,pow(sub(0,add(imod(1,greater(bor(2,3),4)),sub(5,sub(6,add(rdiv(7,8),sub(times(9,le(10,11)),idiv(12,rdiv(less(13,14),rdiv(greater(15,le(16,greater(bor(17,18),19))),greater(bor(20,21),22)))))))))),pow(rdiv(eql(le(23,24),eql(25,26)),27),pow(rdiv(28,times(29,idiv(30,times(bor(31,32),times(ne(bor(33,34),35),36))))),add(bor(37,38),add(imod(39,rdiv(40,times(41,42))),add(eql(43,44),add(times(45,ne(bor(46,47),bor(48,49))),50)))))))),assign(vtotal55,pow(add(0,sub(imod(1,bor(2,3)),sub(imod(4,5),add(imod(6,7),sub(rdiv(ne(8,9),10),add(less(11,greater(bor(12,13),14)),times(15,imod(ge(16,less(17,18)),19)))))))),add(20,add(greater(bor(21,22),23),add(rdiv(less(24,25),times(eql(greater(26,le(27,28)),eql(29,30)),greater(31,32))),sub(ge(bor(33,34),35),add(rdiv(36,eql(less(37,38),ge(39,ge(40,41)))),add(bor(42,43),sub(times(bor(44,45),idiv(bor(46,47),less(48,49))),50))))))))),assign(vtotal56,pow(0,pow(sub(le(1,2),idiv(eql(ge(3,bor(4,5)),less(6,greater(bor(7,bor(8,9)),less(10,bor(11,12))))),imod(eql(13,bor(14,15)),16))),pow(add(imod(ne(17,18),19),add(idiv(less(20,greater(21,less(22,23))),24),sub(idiv(le(25,26),idiv(27,ge(28,greater(bor(29,30),bor(31,32))))),sub(eql(le(33,ge(34,greater(35,36))),bor(37,38)),times(39,idiv(40,ne(41,eql(le(42,43),eql(44,45))))))))),sub(le(46,greater(47,ge(48,49))),50))))),assign(vtotal57,pow(imod(bor(0,1),eql(2,3)),pow(sub(4,sub(imod(ge(5,greater(6,7)),times(ne(8,ne(ge(9,10),11)),times(12,idiv(13,rdiv(14,ge(15,16)))))),imod(17,idiv(18,imod(19,imod(20,21)))))),pow(add(idiv(22,times(less(bor(23,24),le(25,greater(26,ge(27,less(28,29))))),le(bor(30,31),ge(32,33)))),imod(le(34,less(35,36)),imod(37,bor(bor(38,39),40)))),pow(41,add(ne(42,43),sub(rdiv(le(44,greater(45,46)),47),times(48,times(49,50))))))))),assign(vtotal58,sub(times(ge(0,1),rdiv(2,idiv(ge(bor(3,4),5),imod(6,rdiv(7,8))))),sub(idiv(le(9,greater(10,bor(11,12))),eql(less(13,14),le(15,16))),add(idiv(le(17,le(18,bor(19,20))),times(greater(21,bor(22,23)),ne(24,bor(25,26)))),sub(times(eql(27,bor(28,29)),30),add(imod(greater(31,32),imod(eql(greater(33,34),35),imod(36,rdiv(37,times(38,idiv(39,40)))))),imod(eql(41,eql(bor(42,43),44)),eql(45,ne(46,eql(less(47,48),ge(49,50))))))))))),assign(vtotal59,pow(sub(times(0,1),2),pow(times(le(3,4),times(5,less(6,7))),pow(imod(le(8,9),10),pow(add(idiv(le(11,le(12,less(13,14))),rdiv(less(15,16),17)),rdiv(ne(18,greater(19,20)),greater(21,greater(22,23)))),pow(sub(times(24,ne(25,le(26,27))),add(bor(28,29),add(less(30,greater(31,32)),less(33,34)))),sub(imod(le(35,36),times(greater(bor(37,38),39),40)),sub(rdiv(bor(41,42),43),times(44,times(45,imod(greater(46,47),ne(greater(48,49),50)))))))))))),assign(vtotal60,pow(sub(ne(bor(0,1),ne(greater(2,bor(3,4)),5)),sub(times(6,times(le(bor(7,8),bor(9,bor(10,11))),rdiv(eql(12,eql(13,14)),imod(15,times(bor(16,17),idiv(18,times(le(19,20),imod(21,imod(eql(bor(22,23),24),rdiv(25,imod(eql(less(26,bor(27,28)),bor(29,30)),idiv(31,ge(32,ge(33,less(34,35))))))))))))))),add(36,idiv(37,times(38,imod(39,less(40,bor(41,42)))))))),sub(idiv(less(43,44),45),add(imod(less(46,47),48),idiv(49,50))))),assign(vtotal61,pow(add(times(greater(0,1),rdiv(ne(2,greater(3,4)),imod(5,idiv(eql(bor(6,7),8),9)))),add(10,sub(times(bor(11,12),rdiv(eql(13,14),idiv(15,idiv(16,le(bor(17,18),19))))),sub(rdiv(20,imod(ne(ge(21 ,less(bor(22,23),24)),ge(25,bor(26,27))),28)),29)))),add(rdiv(eql(30,ne(ge(31,less(32,33)),34)),rdiv(less(35,36),idiv(37,eql(less(38,greater(39,40)),ne(41,42))))),rdiv(ne(greater(bor(43,44),45),46),times(less(47,ge(48,49)),50))))),assign(vtotal62,pow(idiv(0,times(ge(1,2),imod(greater(3,4),ge(5,6)))),pow(sub(imod(7,rdiv(8,rdiv(9,imod(10,times(ge(11,le(12,13)),ge(bor(14,15),bor(16,17))))))),add(le(18,bor(19,20)),add(21,add(idiv(greater(bor(22,23),24),25),add(ne(26,27),sub(28,add(29,eql(30,31)))))))),pow(add(times(le(bor(32,33),34),imod(35,36)),less(37,less(38,39))),pow(ge(40,41),pow(add(bor(42,43),add(ge(44,45),le(46,less(bor(47,48),49)))),50)))))),assign(vtotal63,pow(0,add(ne(1,bor(2,3)),add(idiv(eql(4,5),times(6,eql(7,eql(ge(8,le(9,10)),ge(11,12))))),add(idiv(13,14),add(idiv(bor(bor(15,16),17),rdiv(18,bor(19,20))),add(times(bor(21,22),times(23,24)),sub(eql(greater(25,26),27),sub(eql(bor(28,29),bor(30,31)),add(imod(32,times(ge(33,34),imod(35,imod(bor(36,37),idiv(38,rdiv(bor(39,40),idiv(le(41,bor(bor(42,43),44)),rdiv(eql(45,46),47)))))))),times(bor(48,49),50))))))))))),assign(vtotal64,pow(sub(eql(0,1),ne(2,bor(3,4))),pow(add(bor(5,6),add(eql(7,less(8,9)),sub(10,add(times(11,ne(12,13)),sub(14,add(15,sub(16,sub(rdiv(17,18),add(times(ge(19,20),idiv(21,22)),rdiv(less(23,less(24,less(25,26))),rdiv(greater(27,28),imod(greater(29,30),idiv(eql(31,ne(less(32,33),34)),times(35,idiv(ne(36,37),ne(greater(38,39),ne(40,le(41,42)))))))))))))))))),imod(43,rdiv(44,rdiv(ge(bor(45,46),47),greater(bor(48,49),50))))))),assign(vtotal65,pow(bor(0,1),pow(add(idiv(less(2,3),4),add(rdiv(greater(bor(5,6),bor(7,bor(8,9))),10),sub(imod(11,ne(le(12,13),bor(bor(14,15),16))),sub(times(17,idiv(le(18,le(19,le(20,21))),times(22,23))),bor(24,25))))),pow(add(times(26,27),add(ge(28,29),add(rdiv(greater(30,ge(31,32)),ne(33,34)),bor(35,36)))),sub(rdiv(bor(37,38),le(39,40)),idiv(41,rdiv(42,imod(bor(43,44),imod(45,idiv(46,eql(greater(47,bor(48,49)),50))))))))))),assign(vtotal66,pow(sub(idiv(bor(0,1),times(2,imod(3,bor(4,5)))),sub(6,times(7,idiv(bor(8,9),idiv(10,rdiv(11,less(12,bor(13,14)))))))),add(15,sub(16,sub(imod(ge(17,18),idiv(19,imod(20,times(21,imod(ne(greater(22,23),24),idiv(eql(25,26),idiv(ne(27,28),idiv(29,times(30,times(eql(less(31,32),33),times(34,rdiv(35,imod(greater(36,bor(37,38)),le(39,le(40,41))))))))))))))),sub(rdiv(42,eql(43,44)),ne(bor(45,46),ge(47,greater(48,le(49,50)))))))))),assign(vtotal67,add(rdiv(ge(0,ge(1,less(2,less(3,le(bor(4,5),6))))),rdiv(ge(7,8),9)),sub(times(le(10,11),idiv(eql(12,le(13,14)),idiv(ge(15,16),17))),sub(rdiv(18,19),sub(ne(20,21),sub(idiv(ge(22,less(23,24)),times(eql(25,26),times(ge(27,28),times(29,times(le(30,bor(31,bor(32,33))),rdiv(ne(34,ge(bor(35,36),le(37,38))),times(39,times(ge(40,41),42)))))))),sub(times(bor(43,44),imod(bor(45,46),47)),greater(48,greater(49,50))))))))),assign(vtotal68,pow(0,pow(sub(1,add(2,sub(3,eql(le(4,less(5,6)),7)))),pow(8,pow(add(eql(ge(9,le(bor(10,11),greater(12,13))),ge(14,15)),add(imod(ne(16,eql(17,18)),times(le(19,ge(20,21)),idiv(ge(bor(22,bor(23,24)),25),26))),idiv(bor(27,28),ge(bor(29,30),less(31,32))))),add(idiv(less(33,34),times(ne(35,ge(36,ge(37,38))),39)),sub(idiv(bor(40,bor(41,42)),imod(43,imod(44,45))),imod(46,times(47,ne(48,le(49,50))))))))))),assign(vtotal69,pow(idiv(le(0,1),times(bor(2,3),idiv(ne(4,5),times(6,rdiv(less(7,bor(8,9)),idiv(ge(10,ge(11,12)),rdiv(13,idiv(14,rdiv(ne(15,16),17))))))))),pow(sub(18,sub(times(19,idiv(20,21)),add(idiv(22,idiv(ge(bor(23,24),25),ge(26,27))),ge(28,29)))),pow(add(30,add(imod(eql(greater(31,32),greater(bor(33,bor(34,35)),less(36,37))),imod(eql(38,bor(39,40)),rdiv(eql(41,ne(42,43)),eql(44,le(45,greater(bor(46,47),48)))))),49)),50)))),assign(vtotal70,pow(add(idiv(less(0,1),imod(2,times(bor(3,4),rdiv(ne(5,ge(6,ge(7,8))),imod(ge(9,le(10,ge(bor(11,12),13))),times(14,imod(15,imod(16,idiv(bor(17,18),idiv(ne(19,20),le(21,ge(bor(22,23),24)))))))))))),add(rdiv(25,less(26,27)),sub(bor(28,29),add(rdiv(30,le(31,32)),sub(bor(33,34),add(35,sub(times(eql(ge(36,37"
Phúc Trí,1,12/18/2011,định nghĩa path of the execution of the function?,"đãđọc mấy topic khác mà vẫn chưa hiểuđượcpath of the execution of the function trong Crazy nàyđượcđịnh nghĩa như thế nào? Mỗi ngôn ngữ có 1đặc tả, cách hiện thực khác nhau, vậy mà thầy cũng chẳngđịnh nghĩa 1 câu.Chẳng biếtđâu mà làm."
Sieutoc,1,12/19/2011,Re:định nghĩa path of the execution of the function?,Mình có một cách hiểu về execution path như thế này muốn chia sẻ cùng bạn: - execution path là đường thực thi của chương trình mà từ lúc chương trình bắt đầu đi vào và cho đến khi đi hết đường thực thi đó thì cũng là lúc kết thúc chương trình. Trong một chương trình thì có thể có một hoặc nhiều execution path. vd: -Các execution path này đôi khi chồng lấn lẫn nhau ở một số bộ phận. function example(a:integer) : real; begin var x: integer; x:= 3; if ((a+x) > 10) then a:=0; else a:=1; loop(a) do begin a:=0; return a; end return a; end; - Đôi khi phân định rõ ràng function example(a:real):real; begin if (a > 3) then return 0; else return 1 end;
Nhan Nguyen Van,1,12/19/2011,Re:định nghĩa path of the execution of the function?,Vậy chương trình sau có bao nhiểu đường thực thi. var a: boolean; function func(): real; begin if a then return 1; end;
Sieutoc,1,12/19/2011,Re:định nghĩa path of the execution of the function?,"có 1 đường bạn. Đường vào là if .... , sau khi hết đường đó thì cũng là lúc kết thúc hàm func."
Nhan Nguyen Van,1,12/22/2011,Re:định nghĩa path of the execution of the function?,"Vậy nếu trong chương trình có một câu lệnh return ở ngoài thì trong if else, while , loop không cần xét nữa đúng ko? Vì đường thực thi luôn đi qua câu lệnh return này Ví du 1: var a: boolean; function main():real; begin if a then a := true; return 0; end; Ví du 2: var a: boolean; function main():real; begin return 0; if a then a := true; end; 2 trường hợp trên có báo lỗi không"
vanhoa,1,10/30/2011,Testcase cho stage 2,"Download: http://www.vhn.vn/u/tesS2.zip [update 07/11/2011] Code gen output: Code: import scala.io.Source

 import java.io.FileWriter

 

 object TestParser {

   //-|not|and|or|>|>=|<|<=|<>|==|*|/|div|mod|+|-|^

   def main(args: Array[String]): Unit = {

     (11 to 27).foreach(testNC(_))

   }

   def prettyPrint(s: String) = {

 	  var sp = """"

 	  var sc = 0

 	  var ln = 1

 	  var stack: List[Int] = List()

     (""%4d | %4d | %4d : "".format(0,0,0) /: s.toCharArray()){

       (r: String, c: Char) => {

         r + (c match {

           case ',' => ln += 1; c+""\n""+""%4d | %4d | %4d : "".format(ln,sc,stack.head)+sp

           case '(' => sp=sp+""  ""; sc+=1; stack = ln :: stack ; c //+sp

           case ')' => sp=sp.substring(0,sp.length()-2); sc-=1; stack=stack.tail ; c //+sp

           case '[' => sp=sp+""  ""; sc+=1; stack = ln :: stack ; c //+sp

           case ']' => sp=sp.substring(0,sp.length()-2); sc-=1; stack=stack.tail ; c //+sp

           case c => c

         })

       }

     }

   }

   def testNC(no: Integer): Unit = {

     val inputFile = ""desc/testcase/test""+no+"".my.txt""

     println(""############Process [[""+inputFile+""]]###############"");

     val lines = Source.fromFile(inputFile).getLines

     val input = if (!lines.isEmpty) lines.reduceLeft[String](_ + '\n' + _) else """"

 

     val parser = new CrazyParser

     val result = parser.parse(input)

     var res=parser.show(result);

     //println(""_______ Result: ""+res);

     //println(""_______ Result: ""+prettyPrint(res));

     

     var outPut = new FileWriter(inputFile.replace(""testcase"",""testsol"").replace(""txt"",""pt""))

     outPut.write(res+""\n"")

     outPut.close();

     

     outPut = new FileWriter(inputFile.replace(""testcase"",""testsol"").replace(""txt"",""pretty.pt""))

     outPut.write(

 	    (result match {

 	      case parser.Failure(msg, next) =>

 	        ""line ""+next.pos.line+"":""+next.pos.column+"": unexpected token: ""+parser.clean(next.first)

 	      case _ => prettyPrint(result.get.toString)

 	    }) + ""\n"")

     outPut.close();

   }

   def test(no: Integer): Unit = {

     val inputFile = ""desc/testcase/test""+no+"".txt""

     println(""############Process [[""+inputFile+""]]###############"");

     val lines = Source.fromFile(inputFile).getLines

     val input = if (!lines.isEmpty) lines.reduceLeft[String](_ + '\n' + _) else """"

 

     val parser = new CrazyParser

     val result = parser.parse(input)

     var in2=inputFile.replace(""testcase"",""testsol"").replace(""txt"",""pt"")

     var res=parser.show(result);

     println(""_______ Result: ""+res);

     print(""Correct Result: "");

     val Cresult = Source.fromFile(in2).getLines.foreach(println(_))

   }

 } Để kiểm tra bằng file pretty, các bạn có thể dùng diff."
nguyen dung,1,11/5/2011,Re:Testcase cho stage 2,dấu "-" đó là 1 ngôi đó bạn.
vanhoa,1,10/30/2011,Testcase cho stage 2,"A Hùng xem giúp e test25 xem e hiểu đúng ko nhé. Code: procedure main();

begin

	while 1 do begin end

	break;

end; Cái này break nằm ngoài while nên sẽ báo lỗi?"
librastar,1,10/30/2011,Re:Testcase cho stage 2,"Đã test thử, có vài khác biệt: Test 11: Bạn chưa kiểm tra type của mảng? VD: Code: const myArrayConst3 = [1;false;3.5]; Test 25: procedure main();



begin

     while 1 do begin end

     break;

end; Trường hợp này ko biết sẽ check ở phần static checker hay dectect ngay tại assignment1 này luôn. Chờ ý kiến của thầy.^^"
vanhoa,1,10/30/2011,Testcase cho stage 2,Mình nghĩ h chưa cần kt type:-?
cong thanh,1,10/31/2011,Re:Testcase cho stage 2,"v4:=1--2-----4; có trường hợp như thế này sao bạn mà sao lại trả về assign(v4,sub(sub(1,sub(2)),sub(sub(sub(sub(4))))))"
vanhoa,1,10/31/2011,Testcase cho stage 2,Thì nó chỉ là (1-(-2))-(-(-(-(-4)))) thôi :)
thanhnghi_py,1,11/5/2011,Re:Testcase cho stage 2,v9:= 1 >= 2 = 3<=4 <> 5=6 > 7 > 8 > 9 = 10; biểu thức trên (trong test 1) hiểu thế nào đây hòa
Doan Tuan Sang,1,11/5/2011,Re:Testcase cho stage 2,"với lại test này ra gì vậy? procedure init(x:array[5] of integer); begin x[i]:=a[i]; end; minh ra [proc(init,[par(x,arr([5],int))],[assign(ele(x,[i]),ele(a,[i]))])] hok bit dung hok"
MFC.Maximus,1,11/5/2011,Re:Testcase cho stage 2,"các bạn cho mình hỏi testcase 26 procedure main(); begin if 1 then if 2 then if 3 then s3(); else s4(); else s5(); else if 7 then s7(); else if 8 then s8(); else if 9 then s9(); end; ở đây theo bạn Hòa thì s3 là functioncall trong khi đó định nghĩa của if statement làif <expression> then <statement> else <statement> or if <expression> then <statement> vậy functioncall lúc này chấp nhận là statement hả? nếu vậy mình không định nghĩa được @@ đáp án của bạn hòa[proc(main,[],[if(1,if(2,if(3,call(s3,[]),call(s4,[])),call(s5,[])),if(7,call(s7,[]),if(8,call(s8,[]),if(9,call(s9,[])))))])]"
Tri,1,11/5/2011,Testcase cho stage 2,"Trong stage này mình không kiểm tran kiểu, nhưng theo đặc tả cảu Crazy thì không có expr kiểu String , vậy có 1 + 2 + 'abc' có parser được hay không? function testExpr(a: real;b,c,d:array[3,2,1] of real):array[1,2,3] of real; begin v1:=1+true+false+'abc'+[1;2;3]+a+a[0]+a[0,1]; end;"
Tri,1,11/5/2011,Re:Testcase cho stage 2,"Scala ^^  wrote: expr có const, mà const gồm có string mà bạn Thanks, chắc làm theo số đông thôi. Còn break|continue bạn có kiểm tra không hay bỏ vô stmt luôn?"
Tri,1,11/5/2011,Re:Testcase cho stage 2,"Scala ^^  wrote: giai đoạn này thầy nói k kiểm tra cái đó, mình bỏ vô stmt luôn Đặc tả mơ hồ quá ^^. Cảm ơn bạn nhé"
Forever Alone,1,11/6/2011,Re:Testcase cho stage 2,//Post nhầm ^^. Đã xóa
cong thanh,1,10/31/2011,Re:Testcase cho stage 2,hàm sub nhận 1 biến đc ah theo mình nghĩ phải là bnot chứ
cong thanh,1,10/31/2011,Re:Testcase cho stage 2,const myArrayConst3 = [1;false;3.5]; const myArrayConst4 = [[2; 4];3;true]; 2 trường hợp này theo đặc tả là k nhận đc thầy có ghi Note that the elements of an array must be in the same type. For example [1;3;2]    array size 3 of integer [3.2;.2E-2]   array size 2 of real [[1;2];[3;4]]  two-dimensional array of integer []     empty array [[1;2];3;4]   not a multi-dimensional array [1;2;true]   array with mixed element types
Vu Dang,1,10/31/2011,Re:Testcase cho stage 2,"cho minh hoi ket qua cua test nay la the nao? var a, b : integer;"
cong thanh,1,10/31/2011,Re:Testcase cho stage 2,"[var(a,int),var(b,int)]"
walk alone,1,10/31/2011,Re:Testcase cho stage 2,cong thanh wrote: const myArrayConst3 = [1;false;3.5]; const myArrayConst4 = [[2; 4];3;true]; 2 trường hợp này theo đặc tả là k nhận đc thầy có ghi Note that the elements of an array must be in the same type. For example [1;3;2]    array size 3 of integer [3.2;.2E-2]   array size 2 of real [[1;2];[3;4]]  two-dimensional array of integer []     empty array [[1;2];3;4]   not a multi-dimensional array [1;2;true]   array with mixed element types cai nay toi static check moi kiem tra thi phai.
cong thanh,1,10/31/2011,Re:Testcase cho stage 2,cần thầy vô trả lời chứ chả bít nên làm sao cả
Long Nguyễn,1,11/1/2011,Testcase cho stage 2,"Thế trường hợp sau có parse được không nhỉ: procedure a(); begin a := a[a,a[a]]; end; Hiện mình cho parse tree là: [proc(a,[],[assign(a,ele(a,[a,ele(a,[a])]))])]"
Long Nguyễn,1,11/1/2011,Testcase cho stage 2,"@vanhoa: cái chỗ unexpected token đó ko có cặp dấu `' đâu nhé, cẩn thận!"
vanhoa,1,11/1/2011,Testcase cho stage 2,@cong thanh: hien tai minh chua kiem tra cai do ban. @Long: Ủa có test nào mình xuất cái đó ah?
cong thanh,1,11/1/2011,Re:Testcase cho stage 2,bạn xem lại chỗ v4 sẽ thấy
vanhoa,1,11/1/2011,Testcase cho stage 2,Ý mình là ở bước này chưa cần kiểm tra kiểu
Nhan Nguyen Van,1,11/3/2011,Re:Testcase cho stage 2,"procedure main(); begin a := [1;true]; end; vậy nếu có testcase như vậy thì kết quả là gì? line 3:10: unexpected token: true hay[proc(main,[],[assign(a,[1;true])])]"
Phúc Trí,1,12/20/2011,Biểu thức hằng??,"Em có 1 vài thắc mắc xin thầy giải đáp. 1. Thầy cho em hỏi là biểu thức hằng nghĩa là trong biểu thức chỉ có const và giá trị trực tiếp. hay biểu thức hằng là biêu thức có giá trị không bao giờ thay đổi. VD var x:Boolean; x:=false; while( x or true ).. thì lúc đó (x or true) , có được coi là biểu thức hằng đúng hay ko? 2. Về vấn đề các điều kiện loop, while, if, nếu giá các biểu thức trong đó chắc chắn đúng hoặc chắc chắn sai (với điều kiện biểu thức hằng, không có những trường hợp x <= x hay x < x + 1) thì vẫn xem xét. x có thể là const hay không? 3. Nêu trong biểu thứcđiều kiện mà có biến var thì nóđược xem là khôngđúng không sai phải khôngạ? 4. Nếu có while điều kiện luôn luôn đúng và trong body có lệnh Ruturn thì mình có cần xem xét phần dưới while có return hay không? VD: function foo():integer; begin while(true) begin return 9; end end; hàm foo trên có bị báo lỗi ko có Return hay ko? 5. Câu lệnh Return có cần có điều kiện nằm trước break,continue mới được tính như phần h hay không? Em cám ơn thầy."
Phúc Trí,1,12/22/2011,Tầm ảnh hưởng của câu lệnh Return. Mong thầy giải đáp giúp.,"1.Thầy cho e hỏi là tầmảnh hưởng của câu lệnh returnđến phép gán tương tự như break và continue phải không? (hy vọng là sẽ như nhau cho tụi emđỡ khổ) 2. procedure pro(); begin var a,x:integer; while(true) begin while(true) begin return 0; a:=0;// câu lệnh gán này chắc chắn sẽ khôngđược tính end a:=9;// câu lệnh gán này cóđược tính hay không? end x:=a+1; end;"
Phúc Trí,1,12/22/2011,Re:Tầm ảnh hưởng của câu lệnh Return. Mong thầy giải đáp giúp.,thầy không thấy câu hỏi này của mình rồi. có ai giúp mình không
Sieutoc,1,11/6/2011,Re:Testcase cho stage 2,vd:= not not not not 4 ; Các bạn cho mình hỏi xài not như vậy là not có kết hợp phải rồi phải không. Nhưng ma trong đề thì mình thấy not không có kêt hợp nào cả. Có phải nên sửa lại là: vd: = not (not (not (not 4)));
Long Nguyễn,1,11/6/2011,Re:Testcase cho stage 2,Mai Hoa Đạo  wrote: vd:= not not not not 4 ; Các bạn cho mình hỏi xài not như vậy là not có kết hợp phải rồi phải không. Nhưng ma trong đề thì mình thấy not không có kêt hợp nào cả. Có phải nên sửa lại là: vd: = not (not (not (not 4))); Như vậy là parse được rồi.
meo_lac,1,11/6/2011,Re:Testcase cho stage 2,"nguyen dung wrote: 1) trường hợp var x : array[ 0 ] of integer cũng sẽ parse thành công phải ko ạ? Parse thành công ""The integer constant represents the size of the corresponding dimension and it must be a positive number, i.e. number greater than 0"" Chỗ này cũng mâu thuẫn với đề nè cái demision đề nói phải > 0 mà này parse thành công. Nguồn: https://elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3407.page Thầy trả lời đúng rồi đó bạn, k có j mâu thuẫn đâu. Tại vì giai đoạn này chỉ kiểm tra cú pháp thôi (tức là mặt chữ đó), còn những cái liên quan đến ngữ nghĩa, tầm vực, kiểu thì k quan tâm. Còn trong file PT thầy thêm trường hợp list null cho ArrayLiteral và EleExpr là để tránh xảy ra exception trong quá trình chạy test (giả sử quá trình test bài của bạn bị exception thì sẽ bị exit => k test tiếp cho bạn những test sau) ^^. Trường hợp array const thì đề đã ghi rõ là ''An array constant is a semicolon-separated list of elements enclosed in left and right square brackets. The list may NOT be empty '' , còn trường hợp element thì mình nghĩ cũng tương tự. Có j sai mọi người chỉ bảo. ^^"
Long Nguyễn,1,11/6/2011,Re:Testcase cho stage 2,"meo_lac  wrote: nguyen dung wrote: 1) trường hợp var x : array[ 0 ] of integer cũng sẽ parse thành công phải ko ạ? Parse thành công ""The integer constant represents the size of the corresponding dimension and it must be a positive number, i.e. number greater than 0"" Chỗ này cũng mâu thuẫn với đề nè cái demision đề nói phải > 0 mà này parse thành công. Nguồn: https://elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3407.page Thầy trả lời đúng rồi đó bạn, k có j mâu thuẫn đâu. Tại vì giai đoạn này chỉ kiểm tra cú pháp thôi (tức là mặt chữ đó), còn những cái liên quan đến ngữ nghĩa, tầm vực, kiểu thì k quan tâm. Còn trong file PT thầy thêm trường hợp list null cho ArrayLiteral và EleExpr là để tránh xảy ra exception trong quá trình chạy test (giả sử quá trình test bài của bạn bị exception thì sẽ bị exit => k test tiếp cho bạn những test sau) ^^. Trường hợp array const thì đề đã ghi rõ là ''An array constant is a semicolon-separated list of elements enclosed in left and right square brackets. The list may NOT be empty '' , còn trường hợp element thì mình nghĩ cũng tương tự. Có j sai mọi người chỉ bảo. ^^ Phần trước thì mình đồng ý với bạn, còn phần để tránh xảy ra exception thì chắc là không có đâu."
Sieutoc,1,11/6/2011,Re:Testcase cho stage 2,Bạn @vanhoa ơi cho mình hỏi link ở đầu topic là testcase + testsolution mới nhất phải không bạn
Minh Nguyen,1,11/6/2011,Re:Testcase cho stage 2,"Mai Hoa Đạo  wrote: Bạn @vanhoa ơi cho mình hỏi link ở đầu topic là testcase + testsolution mới nhất phải không bạn Hoà đi Thái Lan với thầy Hùng rồi bạn ơi. Cái testsol trên Hoà chưa sửa thì phải. Còn cái vụ a[]:= có parse được hay ko thì chẳng ai biết được vì đề ko đặc tả chỗ này. Chỉ vỏn vẹn 1 câu ""<lefthandside> is a variable or an element of an array"". Nên mỗi người 1 ý. Theo cái bảng [expr,...expr] và expr thì gọi const,... nên cái arrayElem theo mình là ko null được. Mình làm là thế. Còn ý thầy thì sao thì chỉ có thầy biết thôi. Hy vọng thầy đừng ra testcase trong trường hợp đó. ^^"
Sieutoc,1,11/6/2011,Re:Testcase cho stage 2,"Mình làm theo trường hợp truy xuất mãng rỗng dc vì trong EleExprPT thì exprs: List[ExprPT] có thể null dc. Và các phần tử trong List[ExprPT] thì không thể null dc, nhưng mà List[ExprPT] thì có thể null dc."
abc,1,11/1/2011,Re:Testcase cho stage 2,"Test 11 ở chỗ procedure init(x:array[5] of integer); begin var i:integer; //block variable i:=0; x[i]:=a[i]; // a is global var. end; mình nghĩ phải ra là [proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0), assign(ele(x,[i]),ele(a,[i])) ])] còn của bạn ra là proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0), assign(ele(x,[call(i,[])]),ele(a,[call(i,[])])) ]) bạn xem lại thử"
vanhoa,1,11/1/2011,Testcase cho stage 2,Ok thx bạn :) Mình nhỡ cho opt vào cái dấu ngoặc nên var thành call hết :D mình update ở link cũ rồi.
cong thanh,1,11/1/2011,Re:Testcase cho stage 2,ý mình là v4:=1--2-----4; bạn kêu nó hiểu là (1-(-2))-(-(-(-(-4)))) (-4) theo mình nghĩ phải hiểu là bnot(4) chứ trong đáp án thì là sub(4)
vanhoa,1,11/1/2011,Testcase cho stage 2,- là sub đó bạn
Long Nguyễn,1,11/1/2011,Testcase cho stage 2,"@vanhoa: test nào có lỗi đều có hết đó bạn, ví dụ test 14 hay 15. còn cái - 1 ngôi là bnot, 2 ngôi mới là sub."
nguyen dung,1,11/1/2011,Re:Testcase cho stage 2,Hơ vậy rốt cuộc mình có phải parse array constant không vậy? Thầy xác nhận chỗ này dùm tụi em với
tuong vo,1,11/2/2011,Re:Testcase cho stage 2,
walk alone,1,11/2/2011,Re:Testcase cho stage 2,"cho mình hỏi xíu, khi truy cập phần tử mảng thì cái a[] , trong [] có thể có nhiều phần tử và ngăn cách bởi dấu , ah :-?"
Sieutoc,1,11/2/2011,Re:Testcase cho stage 2,"Các bạn ơi cho mình hỏi input: const g = true; thì kết quả là: const(g,true) hay const(g, ' true ' ) Cảm ơn"
Tran Quoc Anh,1,11/2/2011,Re:Testcase cho stage 2,"Mình thấy vanhoa làm cái minus là sub đúng rồi, nếu các bạn xem kỹ sẽ thấy khai bao sub có 2 constructor 1 cái 2 ngôi, 1 cái 1 ngôi cho minus"
Tran Quoc Anh,1,11/2/2011,Re:Testcase cho stage 2,"Mai Hoa Đạo  wrote: Các bạn ơi cho mình hỏi input: const g = true; thì kết quả là: const(g,true) hay const(g, ' true ' ) Cảm ơn Theo test case của thầy thì là const(g,true)"
Sieutoc,1,11/2/2011,Re:Testcase cho stage 2,"Tran Quoc Anh wrote: Mai Hoa Đạo  wrote: Các bạn ơi cho mình hỏi input: const g = true; thì kết quả là: const(g,true) hay const(g, ' true ' ) Cảm ơn Theo test case của thầy thì là const(g,true) Cam on ban"
Thanh Pham Minh,1,11/2/2011,Re:Testcase cho stage 2,"// hỏi nhầm, đã xóa"
cong thanh,1,11/3/2011,Re:Testcase cho stage 2,"bước này k có kiểm tra kiểu nên a[1,true] vẫn đc nhận"
Vu Dang,1,11/3/2011,Re:Testcase cho stage 2,"cho minh hoi test nay ket qua the nao? procedure child2(a,b,c: integer); begin end; ket qua cua minh vay : [proc(child2,[par( abc ,int)],[])] dung khong? anh Hưng cho em hỏi cái này luôn. khai bao 1 hàm trong đặc tả có nói The function declaration begins with a function keyword, then the function name, an opening parenthesis („(„), a semicolon-separated parameter list, a closing parenthesis („)‟), a colon (:), a return type, a semi-colon and the body of the function . A function declaration is terminated by a semi-colon (;). vậy phần khai báo function bắt buộc phải có body function không? nếu có ví dụ thế này : function area(a:real;b:real;c:real):real; thì parser thành công không?"
FirstName LastName,1,11/3/2011,Re:Testcase cho stage 2,"Mình nghĩ là không, phần body là bắt buộc"
Nguyen Vo,1,11/3/2011,Re:Testcase cho stage 2,các hàm built-in bây giờ code sao đây các bạn. ai làm rồi thì gợi ý chỗ này chút xíu. thanks.
Thanh Pham Minh,1,11/3/2011,Re:Testcase cho stage 2,"Nếu đọc kỹ đặc tả sẽ thấy arrayLiteral chỉ yêu cầu là có các phần tử của chính nó cùng kiểu (integer, real, boolean hoặc array) chứ không yêu cầu xét một cách đệ quy . Nghĩa là: const b = [true;false];[1;2;3];[1;2;3;4];[[1];[2; 3]]]; sẽ parse thành công vì đối với array mẹ (array ngoài cùng) các phần tử của chính nó có cùng kiểu array (array luôn là array không cần phân biệt số chiều, kiểu, mức độ lồng nhau ). Tương tự, array con thứ nhất, thứ hai, thứ ba lần lượt có các phần tử cùng kiểu boolean, integer, integer. array con thứ tư có các phần tử là các array. Nhưng: const c = [1;2;[3;4]]; sẽ không parse thành công vì có phần tử thứ nhất và thứ hai kiểu integer nhưng phần tử thứ ba có kiểu array. Tương tự: const d = [true;1]; cũng không parse thành công. Có gì sai thầy và các bạn sửa giúp"
Linh Nguyen Thanh,1,11/3/2011,Re:Testcase cho stage 2,"giai đoạn này không cần kiểu tra kiểu đâu , ông ạ. 2 VD ông cho không có cái nào parse thành công cả phần tử của hằng mảng không có kiểu string đâu. The elements may be integer, real, boolean or array constant."
Thanh Pham Minh,1,11/3/2011,Re:Testcase cho stage 2,"Ờ, thank ông đã nhắc. Nhưng nếu muốn kiểm tra ở mức độ tui đã nói thì cũng làm được mà :) Chưa có thống nhất! Phần arrayLiteral thì nói phần tử của mảng có thể là array, không thể là string. Nhưng phần arrayType thì ngược lại: không thể declare một array có phần tử là array vì sau ""of"" chỉ có thể là primitive type. Primitive type có bao gồm string nên trong phần này array có thể có kiểu phần tử là string. Dù sao đây cũng là Crazy Language nên.. thôi :))"
thinh van,1,11/3/2011,Re:Testcase cho stage 2,"sax, đúng là Crazy:))"
Tran Quoc Anh,1,11/4/2011,Re:Testcase cho stage 2,"quang minh dinh wrote: cho minh hoi test nay ket qua the nao? procedure child2(a,b,c: integer); begin end; ket qua cua minh vay : [proc(child2,[par( abc ,int)],[])] dung khong? Mình ra kết quả thế này [proc(child2,[par(a,int),par(b,int),par(c,int)],[])] mình thấy vậy mới đúng đó, giống như khai báo biến var a,b,c : real; thì cũng ra từng cái một"
Phúc Trí,1,11/4/2011,Re:Testcase cho stage 2,trường hợp này có thành công ko thế function afunc( ; ):real; begin end; và function fun(x:real; :real):real; begin end;
Long Nguyễn,1,11/4/2011,Testcase cho stage 2,line 1:17: unexpected token: ; và line 1:22: unexpected token: :
Sieutoc,1,11/6/2011,Re:Testcase cho stage 2,Cho mình hỏi là xuất ra lỗi EOF hay <eof> vậy ? Cảm ơn.
Forever Alone,1,11/6/2011,Re:Testcase cho stage 2,Mai Hoa Đạo  wrote: Cho mình hỏi là xuất ra lỗi EOF hay vậy ? Cảm ơn. <eof>
thanhnghi_py,1,11/7/2011,Re:Testcase cho stage 2,"Cho mình hỏi if a then s(); else s(); câu lệnh sau then có dấu chấm phẩy à còn cái này loop 1 do begin a:=1; b:=2; break; end sau end lại không có chấm phẩy, như vậy có đúng không"
Huỳnh Tiến Tài,1,11/7/2011,Re:Testcase cho stage 2,"Đã được trả lời trường hợp a[] := 3; Ko parse được, các bạn update code! Vậy là chắc hết thắc mắc cái Ass này rồi!"
vanhoa,1,11/7/2011,Testcase cho stage 2,Mình cập nhật result ở đầu bài rồi đó.
Huỳnh Tiến Tài,1,11/7/2011,Re:Testcase cho stage 2,"Hòa chưa cập nhật lại cái string kìa! parse ra để nguyên, không bỏ đi 2 dấu ' ' ở đầu và cuối luôn!"
vanhoa,1,11/7/2011,Re:Testcase cho stage 2,"ah lúc nãy mình chưa rename, bạn tải lại đi:)"
BKIT 09,1,11/7/2011,Re:Testcase cho stage 2,"nhan nguyen van wrote: procedure main(); begin a := [1;true]; end; vậy nếu có testcase như vậy thì kết quả là gì? line 3:10: unexpected token: true hay[proc(main,[],[assign(a,[1;true])])] Mình ra : line 3:9: unexpected token: true"
BKIT 09,1,11/7/2011,Re:Testcase cho stage 2,"Doan Tuan Sang wrote: với lại test này ra gì vậy? procedure init(x:array[5] of integer); begin x[i]:=a[i]; end; minh ra [proc(init,[par(x,arr([5],int))],[assign(ele(x,[i]),ele(a,[i]))])] hok bit dung hok Me 2 [proc(init,[par(x,arr([5],int))],[assign(ele(x,[i]),ele(a,[i]))])]"
Sieutoc,1,11/7/2011,Re:Testcase cho stage 2,"procedure main(); begin a[]:=0; end; Testcase 31. Hòa ơi bạn làm theo trường hợp ko truy xuất mãng rỗng dc hả. Trường hợp này mình parse dc vì mình thấy trong EleExprPT cho phép List[ExprPT] null. Và mình xem như a[] là a vậy. Result của mình: [proc(main,[],[assign(a,0)])] Trong notice thầy chỉ nói ra trường hợp ko dc khai báo mảng rỗng thôi. var a: array [] of real; => line 1:15: unexpected token: ]"
vanhoa,1,11/7/2011,Testcase cho stage 2,"Đúng là thầy có cho phép cái list kia là null, nhưng mình nghĩ vậy thì nó lại ko có ý nghĩa gì cả (a[] và a là một thì tại sao lại phải dùng a[]?), nên hoặc là test của thầy sẽ ko có trường hợp này hoặc là thầy sẽ ghi rõ ràng trong đặc tả ngôn ngữ. File đặc tả khá đơn giản, nên mình chỉ nên đơn giản làm theo thôi. Còn nếu bạn muốn có cơ sở, mình nghĩ câu đặc tả này cũng đủ rồi: Brackets (array subscript to access array element ) a là array, a[...] là array element, vậy thì a[] là một array element thì cũng là bản thân array luôn?"
thinh van,1,11/7/2011,Re:Testcase cho stage 2,"tóm lại cho a[]:=... hok mí ông, chnas quá đi"
Phúc Trí,1,12/21/2011,Re:Biểu thức hằng??,"Thầy cho em hỏi lại về vấnđề 4. trong phần Notice thầyđã nói là vẫn check các câu lệnh nằm phía sau vòng lặpwhile. Nhưngý em muốn hỏi là trongđiều kiện luôn luônđúng thì chương trình chỉ có 1 luồng thực thi làđi vàowhile rồi ra khỏiwhile và tiếp phần còn lại, vậy thì functionđã có return. Tại sao bắt buột ngoàiwhile phải có lệnh return nữa? ( hơi mâu thuẫn với trường hợpif(true) else thì chỉ cần xét nhánhif). Em cámơn thầy."
Nhan Nguyen Van,1,12/22/2011,Re:Biểu thức hằng??,"Const array có tính không? Nếu tính thì chỉ số của Array được đánh bắt đầu là 0 hay là 1 ? function main(): real; begin const a = [1;2;3]; const b = [[1;0];[4;3]]; var c : real; if(a[1] <> b [1,1]) then c:= 0; return 0; end; Nếu đánh là 1 thì ra thế này a[1] = 1 b[1,1] = 1 =>if(a[1] <> b [1,1]) then c:= 0;   =if(false) then c:= 0; => None Còn đánh là 0 thì a[1] = 2 b[1,1] = 3 Function Not Return: main"
_Tieu_ Doan_Du,1,12/22/2011,Biểu thức hằng??,Nếu đến giờ chưa có khẳng định của TA thì chắc là không có case nào dùng => yên tâm
Ngan Tuyet,1,12/22/2011,Re:Biểu thức hằng??,"H.T.P (^_^)  wrote: Thầy cho em hỏi lại về vấnđề 4. trong phần Notice thầyđã nói là vẫn check các câu lệnh nằm phía sau vòng lặpwhile. Nhưngý em muốn hỏi là trongđiều kiện luôn luônđúng thì chương trình chỉ có 1 luồng thực thi làđi vàowhile rồi ra khỏiwhile và tiếp phần còn lại, vậy thì functionđã có return. Tại sao bắt buột ngoàiwhile phải có lệnh return nữa? ( hơi mâu thuẫn với trường hợpif(true) else thì chỉ cần xét nhánhif). Em cámơn thầy. Em đồng ý với bạn này! Theo thầy trả lời trong topic thì while(unlnown) = while(false) và ko tính cái assign hay return nằm trong while này. Vậy bây h mà while(true) ko tính return lun thì làm cái eval condition trong while làm gì nữa ạ! Mong thầy giải đáp!"
Minh Nguyen,1,12/22/2011,Biểu thức hằng??,"thực là mâu thuẫn, nếu đã tính eval thì while(true) phải cho return chứ nhỉ ! Làm quá trời rồi thầy nói while(true) cũng không tính return @_@ Mong thầy sớm trả lời để tụi em còn sửa chữa kịp thời, mai đã là deadline rồi thầy ơi !!!!!!!"
Minh Nguyen,1,12/22/2011,Biểu thức hằng??,"Câu hỏi: Case i: 3 trường hợp: While(true) {break; return .. ;} While(false){return;} While(unknown) {return;} TH nào là báo lỗi function not return; Trả lời: Phải có đủ thân hàm (trước sau while có return nào khác không) mới trả lời được câu hỏi này. Với giả sử không có lệnh return nào khác nữa thì: cả 3 trường hợp đều báo lỗi. To mọi người: Theo mình hiểu là while (true) vẫn tính return nhưng cái while (true) {break; return;..} trên vẫn báo lỗi do nó đụng break và out , chưa đụng đến return"
Phúc Trí,1,12/22/2011,Re:Biểu thức hằng??,Mình nghĩ vậy là hợp lý rồiđó.
Huỳnh Tiến Tài,1,12/22/2011,Biểu thức hằng??,"Hợp lí??? Thế bạn có thấy cái test case đầu topic của bạn không. While (true) rõ ràng, và câu trả lời là vẫn phải xét sau đó có return hay k???"
Vu Dang,1,11/4/2011,Re:Testcase cho stage 2,"xin lỗi các bạn vì đã spam. hôm nay tiết bài tập CNPM tiết 9, 10 mình có để quên 1 con chuột wiless màu xanh trên bàn tại phòng máy A5! bạn nào có giữ nó cho mình xin lại! SDT: 01695305025 mình cảm ơn rất nhiều!"
Nguyen Vo,1,11/4/2011,Re:Testcase cho stage 2,cac ban minh hoi: var :real; se ra ket qua la: [] hay la line 1:5: unexpected token: : thanks truoc.
Vu Dang,1,11/4/2011,Re:Testcase cho stage 2,chicken _ wrote: cac ban minh hoi: var :real; se ra ket qua la: [] hay la line 1:5: unexpected token: : thanks truoc. kết quả của mình: line 1:5: unexpected token: :
Huỳnh Tiến Tài,1,11/4/2011,Re:Testcase cho stage 2,"cái này có thể dùng thủ thuật đơn giản mà bạn, nếu bạn muốn a+ thì là: a ~ rep("";"" ~>a) ^^ { case a ~ lst ... case a ~ Nil ...}"
Thanh Pham Minh,1,11/4/2011,Re:Testcase cho stage 2,@Scala ^^: rep1sep
Tan Phat,1,11/4/2011,Testcase cho stage 2,"input (test25 của vanhoa): procedure main(); begin while 1 do begin end break; end; Test trên output ra: [proc(main,[],[while(1,[]),break(null)])] hay là output này: line 4:2: unexpected token: `break'"
nguyen dung,1,11/4/2011,Testcase cho stage 2,"@Tan Phat: thầy Tân nói là không kt phạm vi break và continue @Scala^^ : cũng thắc mắc giống bạn này, mình thấy classEleExprPT và ArrayLiteralPTcó xử lý chỗ null, nên mình nghĩ là parse thành công. VD: function a(): real; begin const a =[]; // array rong a:=[]; a[]:=b[]; //truy cap dia chi rong end; Output:[func(a,[],float,[const(a,[]),assign(a,[]),assign(a,b)])] Mấy bạn xem chỗ này thử he P/S: VD:var a: array [7,0,1] of real; Output :line 1:17: unexpected token: 0 Ra vậy phải không mọi người?"
_Trung_Than_Thong,1,11/4/2011,Re:Testcase cho stage 2,Cho mình hỏi test case này các bạn ra gì (thấy nó lại báo lỗi khác với cái test mẫu trong đặc tả): var a:integer; procedure proc(); begin s; end;
Nguyen Vo,1,11/4/2011,Re:Testcase cho stage 2,line 4:2: unexpected token: ;
Phúc Trí,1,11/4/2011,Testcase cho stage 2,"nguyen dung wrote: @Tan Phat: thầy Tân nói là không kt phạm vi break và continue @Scala^^ : cũng thắc mắc giống bạn này, mình thấy classEleExprPT và ArrayLiteralPTcó xử lý chỗ null, nên mình nghĩ là parse thành công. VD: function a(): real; begin const a =[]; // array rong a:=[]; a[]:=b[]; //truy cap dia chi rong end; Output:[func(a,[],float,[const(a,[]),assign(a,[]),assign(a,b)])] Mấy bạn xem chỗ này thử he P/S: VD:var a: array [7,0,1] of real; Output :line 1:17: unexpected token: 0 Ra vậy phải không mọi người? sao const array rỗng mà lại parse được nhỉ. còn cái elem có định dạng <id>[<expr>,…,<expr>]. nên mình nghĩ nó cũng ko rống như a[] dược đâu. Mọi người cho ý kiến??"
nguyen dung,1,11/4/2011,Re:Testcase cho stage 2,"class EleExprPT (val id: IdPT, val exprs : List[ExprPT]) extends LefHandSidePT { ... if ( exprs != null) ... else ... } class ArrayLiteralPT (val ele : List[LiteralPT]) extends LiteralPT { ... (if (! ele .isEmpty) (ele.head.toString /: ele.tail)(_ + "";"" + _) else """") + ""]"" } Nếu không rỗng sao thầy code thêm else ??"
thanhnghi_py,1,12/21/2011,có được dùng biến var thay cho val ??,"Trong bài tập lớn này mình có được khai báo biến theo kiểu var không (var x: Boolean) ? Bởi vì mình cần cùng một biến mà trong lúc chạy phải gán lại giá trị, không thể khai báo val được"
V For,1,12/21/2011,có được dùng biến var thay cho val ??,"Trần Gia Lạc wrote: Trong bài tập lớn này mình có được khai báo biến theo kiểu var không (var x: Boolean) ? Bởi vì mình cần cùng một biến mà trong lúc chạy phải gán lại giá trị, không thể khai báo val được Duoc ! Minh cung lam vay."
Huỳnh Tiến Tài,1,12/21/2011,Re:có được dùng biến var thay cho val ??,"hix, quan trọng là thầy có cho không chứ? A Hùng có thể trả lời cho tụi em biết được không?"
V For,1,12/21/2011,Re:có được dùng biến var thay cho val ??,"huynh tien tai wrote: hix, quan trọng là thầy có cho không chứ? A Hùng có thể trả lời cho tụi em biết được không? code là do mình, thích làm j thì làm. Làm j có chuyện k cho"
Huỳnh Tiến Tài,1,12/21/2011,Re:có được dùng biến var thay cho val ??,Bạn nghĩ như vậy thì được rồi. Và nếu làm như bạn cũng sẽ đỡ. Thế còn khái niệm của thầy là "phải dùng scala như lập trình hàm" thì sao? Ai dám chắc là thầy sẽ k check điều đó. Cũng như CTDL linked list năm ngoái k cho xài array thôi!
Phúc Trí,1,12/21/2011,Re:có được dùng biến var thay cho val ??,hồi đó đề có ghi là cấm. còn lần này đề không cấm thì cứ xài thoải mái. Lo xa.
Bernkastel 奇跡の魔女,1,12/21/2011,Re:có được dùng biến var thay cho val ??,"Mình thấy cái gì trong spec và trong notice thầy ko cấm thì cứ làm, miễn sao tiện là được rồi ^^"
Crazy Boy,1,12/22/2011,có được dùng biến var thay cho val ??,Ối....thầy giải đáp hộ tụi em..... Em hiện đang dùng biến này.... Mong thầy phản hồi xớm để tụi em còn tìm cách sử lý khác......mất công bj mất điểm oan T_T
tuong vo,1,12/22/2011,Re:có được dùng biến var thay cho val ??,mong thầy sớm giải đáp .
tuong vo,1,12/22/2011,Re:có được dùng biến var thay cho val ??,mong thầy giải đáp sớm cho tụi em.
Crazy Boy,1,12/22/2011,có được dùng biến var thay cho val ??,Mong thầy sớm giải đáp....T__T
Phúc Trí,1,12/22/2011,Re:có được dùng biến var thay cho val ??,"spec không cấm, bạn spam kiểuđó thầy không nói j tức là không saođó.đừng spam nữa bạn ah. xài var vô tưđi"
Cong Cuong Pham,1,12/22/2011,có được dùng biến var thay cho val ??,không muốn var thì bạn có thể import util.DynamicVariable
Tan Phat,1,11/5/2011,Re:Testcase cho stage 2,"nguyen dung wrote: class EleExprPT (val id: IdPT, val exprs : List[ExprPT]) extends LefHandSidePT { ... if ( exprs != null) ... else ... } class ArrayLiteralPT (val ele : List[LiteralPT]) extends LiteralPT { ... (if (! ele .isEmpty) (ele.head.toString /: ele.tail)(_ + "";"" + _) else """") + ""]"" } Nếu không rỗng sao thầy code thêm else ?? ArrayLiteral thì trong file đặc tả ko chấp nhận ArrayLiteral rỗng (An array constant is a semicolon-separated list of elements enclosed in left and right square brackets. The list may NOT be empty.) Nhưng trong file PT thì lại chấp nhận const array rỗng. Ko biết ntn mới đúng? còn EleExprPT khi exprs=null thì nó trả về id mà, nên mình nghĩ a[ ]:=<expr> thì parser trả về giống như a:=<expr>; .Mọi người cho ý kiến với."
nguyen dung,1,11/5/2011,Re:Testcase cho stage 2,"1) trường hợp var x : array[ 0 ] of integer cũng sẽ parse thành công phải ko ạ? Parse thành công ""The integer constant represents the size of the corresponding dimension and it must be a positive number, i.e. number greater than 0"" Chỗ này cũng mâu thuẫn với đề nè cái demision đề nói phải > 0 mà này parse thành công. Nguồn: https://elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3407.page"
Phúc Trí,1,12/22/2011,Tổng hợp lại các trường hợp của bonus,"Mình xin tổng hợp lại tất cả các trường hợp như sau. Nếu có j sai thì thầy và các bạn nóiđể mình sửa lại. Nếu không thì chắc là nóđúng. 1.While(true) coi nó như là 1 block bình thường, mọi câu lện gán, return trong nó vẫn được tính nếu thỏađiều kiện: -assign phải trước break,continue,return ( vì return tươngđương break - trong notice thầy đã nói); -return phải nằm trước break,continue. 2.While(false) vàwhile(unknown) Coi như ko cówhile, mọi câu lệnhassign và return trong bodyđều khôngđược tính (không hợp lệ) . 3. if (true) các câu lệnh gán và return hợp lệở nhánh if đềuđược tính. 4. if(false) Coi như ko có - không xem xét. 5.if (unknown) Coi như không có 6.if(true) ... else coi như ko có else vàáp dụng như trường hợp 3. 7,if (false) ... else ... Coi như không có nhánhif vàáp dụng trượng hợp 3. 8.if (unknown) else ... Phải có lênh gán,return hợp lệở cả 2 nhánh. các trường hợp nói trên chi tính cho case h,i. mọi lỗi khác vẫn test bình thường."
Huỳnh Tiến Tài,1,12/22/2011,Re:Tổng hợp lại các trường hợp của bonus,"1/ Có vẻ như bạn đúng hết rồi 2/ Em muốn hỏi thầy về câu trả lời trong notice vì em vẫn chưa hiểu rõ Câu hỏi: 1. Truyền tham số , return với kiểu string có chấp nhận. Có áp dụng LHS:=RHS (LHS khác string và array type) Trả lời: Theo đặc tả ngôn ngữ thì chấp nhận. Nhưng ở assignment này đã thu hẹp lại như quy định ở 3d . Vì vậy, các em không cần làm Em không hiểu ""không cần làm"" ở đây là như thế nào vậy ạ? Tức là Truyền tham số , return có chấp nhận ki ểu string vàarr ay hay kh ông?"
Ngan Tuyet,1,12/22/2011,Re:Tổng hợp lại các trường hợp của bonus,Đồng ý với bạn H.T.P (^_^) Bổ sung thêm TH loop(n) n >0 thì tương đương while(true) n <= 0 thì tương đương while(false) và while(unknown)
_Trung_Than_Thong,1,12/22/2011,Tổng hợp lại các trường hợp của bonus,H.T.P (^_^)  wrote: Mình xin tổng hợp lại tất cả các trường hợp như sau. Nếu có j sai thì thầy và các bạn nóiđể mình sửa lại. Nếu không thì chắc là nóđúng. 5.if (unknown) Coi như không có coi như không có là sao ban? unknown là không cần kiểm tra các câu lệnh sau nó ak (đag nói ktra bonus)? vd: function foo():real; begin var x:integer; var y:integer; y:=3; if(y>0) then x:=x+1; //y>0 là unknown vậy có kiểm tra cái x ở sau là not defined không? end;
Phúc Trí,1,12/22/2011,Re:Tổng hợp lại các trường hợp của bonus,Coi nhu khong co tuc la moi cau lenh assign va return trong block do deu coi nhu khong có (có cũng không tính). :D
LAV,1,12/22/2011,4 Testcase!,1/ procedure main(); begin const b = 3; b[1] := 6; end; cái này ra cái gì vậy bạn ? ---------------------------------------------- 2/ procedure main(); begin const b = [3; 4; 5]; b[1] := 6; end; còn cái này? -------------------------------------------- 3/procedure c(); begin var a : array[1] of integer; var b : integer; a := 3; end; ------------------------------------------- 4/procedure c(); begin var a : array[1] of integer; var b : integer; b[1] := 3; //a := 3; end;
Nha Nguyen,1,12/22/2011,Re:4 Testcase!,"test 1,2 : Cannot Assign To Constant: assign(ele(b,[1]),6)"
LAV,1,12/22/2011,Re:4 Testcase!,"Nguyen Nha wrote: test 1 : Type Mismatch In Expression: ele(b,[1]) mình nghĩ cái này ra cannot assign...... chứ !!!"
Nha Nguyen,1,12/22/2011,Re:4 Testcase!,thanks bạn mình đã fix !
V For,1,12/22/2011,Re:4 Testcase!,"1/Type Mismatch In Expression: ele(b,[1]) 2/Cannot Assign To Constant: assign(ele(b,[1]),6) 3/Type Mismatch In Statement: assign(a,3) 4/Type Mismatch In Expression: ele(b,[1])"
LAV,1,12/22/2011,Re:4 Testcase!,"tran ngoc duc wrote: 1/Type Mismatch In Expression: ele(b,[1]) 2/Cannot Assign To Constant: assign(ele(b,[1]),6) 3/Type Mismatch In Statement: assign(a,3) 4/Type Mismatch In Expression: ele(b,[1]) cái 1/ mình nghĩ cannot assign ......... chứ"
Bruce Wayne,1,12/22/2011,Re:4 Testcase!,"tran ngoc duc wrote: 1/Type Mismatch In Expression: ele(b,[1]) 2/Cannot Assign To Constant: assign(ele(b,[1]),6) 3/Type Mismatch In Statement: assign(a,3) 4/Type Mismatch In Expression: ele(b,[1]) Giống bạn này!"
Phúc Trí,1,12/22/2011,Re:4 Testcase!,cais test 1 tùy theo kiểm tra cái nào trước. Nếu KT nó có phải constant hay ko trước thì ra connotassign. Nếu KT type của nó trước thì ra type mismatchexpr. Thầyđã nói test chỉ có 1 lỗi.
V For,1,12/22/2011,Re:4 Testcase!,"LAV  wrote: tran ngoc duc wrote: 1/Type Mismatch In Expression: ele(b,[1]) 2/Cannot Assign To Constant: assign(ele(b,[1]),6) 3/Type Mismatch In Statement: assign(a,3) 4/Type Mismatch In Expression: ele(b,[1]) cái 1/ mình nghĩ cannot assign ......... chứ Bắt lỗi đầu tiên tìm được Vậy b[] trong khi b là const integer là sai rồi. system.exit. K check tiếp phép gán :D"
facebook.com,1,12/23/2011,redeclared,"Cho mình hỏi 1 câu này, vội quá: var x: integer; procedure main(); begin var x: real; var y: integer; var y: real; var x: integer; end; kết quả là Redeclared x hay y vậy? Vì code mẫu của thầy ra là redeclared x. Chúc mọi người may mắn..."
V For,1,12/23/2011,redeclared,"Guest User wrote: Van Persie wrote: Cho mình hỏi 1 câu này, vội quá: var x: integer; procedure main(); begin var x: real; var y: integer; var y: real; var x: integer; end; kết quả là Redeclared x hay y vậy? Vì code mẫu của thầy ra là redeclared x. Chúc mọi người may mắn... bạn yên tâm! thứ nhất: ko có cái nào 2 lỗi trong 1 chương trình thứ 2: sẽ báo lỗi Redeclared x bởi vì code hàm checkUnique của thầy ưu tiên gặp biến nào đầu tiên là báo lỗi! bạn gặp x đầu tiên nên báo lỗi x thôi. vì vậy ko cần phải quan tâm báo lỗi nào đâu đúng là a Hung đã nói k có 2 lỗi trong 1 ctrinh. Nhưng với chương trình này, lỗi đầu tiên là y: var x: integer;  --------> toàn cục procedure main(); begin var x: real;  -------> cục bộ, được khai báo mới, k lỗi var y: integer; --------> k lỗi var y: real;  ------------> ERROR var x: integer; end;"
M.U.,1,12/21/2011,Gán String thế này sẽ output thế nào?,procedure main(); begin var a: string; const strConst='hello '' world'; a := '2' + strConst; end; lỗi sẽ là string addition hay là assigment vậy mọi người? Mình đoán là string addition. Cám ơn mọi người.
M.U.,1,12/21/2011,Re:Gán String thế này sẽ output thế nào?,"Kid  wrote: Type Mismatch In Statement: assign(a,add(""'2'"",strConst)) bản chất a la string thi khong duoc la LHS roi`, báo lỗi liền. nên k cần xét RHS. cám ơn bạn nhìu."
V For,1,12/22/2011,Gán String thế này sẽ output thế nào?,"Vo Thanh Hung wrote: M.U.  wrote: procedure main(); begin var a: string; const strConst='hello '' world'; a := '2' + strConst; end; lỗi sẽ là string addition hay là assigment vậy mọi người? Mình đoán là string addition. Cám ơn mọi người. Tại mỗi test chỉ có 1 lỗi duy nhất, không có trường hợp nhiều lỗi đồng thời 1 test chi co duy nhat 1 loi hay la 1 dòng lệnh chỉ co duy nhất 1 lỗi vậy a Hung. Nếu 1 test chỉ có 1 lỗi thì cần j đặc tả chổ bắt lỗi đầu tiên, sau đó dừng chương trình :D"
V For,1,12/23/2011,Re:Gán String thế này sẽ output thế nào?,Vo Thanh Hung wrote: Mỗi test có duy nhất 1 lỗi. Em cảm ơn! p/s: Nếu cái này được ghi rỏ trong đặc tả thì thời gian code ass2 này sẽ giảm xuống đáng kể :D
M.U.,1,12/23/2011,Cho mình hỏi cách test trên Cygwin,"Mình làm ass2 này là dựa vào cái Intermediate, nhưng khi test trên cygwin thì hok có box console để mà nhập input rùi Ctrl Z, do đó input sẽ nhập vào đâu. Mình cám ơn."
Huỳnh Tiến Tài,1,12/22/2011,Thắc mắc cấu trúc test case ass2,"Thưa thầy, không biết thầy có thể cho tụi em biết cấu trúc test case của assignment 2 như thế nào không ạ??? Để em có thể biết được case h và i chiếm bao nhiêu phần trăm mà nộp bài cho hợp lí chứ vì thêm case h và i mà sửa cấu trúc tùm lum hết(gần như cả bài), không biết mấy case cơ bản có còn đúng nữa không?"
Đỗ Sỹ Hưng,1,12/23/2011,Giá trị của biến toàn cục,"Nếu biến x là biến toàn cục thì x có được xem là được gán giá trị ban đầu hay x không có giá trị ?? vd: //1 var x: real; procedure main(); begin writeReal(x); end; //2 var x: real; procedure main(); begin x := 1.0; writeReal(x); end; Trường hợp 1: 1 Not Defined Before Used, 2 None Trường hợp 2: 1 None, 2 None"
M.U.,1,12/23/2011,Re:Cho mình hỏi cách test trên Cygwin,ai giúp mình với :((
V For,1,12/23/2011,Re:Testcase,"O_$  wrote: Mong vanhoa trở lại để giúp mọi người, sự hiện diện của bạn là niềm vui cho tất cả. P/S: nếu thế giới phản bội vanhoa thì chúng em sẽ phản bội lại thế giới Cần phải thế k bạn =)) =))"
Sieutoc,1,12/20/2011,Re:Testcase,"Kid  wrote: Mai Hoa Đạo  wrote: Test 27: mình nghĩ (1<1.0) vẫn so sánh được mà. Luật cùng kiểu chỉ có tác dụng trong phép gán thôi mà, sao lại báo lỗi nhỉ ? integer và real đúng là dc phép sử dụng phép < , tuy nhiên chúng phải cùng kiểu. ví dụ 1<2 hoặc 1.2< 2.1 However, for + - * /, their operands can be in mixed types: integer and real. ( trích đặc tả ass1) Cảm ơn bạn nhưng sau khi tui xem lại Crazy spec thì phát hiện ra rằng không có sự so sánh bằng ""="" cho kiểu real. Nghĩa là kiểu real sẽ không bao giờ được đem đi so sánh ""=""."
Nguyen Vo,1,12/20/2011,Re:Testcase,<None>
Nguyen Vo,1,12/20/2011,Re:Testcase,"Thanh Pham Minh wrote: Test này các bạn ra None hay Type Mismatch In Expression: array([array([array([1.0,2.0])]),array([array([1,2])])]) function foo(param: array[2,1,2] of real): integer; begin return 0; end; procedure main(); begin var a: real; a:= foo([[[1.0; 2.0]]; [[1; 2]]]); end; Test này ra None hay Type Mismatch In Expression: ele(a,[1000]) procedure main(); begin var a: array[2] of integer; a[1000]:= 1000; end; Mình nghĩ cả hai cái đều ra None chứ"
Nguyen Vo,1,12/20/2011,Re:Testcase,Có ai giải thích giúm được ko. mình nghĩ phải ép kiểu sang real chứ. Mảng integer ấy.
Thanh Pham Minh,1,12/20/2011,Re:Testcase,@chicken _: Test này bạn ra gì: const b = [[[1.0; 2.0]]; [[1; 2]]];
Nguyen Vo,1,12/20/2011,Re:Testcase,None. Nhưng sửa lại rồi. hic.
Phúc Trí,1,12/20/2011,Re:Testcase,"test 65: const bTrue=true; function main(b: boolean): boolean; begin var x,y: real; while b do begin x:=7; end x:=x; return false; end; ra None chứ trong vòngwhileđã có lệnh gán rồi chứ.đừng nóiwhile(true) thì lúcđó phép gán mớiđược tính????"
nguyen dung,1,12/20/2011,Re:Testcase,Test #84 varx:integer; proceduremain(); begin while(1>x)do begin varz:real; begin break; end z:=1; z:=z;//(1) end end; z nằm sau break vậy phép gán z:=1; có tính không ? Mình raNot Defined Before Used: z
Phúc Trí,1,12/20/2011,Re:Testcase,nguyen dung wrote: Test #84 varx:integer; proceduremain(); begin while(1>x)do begin varz:real; begin break; end z:=1; z:=z;//(1) end end; z nằm sau break vậy phép gán z:=1; có tính không ? Mình raNot Defined Before Used: z rađúng rồiđó bạn. giống mình :D
Phúc Trí,1,12/20/2011,Re:Testcase,"var x:integer; function a():real; begin var b:boolean; var c,s:real; b:=false; while (b) do if (b) then begin return 3; s:=3; end else s:=5; c:=s; end; test này ra j vậy?"
vanhoa,1,12/20/2011,Re:Testcase,nguyen dung wrote: Test #84 varx:integer; proceduremain(); begin while(1>x)do begin varz:real; begin break; end z:=1; z:=z;//(1) end end; z nằm sau break vậy phép gán z:=1; có tính không ? Mình raNot Defined Before Used: z Khôngcólỗibạn.
Peter,1,12/20/2011,Re:Testcase,nguyen dung wrote: Test #84 varx:integer; proceduremain(); begin while(1>x)do begin varz:real; begin break; end z:=1; z:=z;//(1) end end; z nằm sau break vậy phép gán z:=1; có tính không ? Mình raNot Defined Before Used: z Minh ra [None]
nguyen dung,1,12/20/2011,Re:Testcase,Mới sửa lại ra None
Phúc Trí,1,12/21/2011,Re:Testcase,varx:integer; proceduremain(); begin while(1>x)do begin varz:real; begin break; end z:=1; z:=z;//(1) end end; cái test này sao lại ra None nhỉ.sau lệnh Break rồi mà.
vanhoa,1,12/21/2011,Testcase,Mình vừa cập nhật lại các test short circuit.
nguyen dung,1,12/21/2011,Re:Testcase,Cái test 70 functionmain(x:boolean):real; begin if not(falseandx) thenreturn1; end; Chỗ đó -> if (true) then return 1; bình thường mà sao Hòa báo lỗi Function Not Return: main
M.U.,1,12/22/2011,Re:Testcase,proceduremain(); begin vara:boolean; a:=(1+2*3.4)=5.0; a:=1=2; a:=1.2=2.2; a:=1=2.2; a:=(1<2)and(2<3); a:=1<2<3; end; tại sao lại báo lỗi dòng này vậy a:=(1+2*3.4)=5.0; ??? Cám ơn
Nhất Tiếu nại Hà,1,12/22/2011,Re:Testcase,các bạn test này ntn: proceduref(a:real); begin varf:real; end; =>KQ?
_Tieu_ Doan_Du,1,12/18/2011,Testcase,"Test 27 sao lại có lõi ở phép gán nhỉ, toán tử so sánh dùng cho cả số thực và số nguyên mà."
Phúc Trí,1,12/22/2011,Re:Testcase,Nhất Tiếu nại Hà  wrote: các bạn test này ntn: proceduref(a:real); begin varf:real; end; =>KQ? Redeclared Variable: f
Nhất Tiếu nại Hà,1,12/22/2011,Re:Testcase,Guest User wrote: H.T.P (^_^)  wrote: Nhất Tiếu nại Hà  wrote: các bạn test này ntn: proceduref(a:real); begin varf:real; end; =>KQ? Redeclared Variable: f Mình thấy lỗi này ko đúng Redeclared Variable: f chưa có khai báo variable f so lại redeclared variable được. mình cũng giống bạn...nhưng hình như trong kai Procedure là f rooig bên trong nó ko đc khai báo đè đâu...:(
Phúc Trí,1,12/22/2011,Re:Testcase,function a():real; begin var x:real; var b : boolean; b:=true; while ( true ) do begin if(true) then return 9; x:=9; end x:=3;//1 cau lệnh gán này có được tính không x:=x; end; output ra j các bạn
Nhất Tiếu nại Hà,1,12/22/2011,Re:Testcase,H.T.P (^_^)  wrote: function a():real; begin var x:real; var b : boolean; b:=true; while ( true ) do begin if(true) then return 9; x:=9; end x:=3;//1 cau lệnh gán này có được tính không x:=x; end; output ra j các bạn theo minh la =>None(nếu bạn chưa làm bonnus)..:)
vanhoa,1,12/22/2011,Testcase,"Uh giờ các test mình không đúng nữa đâu, giờ mình cũng chán rồi, sẽ không sửa gì nữa, các bạn chỉ nên tham khảo các test ngoài bonus :)"
n0b0dy,1,12/23/2011,Testcase,"Hòa ơi , có nản cũng đừng xóa test case chứ :)"
Thanh Cao,1,12/23/2011,Re:Testcase,"Mong vanhoa trở lại để giúp mọi người, sự hiện diện của bạn là niềm vui cho tất cả. P/S: nếu thế giới phản bội vanhoa thì chúng em sẽ phản bội lại thế giới"
Nhan Nguyen Van,1,12/15/2011,Testcase,"vanhoa  wrote: Vẫn None bạn. đâu có đúng đâu? Ngoài câu lện if else, while, loop, block thì các câu lệnh còn lại vẫn phải tính là 1 đường thực thi chứ. vidu: function main(): real; begin var a: real; end; với function main(): real; begin if false return 0; var a: real; end; thì sao?"
_Tieu_ Doan_Du,1,12/18/2011,Testcase,"Case 16 làm mình nhớ đến một vấn đề trong phần Spec của Crazy Language. +, - ,* => integer if both operands are integers, otherwise real. Vậy thì -a (unary op) ở đây là kiểu real hay integer"
vanhoa,1,12/18/2011,Testcase,Mình vừa update lại một số test cũ. @TDD: -integer -> integer -real -> real
_Tieu_ Doan_Du,1,12/18/2011,Testcase,"vanhoa  wrote: Mình vừa update lại một số test cũ. @TDD: -integer -> integer -real -> real Đúng là bình thường là thế, nhưng trong đặc tả (file Spec của CrazyLanguage), phần mình quote trên đó, thì chỉ nói đến dấu trừ của phép trừ, còn dấu trừ kia thì không nói, và nếu đọc đúng cái đặc tả đó thì -integer -> real. À, Hòa bỏ case 41, 43, 44 phần tử của mảng không có kiểu String đâu."
vanhoa,1,12/18/2011,Testcase,"83 thì func được khai báo ở block trong của hàm, 76 thì không."
Vo Quoc Hieu,1,12/18/2011,Re:Testcase,"Bạn xem lại test 8 nha, sao kết quả mình ra: Cannot Assign to Constant: assign(y,7) không biết mình có hĩu sai chỗ nào hok bạn trả lời giúp mình."
Bruce Wayne,1,12/18/2011,Testcase,"Mình nghĩ là Type Mismatch In Expression: add(1,true) Nhân tiện cho mình hỏi thêm là mỗi vế của phép gán có thể là mảng ko, hay chỉ là kiểu nguyên thủy: boolean, integer, real. Tại vì trong đặc tả nói mình thấy không rõ lắm. For an assignment statement, the LHS can be in real, integer or boolean type ."
Bruce Wayne,1,12/18/2011,Testcase,"Vậy kiểu trả về của function ko thể là string phải ko, tại vì giá trị trả về của function được xem là một vế phép gán mà mỗi vế chỉ có thể là các kiểu: real, integer, boolean"
Phúc Trí,1,12/19/2011,Re:Testcase,Test 41: const arrConst=['hello '' world';'']; hằngarray làm j có kiêu String nhỉ. sai từ cái parse tree.
Phúc Trí,1,12/19/2011,Re:Testcase,Test #52 => None Phần KT Not Defined Before Usedđâu yêu cầu KT giá trị biếu thứcđiều kiệnđâu Hòa. chỉ cần có lệnh gán hợp lệở 2 nhánhif làđược rồi mà như Test 52
Phúc Trí,1,12/19/2011,Testcase,"Assignment2  wrote: Vậy kiểu trả về của function ko thể là string phải ko, tại vì giá trị trả về của function được xem là một vế phép gán mà mỗi vế chỉ có thể là các kiểu: real, integer, boolean đề ko nói Func ko thể trả về kiểu String thì cứ vậy mà làm,đừng quan tâm nó trả về để làm j."
vanhoa,1,12/19/2011,Testcase,Test 52 làm gì có 2 nhánh.
Phúc Trí,1,12/19/2011,Testcase,"vanhoa  wrote: Test 52 làm gì có 2 nhánh. Sr, mình nhầm"
Phúc Trí,1,12/19/2011,Re:Testcase,"Test 59 proceduremain(b:boolean); begin varx:real; constt=[[1;2];[3;4]]; whilet[0,0]>t[0,1]dobegin x:=2; end x:=x; end; cái phần Not Defined Before Useđâu có yêu cầu evalđiều kiện đâu. Biết là t[0,0]>t[0,1] ra false constant. Nhưngđặc tảđâu yêu cầu KTđâu. Cái phần Not Return Hòa nói eval thì còn chấp nhậnđược. Còn cái nàyđềđã nói thế. Thầy chỉ nói với Hòachứ chưacông bố chính thức mà. :|"
Thanh Pham Minh,1,12/20/2011,Re:Testcase,"Thêm một test về Not Defined Before Used :) var u: integer; var v: integer; procedure main(); begin var x, y: integer; while (u > 0) do begin var u: integer; while ( 1 > 0) do begin u:= 1; y:= 2; if ( 0 > 1 ) then continue; x:= 1; y:= x; v:= 2; end // x:= y; y:= x; end u:= u; v:= v; end; Output: //none"
vanhoa,1,12/16/2011,Testcase,Mình đã update lại các test case và thêm một số test case mới.
vanhoa,1,12/16/2011,Testcase,Uh lâu rồi mình không xem ass này nên quên mất còn có kiểu Parameter nữa. Mình sửa rồi đó bạn.
nguyen dung,1,12/16/2011,Re:Testcase,"Sao cái test 6 ra ngộ vậy Hòa: Type Mismatch In Statement Some(Symbol(main,ProcType(List()),Procedure)) : assign(main,0) Ra: Type Mismatch In Statement: assign(main,0) thôi chứ nhỉ ?"
FirstName LastName,1,12/16/2011,Re:Testcase,"Vanhoa bạn coi lại test 6 tự dưng in ra dài kinh thế Type Mismatch In Statement Some(Symbol(main,ProcType(List()),Procedure)): assign(main,0) (debug chưa xóa nè)"
_Trung_Than_Thong,1,12/16/2011,Re:Testcase,cái này ra thế nào mọi người: procedure f(a:real); begin var f:real; end;
vanhoa,1,12/17/2011,Testcase,@MU: Ok mình sửa rồi. @TTT: xem Test # 76.
FirstName LastName,1,12/17/2011,Re:Testcase,"test 76, cái biến f(hàm) coi như là toàn cục, nhưng biến f trong hàmđó thì là biến cục bộ, như vậy vẫnđúng chứ, sao lại Redeclare dc nhỉ"
MFC.Maximus,1,12/17/2011,Re:Testcase,cho mình hỏi test 36 sai chỗ nào thế :). Mình không hiểu path of execution cho lắm
_Trung_Than_Thong,1,12/17/2011,Re:Testcase,"Manchester United wrote: test 76, cái biến f(hàm) coi như là toàn cục, nhưng biến f trong hàmđó thì là biến cục bộ, như vậy vẫnđúng chứ, sao lại Redeclare dc nhỉ cùng ý kiến với bạn. Huống chi là Tên hàm có thể trùng tên biến còn tên biến sao lại k thể trùng mà declare dc"
vanhoa,1,12/20/2011,Re:Testcase,"Thanh Pham Minh wrote: Thêm một test về Not Defined Before Used :) var u: integer; var v: integer; procedure main(); begin var x, y: integer; while (u > 0) do begin var u: integer; while (v > 0) do begin //vong lap nay chua chac da duoc chay u:= 1; y:= 2; if (u > 0) then continue; x:= 1; y:= x; v:= 2; end x:= y;//y is not defined. y:= x; end u:= u; v:= v; end; Output: //None"
Thanh Pham Minh,1,12/20/2011,Re:Testcase,"@vanhoa: mình post test này lên cũng là muốn thắc mắc chỗ đó. Luật 4 phần i không nhắc đến expr trước do phải chắc chắn đúng (hoặc > 0), thậm chí không loại trừ cả trường hợp expr đó chắc chắn sai. Nếu xét expr thì lại không thống nhất với luật 3. Luật 3 lại luôn yêu cầu biến phải được gán trong ""...both branches..."" . Thấy kiểu nào thỏa đặc tả cũng không được hợp lý, mà kiểu hợp lý thì không còn đúng với đặc tả! Edit: trong notice thầy có bổ sung ý rồi. Kết hợp đặc tả với Notice thì không còn bất hợp lý nữa =)) Sửa lại test phía trên luôn cho hợp :D"
vanhoa,1,12/20/2011,Testcase,Mình update lại testcase theo file PT của a Hùng.
Phúc Trí,1,12/20/2011,Re:Testcase,Cho minh hỏi.File PT của thầy vẫn là kiểu int và float. Vậy mình fai sửa lại kiểu trong file StaticCheck sao. tại trong 12 cái hàm built của thầy làm banđầu thì thầyđể kiểu integer và real. v Vậy cuối cùng làm theo cái nàođây.
vanhoa,1,12/20/2011,Testcase,Thầy cập nhật lại rồi đó bạn :)
Phúc Trí,1,12/20/2011,Re:Testcase,"file nguyên mẫu của thầy có ghi Symbol(""readInt"", FuncType(List(), PrimitiveType(""integer"")) , ""Function"") ý mình hỏi là cái kiểu trong file StaticCheck là ""integer"". vậy là mình phải sửa trong file StaticCheck PrimitiveType(""integer"") => PrimitiveType(""int"") PrimitiveType(""real"") => PrimitiveType(""float"") cho tương thích với file PT phải không"
Phúc Trí,1,12/20/2011,Re:Testcase,cho mình hỏi VD này: if(true) x:=9; //không có else vậy x cóđược tính làđã có giá trị không
Thanh Pham Minh,1,12/20/2011,Re:Testcase,"Test này các bạn ra None hay Type Mismatch In Expression: array([array([array([1.0,2.0])]),array([array([1,2])])]) function foo(param: array[2,1,2] of real): integer; begin return 0; end; procedure main(); begin var a: real; a:= foo([[[1.0; 2.0]]; [[1; 2]]]); end; Test này ra None hay Type Mismatch In Expression: ele(a,[1000]) procedure main(); begin var a: array[2] of integer; a[1000]:= 1000; end;"
Phúc Trí,1,12/20/2011,Re:Testcase,"Thanh Pham Minh wrote: Test này các bạn ra None hay Type Mismatch In Expression: array([array([array([1.0,2.0])]),array([array([1,2])])]) function foo(param: array[2,1,2] of real): integer; begin return 0; end; procedure main(); begin var a: real; a:= foo([[[1.0; 2.0]]; [[1; 2]]]); end; Test này ra None hay Type Mismatch In Expression: ele(a,[1000]) procedure main(); begin var a: array[2] of integer; a[1000]:= 1000; end; cái 1 ra nhu bạn. cái 2 None"
FirstName LastName,1,12/17/2011,Re:Testcase,procedure main(); begin var va: array[10] of real; const ca = [1;2;3;4]; va[11]:=2; ca[3.4]:=2 //dòng này lỗi vì ca là constant mà trongarray cũng sai vì là real end; Cái này sẽ báo là a. Type Mismatch In Expression b.Cannot Assign To Constant Cái nàođúng
TV,1,12/17/2011,Re:Testcase,https://elearning.cse.hcmut.edu.vn/library/editor/FCKeditor/editor/skins/default/fck_strip.gif); background-position: 0px -448px; " class="TB_Button_Image" alt="" src="https://elearning.cse.hcmut.edu.vn/library/editor/FCKeditor/editor/images/spacer.gif" /> Hoa xem lai test39
Nhan Nguyen Van,1,12/17/2011,Re:Testcase,Test case Vui procedure demo(); begin y := true; var y: integer; y := 0; end; var y : boolean; => None
vanhoa,1,12/17/2011,Testcase,"@TV: Test 39 lỗi vậy vì không gán đc vào String (theo đặc tả) :| @nhan: test đó báo y chưa được khai báo, vì hàm demo chỉ thấy được các biến toàncục ở trên nó thôi. EDIT: uh test của nhan không báo lỗi."
vanhoa,1,12/17/2011,Testcase,Mình vừa cập nhật testcase và thêm một số case mới.
Nhan Nguyen Van,1,12/17/2011,Re:Testcase,var x :real; function demo(a: real): real; begin return 0; end; procedure main(); begin var demo: real; x := demo(demo); end; Ra gi cac bac?
FirstName LastName,1,12/17/2011,Re:Testcase,"Type Mismatch In Expression: call(demo,[demo]) k bitđúng ko"
vanhoa,1,12/17/2011,Testcase,"Most closed nested rule: For every applied occurrence (i.e., use) of an identifier I in a block A, there must be a corresponding declaration of I. The declaration is in a block that is smallest enclosing the applied occurrence of I. Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block."
vanhoa,1,12/17/2011,Testcase,Mình vừa cập nhật thêm một số testcase.
Ngan Tuyet,1,12/21/2011,Tổng hợp các câu hỏi?,"Thưa thầy, gần deadline rùi mà mọi người vẫn còn những thắc mắc do đề ko rõ và notice mới của thầy về eval cg ko rõ lắm. Em xin tổng hợp 1 số câu hỏi: 1. Truyền tham số , return với kiểu string có chấp nhận. Có áp dụng LHS:=RHS (LHS khác string và array type) 2. UnaryOp có string (như AST sinh ra do PT.scala của thầy) 3. Case h: assign sau break và continue ko tính. Thế sau return có tính ko? 4. Case i: 3 trường hợp: While(true) {break; return .. ;} While(false){return;} While(unknown) {return;} TH nào là báo lỗi function not return; 5. eval giá trị ảnh hưởng tới trường hợp case h và i hay tất cả các trường hợp ? Vd như câu thầy nói "" trong trường hợp 1 trong 2 nhánh chắc chắn không bao giờ thỏa mãn thì mình chỉ kiểm tra 1 nhánh còn lại"". Vậy nhánh sai sẽ không kiểm tra cái gì hết hay chỉ không tính phép gán hoặc return thôi."
Sieutoc,1,12/20/2011,Re:Testcase,//sorry deleted
vanhoa,1,12/1/2011,Testcase,"Notice: Giờ các test mình không đúng nữa đâu, mình cũng chán rồi, sẽ không sửa gì nữa, các bạn chỉ nên tham khảo các test ngoài bonus :) Các bạn click vào số thứ tự test để xem test nhé. Program INPUT AST OUTPUT [017] proceduremain();begin vara,b,c,d,e:integer; varr:array[10]ofreal; r[hello]:=0; end; [proc(main,[],[var(a,integer),var(b,integer),var(c,integer),var(d,integer),var(e,integer),var(r,arr([10],real)),assign(ele(r,[hello]),0)])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(integer)), Var(b,PrimitiveType(integer)), Var(c,PrimitiveType(integer)), Var(d,PrimitiveType(integer)), Var(e,PrimitiveType(integer)), Var(r,Arr(List(IntLit(10)),PrimitiveType(real))), Assign(Ele(r,List(Id(hello))),IntLit(0))))))) Undeclared Identifier: hello [018] proceduremain();begin vara,b,c,d,e:integer; varr:array[10]ofreal; r[0]:=r[1/2]; end; [proc(main,[],[var(a,integer),var(b,integer),var(c,integer),var(d,integer),var(e,integer),var(r,arr([10],real)),assign(ele(r,[0]),ele(r,[rdiv(1,2)]))])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(integer)), Var(b,PrimitiveType(integer)), Var(c,PrimitiveType(integer)), Var(d,PrimitiveType(integer)), Var(e,PrimitiveType(integer)), Var(r,Arr(List(IntLit(10)),PrimitiveType(real))), Assign(Ele(r,List(IntLit(0))),Ele(r,List(BinaryOp(rdiv,IntLit(1),IntLit(2)))))))))) Type Mismatch In Expression: ele(r,[rdiv(1,2)]) [019] proceduremain();begin vara,b,c,d,e:integer; varr:array[10,20]ofreal; r[0]:=0; end; [proc(main,[],[var(a,integer),var(b,integer),var(c,integer),var(d,integer),var(e,integer),var(r,arr([10,20],real)),assign(ele(r,[0]),0)])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(integer)), Var(b,PrimitiveType(integer)), Var(c,PrimitiveType(integer)), Var(d,PrimitiveType(integer)), Var(e,PrimitiveType(integer)), Var(r,Arr(List(IntLit(10), IntLit(20)),PrimitiveType(real))), Assign(Ele(r,List(IntLit(0))),IntLit(0))))))) Type Mismatch In Expression: ele(r,[0]) [020] proceduremain();begin vara,b,c,d,e:integer; varr:array[10]ofreal; r[0]:=0; end; [proc(main,[],[var(a,integer),var(b,integer),var(c,integer),var(d,integer),var(e,integer),var(r,arr([10],real)),assign(ele(r,[0]),0)])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(integer)), Var(b,PrimitiveType(integer)), Var(c,PrimitiveType(integer)), Var(d,PrimitiveType(integer)), Var(e,PrimitiveType(integer)), Var(r,Arr(List(IntLit(10)),PrimitiveType(real))), Assign(Ele(r,List(IntLit(0))),IntLit(0))))))) [021] proceduremain();begin vara,b,c,d,e:integer; varr,r1,r2:array[10]ofreal; r[r1divr2]:=0; end; [proc(main,[],[var(a,integer),var(b,integer),var(c,integer),var(d,integer),var(e,integer),var(r,arr([10],real)),var(r1,arr([10],real)),var(r2,arr([10],real)),assign(ele(r,[idiv(r1,r2)]),0)])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(integer)), Var(b,PrimitiveType(integer)), Var(c,PrimitiveType(integer)), Var(d,PrimitiveType(integer)), Var(e,PrimitiveType(integer)), Var(r,Arr(List(IntLit(10)),PrimitiveType(real))), Var(r1,Arr(List(IntLit(10)),PrimitiveType(real))), Var(r2,Arr(List(IntLit(10)),PrimitiveType(real))), Assign(Ele(r,List(BinaryOp(idiv,Id(r1),Id(r2)))),IntLit(0))))))) Type Mismatch In Expression: idiv(r1,r2) [022] proceduremain();begin vara,b,c,d,e:integer; varr:array[7,7]ofreal; r[0,0]:=0; end; [proc(main,[],[var(a,integer),var(b,integer),var(c,integer),var(d,integer),var(e,integer),var(r,arr([7,7],real)),assign(ele(r,[0,0]),0)])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(integer)), Var(b,PrimitiveType(integer)), Var(c,PrimitiveType(integer)), Var(d,PrimitiveType(integer)), Var(e,PrimitiveType(integer)), Var(r,Arr(List(IntLit(7), IntLit(7)),PrimitiveType(real))), Assign(Ele(r,List(IntLit(0), IntLit(0))),IntLit(0))))))) [023] proceduremain();begin vara,b,c,d,e:integer; varr:array[10,0]ofreal; r[0,0]:=0; end; [proc(main,[],[var(a,integer),var(b,integer),var(c,integer),var(d,integer),var(e,integer),var(r,arr([10,0],real)),assign(ele(r,[0,0]),0)])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(integer)), Var(b,PrimitiveType(integer)), Var(c,PrimitiveType(integer)), Var(d,PrimitiveType(integer)), Var(e,PrimitiveType(integer)), Var(r,Arr(List(IntLit(10), IntLit(0)),PrimitiveType(real))), Assign(Ele(r,List(IntLit(0), IntLit(0))),IntLit(0))))))) Size Is Not Zero: var(r,arr([10,0],real)) [024] proceduremain(); begin while1=2dobegin break;continue; end end; [proc(main,[],[while(eql(1,2),[break(null),continue(null)])])] Program(List(Proc(main,List(),Block(List(While(BinaryOp(eql,IntLit(1),IntLit(2)),Block(List(Break(), Continue())))))))) [025] proceduremain(); begin while1=2dobegin break;continue; end break; end; [proc(main,[],[while(eql(1,2),[break(null),continue(null)]),break(null)])] Program(List(Proc(main,List(),Block(List(While(BinaryOp(eql,IntLit(1),IntLit(2)),Block(List(Break(), Continue()))), Break()))))) Break Not In Loop [026] proceduremain(); begin while1=2dobegin break;continue; end continue; end; [proc(main,[],[while(eql(1,2),[break(null),continue(null)]),continue(null)])] Program(List(Proc(main,List(),Block(List(While(BinaryOp(eql,IntLit(1),IntLit(2)),Block(List(Break(), Continue()))), Continue()))))) Continue Not In Loop [027] proceduremain(); begin while1=2dobegin if1=1then begin begin if2>3then begin break;continue; end end end end if1<1.0then begin end end; [proc(main,[],[while(eql(1,2),[if(eql(1,1),[[if(greater(2,3),[break(null),continue(null)])]])]),if(less(1,1.0),[])])] Program(List(Proc(main,List(),Block(List(While(BinaryOp(eql,IntLit(1),IntLit(2)),Block(List(If(BinaryOp(eql,IntLit(1),IntLit(1)),Block(List(Block(List(If(BinaryOp(greater,IntLit(2),IntLit(3)),Block(List(Break(), Continue())),None))))),None)))), If(BinaryOp(less,IntLit(1),FloatLit(1.0)),Block(List()),None)))))) Type Mismatch In Expression: less(1,1.0) [028] proceduremain(); begin while1=1dobeginend end; [proc(main,[],[while(eql(1,1),[])])] Program(List(Proc(main,List(),Block(List(While(BinaryOp(eql,IntLit(1),IntLit(1)),Block(List()))))))) [029] proceduremain(); begin while1dobeginend end; [proc(main,[],[while(1,[])])] Program(List(Proc(main,List(),Block(List(While(IntLit(1),Block(List()))))))) Type Mismatch In Statement: while(1,[]) [030] proceduremain(); begin if1=1thenbeginend end; [proc(main,[],[if(eql(1,1),[])])] Program(List(Proc(main,List(),Block(List(If(BinaryOp(eql,IntLit(1),IntLit(1)),Block(List()),None)))))) [031] proceduremain(); begin if1thenbeginend end; [proc(main,[],[if(1,[])])] Program(List(Proc(main,List(),Block(List(If(IntLit(1),Block(List()),None)))))) Type Mismatch In Statement: if(1,[]) [032] proceduremain(); begin loop1dobeginend end; [proc(main,[],[loop(1,[])])] Program(List(Proc(main,List(),Block(List(Loop(IntLit(1),Block(List()))))))) [033] proceduremain(); begin loop1=1dobeginend end; [proc(main,[],[loop(eql(1,1),[])])] Program(List(Proc(main,List(),Block(List(Loop(BinaryOp(eql,IntLit(1),IntLit(1)),Block(List()))))))) Type Mismatch In Statement: loop(eql(1,1),[]) [034] functionmain():real; begin return1; end; [func(main,[],real,[return(1)])] Program(List(Func(main,List(),PrimitiveType(real),Block(List(Return(IntLit(1))))))) [035] functionmain():real; begin while1=1do return1; loop1do return1; if1=1thenreturn1; end; [func(main,[],real,[while(eql(1,1),return(1)),loop(1,return(1)),if(eql(1,1),return(1))])] Program(List(Func(main,List(),PrimitiveType(real),Block(List(While(BinaryOp(eql,IntLit(1),IntLit(1)),Return(IntLit(1))), Loop(IntLit(1),Return(IntLit(1))), If(BinaryOp(eql,IntLit(1),IntLit(1)),Return(IntLit(1)),None)))))) [036] functionmain1():real; begin while1=1do return1; end; functionmain2():real; begin loop1do return1; end; functionmain3():real; begin if1=1thenreturn1; end; functionmainx(x:real):real; begin if1>1thenreturn1; while1=1dobegin ifx<1.0thenbreak; return1; end while1=0doreturn1; loop10-20+11dobegin if1.0 [func(main1,[],real,[while(eql(1,1),return(1))]),func(main2,[],real,[loop(1,return(1))]),func(main3,[],real,[if(eql(1,1),return(1))]),func(mainx,[par(x,real)],real,[if(greater(1,1),return(1)),while(eql(1,1),[if(less(x,1.0),break(null)),return(1)]),while(eql(1,0),return(1)),loop(add(sub(10,20),11),[if(less(1.0,x),break(null)),return(1)]),loop(0,return(1)),if(greater(x,1.0),return(1)),if(bnot(greater(x,1.0)),return(1))])] Program(List(Func(main1,List(),PrimitiveType(real),Block(List(While(BinaryOp(eql,IntLit(1),IntLit(1)),Return(IntLit(1)))))), Func(main2,List(),PrimitiveType(real),Block(List(Loop(IntLit(1),Return(IntLit(1)))))), Func(main3,List(),PrimitiveType(real),Block(List(If(BinaryOp(eql,IntLit(1),IntLit(1)),Return(IntLit(1)),None)))), Func(mainx,List(Var(x,PrimitiveType(real))),PrimitiveType(real),Block(List(If(BinaryOp(greater,IntLit(1),IntLit(1)),Return(IntLit(1)),None), While(BinaryOp(eql,IntLit(1),IntLit(1)),Block(List(If(BinaryOp(less,Id(x),FloatLit(1.0)),Break(),None), Return(IntLit(1))))), While(BinaryOp(eql,IntLit(1),IntLit(0)),Return(IntLit(1))), Loop(BinaryOp(add,BinaryOp(sub,IntLit(10),IntLit(20)),IntLit(11)),Block(List(If(BinaryOp(less,FloatLit(1.0),Id(x)),Break(),None), Return(IntLit(1))))), Loop(IntLit(0),Return(IntLit(1))), If(BinaryOp(greater,Id(x),FloatLit(1.0)),Return(IntLit(1)),None), If(UnaryOp(bnot,BinaryOp(greater,Id(x),FloatLit(1.0))),Return(IntLit(1)),None)))))) Function Not Return: mainx [037] functionmain():real; begin varx:boolean; x:=false; ifxthenbegin return1; endelsebegin return1; end end; [func(main,[],real,[var(x,boolean),assign(x,false),if(x,[return(1)],[return(1)])])] Program(List(Func(main,List(),PrimitiveType(real),Block(List(Var(x,PrimitiveType(boolean)), Assign(Id(x),BoolLit(false)), If(Id(x),Block(List(Return(IntLit(1)))),Some(Block(List(Return(IntLit(1))))))))))) [038] varx:array[10,0]ofreal; [var(x,arr([10,0],real))] Program(List(Var(x,Arr(List(IntLit(10), IntLit(0)),PrimitiveType(real))))) Size Is Not Zero: var(x,arr([10,0],real)) [039] proceduremain(); begin vara:string; conststrConst='hello''world'; a:='2'+strConst; end; [proc(main,[],[var(a,string),const(strConst,string(""'hello''world'"")),assign(a,add(string(""'2'""),strConst))])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(string)), Const(strConst,StringLit(""'hello '' world'"")), Assign(Id(a),BinaryOp(add,UnaryOp(string,StringLit(""'2'"")),Id(strConst)))))))) Type Mismatch In Statement: assign(a,add(string(""'2'""),strConst)) [040] proceduremain(); begin vara:string; a:=1+true; end; [proc(main,[],[var(a,string),assign(a,add(1,true))])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(string)), Assign(Id(a),BinaryOp(add,IntLit(1),BoolLit(true)))))))) Type Mismatch In Statement: assign(a,add(1,true)) [041] proceduremain(); begin vara:string; constarrConst=['hello''world';'']; vararrVar:array[2]ofstring; arrVar:=['1';'2']; arrVar:=arrConst; a:=arrConst; end; [proc(main,[],[var(a,string),const(arrConst,array([string(""'hello''world'""),string(""''"")])),var(arrVar,arr([2],string)),assign(arrVar,array([string(""'1'""),string(""'2'"")])),assign(arrVar,arrConst),assign(a,arrConst)])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(string)), Const(arrConst,ArrayLit(List(StringLit(""'hello '' world'""), StringLit(""''"")))), Var(arrVar,Arr(List(IntLit(2)),PrimitiveType(string))), Assign(Id(arrVar),ArrayLit(List(StringLit(""'1'""), StringLit(""'2'"")))), Assign(Id(arrVar),Id(arrConst)), Assign(Id(a),Id(arrConst))))))) Type Mismatch In Statement: assign(arrVar,array([string(""'1'""),string(""'2'"")])) [042] proceduremain(); begin vararrVar:array[2]ofstring; arrVar:=[1;2]; end; [proc(main,[],[var(arrVar,arr([2],string)),assign(arrVar,array([1,2]))])] Program(List(Proc(main,List(),Block(List(Var(arrVar,Arr(List(IntLit(2)),PrimitiveType(string))), Assign(Id(arrVar),ArrayLit(List(IntLit(1), IntLit(2))))))))) Type Mismatch In Statement: assign(arrVar,array([1,2])) [043] proceduremain(); begin vararrVar:array[2]ofstring; arrVar:=['1';'2']; arrVar[1]:=13; end; [proc(main,[],[var(arrVar,arr([2],string)),assign(arrVar,array([string(""'1'""),string(""'2'"")])),assign(ele(arrVar,[1]),13)])] Program(List(Proc(main,List(),Block(List(Var(arrVar,Arr(List(IntLit(2)),PrimitiveType(string))), Assign(Id(arrVar),ArrayLit(List(StringLit(""'1'""), StringLit(""'2'"")))), Assign(Ele(arrVar,List(IntLit(1))),IntLit(13))))))) Type Mismatch In Statement: assign(arrVar,array([string(""'1'""),string(""'2'"")])) [044] proceduremain(); begin vararrVar:array[2]ofstring; arrVar:=['1';'2']; arrVar[1]:='13'; end; [proc(main,[],[var(arrVar,arr([2],string)),assign(arrVar,array([string(""'1'""),string(""'2'"")])),assign(ele(arrVar,[1]),string(""'13'""))])] Program(List(Proc(main,List(),Block(List(Var(arrVar,Arr(List(IntLit(2)),PrimitiveType(string))), Assign(Id(arrVar),ArrayLit(List(StringLit(""'1'""), StringLit(""'2'"")))), Assign(Ele(arrVar,List(IntLit(1))),UnaryOp(string,StringLit(""'13'"")))))))) Type Mismatch In Statement: assign(arrVar,array([string(""'1'""),string(""'2'"")])) [045] proceduremain(); begin vara:boolean; a:=(1+2*3.4)=5.0; a:=1=2; a:=1.2=2.2; a:=1=2.2; a:=(1<2)and(2<3); a:=1<2<3; end; [proc(main,[],[var(a,boolean),assign(a,eql(add(1,times(2,3.4)),5.0)),assign(a,eql(1,2)),assign(a,eql(1.2,2.2)),assign(a,eql(1,2.2)),assign(a,band(less(1,2),less(2,3))),assign(a,less(less(1,2),3))])] Program(List(Proc(main,List(),Block(List(Var(a,PrimitiveType(boolean)), Assign(Id(a),BinaryOp(eql,BinaryOp(add,IntLit(1),BinaryOp(times,IntLit(2),FloatLit(3.4))),FloatLit(5.0))), Assign(Id(a),BinaryOp(eql,IntLit(1),IntLit(2))), Assign(Id(a),BinaryOp(eql,FloatLit(1.2),FloatLit(2.2))), Assign(Id(a),BinaryOp(eql,IntLit(1),FloatLit(2.2))), Assign(Id(a),BinaryOp(band,BinaryOp(less,IntLit(1),IntLit(2)),BinaryOp(less,IntLit(2),IntLit(3)))), Assign(Id(a),BinaryOp(less,BinaryOp(less,IntLit(1),IntLit(2)),IntLit(3)))))))) Type Mismatch In Expression: eql(add(1,times(2,3.4)),5.0) [046] proceduremain(); begin varx:integer; x:=2; begin x:=3; varx:real; x:=3;x:=3.0; end x:=4; x:=4.4; end; [proc(main,[],[var(x,integer),assign(x,2),[assign(x,3),var(x,real),assign(x,3),assign(x,3.0)],assign(x,4),assign(x,4.4)])] Program(List(Proc(main,List(),Block(List(Var(x,PrimitiveType(integer)), Assign(Id(x),IntLit(2)), Block(List(Assign(Id(x),IntLit(3)), Var(x,PrimitiveType(real)), Assign(Id(x),IntLit(3)), Assign(Id(x),FloatLit(3.0)))), Assign(Id(x),IntLit(4)), Assign(Id(x),FloatLit(4.4))))))) Type Mismatch In Statement: assign(x,4.4) [047] proceduremain(); begin varx:integer; x:=2; begin x:=3; varx:real; x:=3;x:=3.0; end x:=4; x:=z; x:=4.4; constz=2; end; [proc(main,[],[var(x,integer),assign(x,2),[assign(x,3),var(x,real),assign(x,3),assign(x,3.0)],assign(x,4),assign(x,z),assign(x,4.4),const(z,2)])] Program(List(Proc(main,List(),Block(List(Var(x,PrimitiveType(integer)), Assign(Id(x),IntLit(2)), Block(List(Assign(Id(x),IntLit(3)), Var(x,PrimitiveType(real)), Assign(Id(x),IntLit(3)), Assign(Id(x),FloatLit(3.0)))), Assign(Id(x),IntLit(4)), Assign(Id(x),Id(z)), Assign(Id(x),FloatLit(4.4)), Const(z,IntLit(2))))))) Undeclared Identifier: z [048] proceduremain(); begin varx:integer; x:=2; begin constz=2; x:=3; varx:real; x:=3;x:=3.0; end x:=4; x:=z; x:=4.4; end; [proc(main,[],[var(x,integer),assign(x,2),[const(z,2),assign(x,3),var(x,real),assign(x,3),assign(x,3.0)],assign(x,4),assign(x,z),assign(x,4.4)])] Program(List(Proc(main,List(),Block(List(Var(x,PrimitiveType(integer)), Assign(Id(x),IntLit(2)), Block(List(Const(z,IntLit(2)), Assign(Id(x),IntLit(3)), Var(x,PrimitiveType(real)), Assign(Id(x),IntLit(3)), Assign(Id(x),FloatLit(3.0)))), Assign(Id(x),IntLit(4)), Assign(Id(x),Id(z)), Assign(Id(x),FloatLit(4.4))))))) Undeclared Identifier: z [049] functionmain():real; begin varx:real; x:=1; returnx; end; [func(main,[],real,[var(x,real),assign(x,1),return(x)])] Program(List(Func(main,List(),PrimitiveType(real),Block(List(Var(x,PrimitiveType(real)), Assign(Id(x),IntLit(1)), Return(Id(x))))))) [050] functionmain():real; begin varx:real; x:=x; end; [func(main,[],real,[var(x,real),assign(x,x)])] Program(List(Func(main,List(),PrimitiveType(real),Block(List(Var(x,PrimitiveType(real)), Assign(Id(x),Id(x))))))) Not Defined Before Used: x [051] proceduremain(x:real); begin x:=x; end; [proc(main,[par(x,real)],[assign(x,x)])] Program(List(Proc(main,List(Var(x,PrimitiveType(real))),Block(List(Assign(Id(x),Id(x))))))) [052] proceduremain(); begin varboolVar:boolean; varx:real; boolVar:=false; ifboolVarthenbegin x:=1; x:=2; end x:=x; end; [proc(main,[],[var(boolVar,boolean),var(x,real),assign(boolVar,false),if(boolVar,[assign(x,1),assign(x,2)]),assign(x,x)])] Program(List(Proc(main,List(),Block(List(Var(boolVar,PrimitiveType(boolean)), Var(x,PrimitiveType(real)), Assign(Id(boolVar),BoolLit(false)), If(Id(boolVar),Block(List(Assign(Id(x),IntLit(1)), Assign(Id(x),IntLit(2)))),None), Assign(Id(x),Id(x))))))) Not Defined Before Used: x [053] proceduremain(); begin varboolVar:boolean; varx:real; boolVar:=false; ifboolVarthenx:=1; elsex:=1; x:=x; end; [proc(main,[],[var(boolVar,boolean),var(x,real),assign(boolVar,false),if(boolVar,assign(x,1),assign(x,1)),assign(x,x)])] Program(List(Proc(main,List(),Block(List(Var(boolVar,PrimitiveType(boolean)), Var(x,PrimitiveType(real)), Assign(Id(boolVar),BoolLit(false)), If(Id(boolVar),Assign(Id(x),IntLit(1)),Some(Assign(Id(x),IntLit(1)))), Assign(Id(x),Id(x))))))) [054] proceduremain(); begin varboolVar:boolean; varx:real; boolVar:=false; ifboolVarthen x:=1; elsebegin varx:real; x:=1; end x:=x; end; [proc(main,[],[var(boolVar,boolean),var(x,real),assign(boolVar,false),if(boolVar,assign(x,1),[var(x,real),assign(x,1)]),assign(x,x)])] Program(List(Proc(main,List(),Block(List(Var(boolVar,PrimitiveType(boolean)), Var(x,PrimitiveType(real)), Assign(Id(boolVar),BoolLit(false)), If(Id(boolVar),Assign(Id(x),IntLit(1)),Some(Block(List(Var(x,PrimitiveType(real)), Assign(Id(x),IntLit(1)))))), Assign(Id(x),Id(x))))))) Not Defined Before Used: x [055] proceduremain(); begin varboolVar:boolean; varx:real; boolVar:=false; ifboolVarthen x:=1; elsebegin x:=1; varx:real; x:=1; end begin varx:real; x:=1; end x:=x; end; [proc(main,[],[var(boolVar,boolean),var(x,real),assign(boolVar,false),if(boolVar,assign(x,1),[assign(x,1),var(x,real),assign(x,1)]),[var(x,real),assign(x,1)],assign(x,x)])] Program(List(Proc(main,List(),Block(List(Var(boolVar,PrimitiveType(boolean)), Var(x,PrimitiveType(real)), Assign(Id(boolVar),BoolLit(false)), If(Id(boolVar),Assign(Id(x),IntLit(1)),Some(Block(List(Assign(Id(x),IntLit(1)), Var(x,PrimitiveType(real)), Assign(Id(x),IntLit(1)))))), Block(List(Var(x,PrimitiveType(real)), Assign(Id(x),IntLit(1)))), Assign(Id(x),Id(x))))))) [056] proceduremain(b:boolean); begin varx:real; whiletruedobegin ifbthenbegin x:=1; continue; endelsebreak; x:=2; end x:=x; end; [proc(main,[par(b,boolean)],[var(x,real),while(true,[if(b,[assign(x,1),continue(null)],break(null)),assign(x,2)]),assign(x,x)])] Program(List(Proc(main,List(Var(b,PrimitiveType(boolean))),Block(List(Var(x,PrimitiveType(real)), While(BoolLit(true),Block(List(If(Id(b),Block(List(Assign(Id(x),IntLit(1)), Continue())),Some(Break())), Assign(Id(x),IntLit(2))))), Assign(Id(x),Id(x))))))) Not Defined Before Used: x [057] proceduremain(b:boolean); begin varx:real; whilebdobegin ifbthenbegin whilenotbdobreak; x:=1; continue; endelsebegin x:=3; break; end x:=2; end x:=x; end; [proc(main,[par(b,boolean)],[var(x,real),while(b,[if(b,[while(bnot(b),break(null)),assign(x,1),continue(null)],[assign(x,3),break(null)]),assign(x,2)]),assign(x,x)])] Program(List(Proc(main,List(Var(b,PrimitiveType(boolean))),Block(List(Var(x,PrimitiveType(real)), While(Id(b),Block(List(If(Id(b),Block(List(While(UnaryOp(bnot,Id(b)),Break()), Assign(Id(x),IntLit(1)), Continue())),Some(Block(List(Assign(Id(x),IntLit(3)), Break())))), Assign(Id(x),IntLit(2))))), Assign(Id(x),Id(x))))))) Not Defined Before Used: x [058] proceduremain(b:boolean); begin varx:real; constt=[[1;2];[3;4]]; whilet[0,0] [proc(main,[par(b,boolean)],[var(x,real),const(t,array([array([1,2]),array([3,4])])),while(less(ele(t,[0,0]),ele(t,[0,1])),[assign(x,2)]),assign(x,x)])] Program(List(Proc(main,List(Var(b,PrimitiveType(boolean))),Block(List(Var(x,PrimitiveType(real)), Const(t,ArrayLit(List(ArrayLit(List(IntLit(1), IntLit(2))), ArrayLit(List(IntLit(3), IntLit(4)))))), While(BinaryOp(less,Ele(t,List(IntLit(0), IntLit(0))),Ele(t,List(IntLit(0), IntLit(1)))),Block(List(Assign(Id(x),IntLit(2))))), Assign(Id(x),Id(x))))))) [059] proceduremain(b:boolean); begin varx:real; constt=[[1;2];[3;4]]; whilet[0,0]>t[0,1]dobegin x:=2; end x:=x; end; [proc(main,[par(b,boolean)],[var(x,real),const(t,array([array([1,2]),array([3,4])])),while(greater(ele(t,[0,0]),ele(t,[0,1])),[assign(x,2)]),assign(x,x)])] Program(List(Proc(main,List(Var(b,PrimitiveType(boolean))),Block(List(Var(x,PrimitiveType(real)), Const(t,ArrayLit(List(ArrayLit(List(IntLit(1), IntLit(2))), ArrayLit(List(IntLit(3), IntLit(4)))))), While(BinaryOp(greater,Ele(t,List(IntLit(0), IntLit(0))),Ele(t,List(IntLit(0), IntLit(1)))),Block(List(Assign(Id(x),IntLit(2))))), Assign(Id(x),Id(x))))))) Not Defined Before Used: x [060] constbTrue=true; proceduremain(b:boolean); begin varx:real; whilebTruedobegin ifbTruethenbreak; x:=x; end x:=x; end; [const(bTrue,true),proc(main,[par(b,boolean)],[var(x,real),while(bTrue,[if(bTrue,break(null)),assign(x,x)]),assign(x,x)])] Program(List(Const(bTrue,BoolLit(true)), Proc(main,List(Var(b,PrimitiveType(boolean))),Block(List(Var(x,PrimitiveType(real)), While(Id(bTrue),Block(List(If(Id(bTrue),Break(),None), Assign(Id(x),Id(x))))), Assign(Id(x),Id(x))))))) Not Defined Before Used: x [061] constbTrue=true; proceduremain(b:boolean); begin varx:real; whilebTruedobegin ifnotbTruethenbreak; elsex:=-1; end writeInt(x); end; [const(bTrue,true),proc(main,[par(b,boolean)],[var(x,real),while(bTrue,[if(bnot(bTrue),break(null),assign(x,sub(1)))]),call(writeInt,[x])])] Program(List(Const(bTrue,BoolLit(true)), Proc(main,List(Var(b,PrimitiveType(boolean))),Block(List(Var(x,PrimitiveType(real)), While(Id(bTrue),Block(List(If(UnaryOp(bnot,Id(bTrue)),Break(),Some(Assign(Id(x),UnaryOp(sub,IntLit(1)))))))), ProcCall(writeInt,List(Id(x)))))))) Type Mismatch In Statement: call(writeInt,[x]) [062] constbTrue=true; functionmain(b:boolean):boolean; begin ifbTruethenreturntrue; end; [const(bTrue,true),func(main,[par(b,boolean)],boolean,[if(bTrue,return(true))])] Program(List(Const(bTrue,BoolLit(true)), Func(main,List(Var(b,PrimitiveType(boolean))),PrimitiveType(boolean),Block(List(If(Id(bTrue),Return(BoolLit(true)),None)))))) [063] constbTrue=true; functionmain(b:boolean):boolean; begin ifnotbTruethenreturntrue; end; [const(bTrue,true),func(main,[par(b,boolean)],boolean,[if(bnot(bTrue),return(true))])] Program(List(Const(bTrue,BoolLit(true)), Func(main,List(Var(b,PrimitiveType(boolean))),PrimitiveType(boolean),Block(List(If(UnaryOp(bnot,Id(bTrue)),Return(BoolLit(true)),None)))))) Function Not Return: main [064] constbTrue=true; functionmain(b:boolean):boolean; begin varx,y:real; whilebTruedobegin ifbthenbreak; elsey:=2; x:=7; end writeInt(x);writeInt(y); end; [const(bTrue,true),func(main,[par(b,boolean)],boolean,[var(x,real),var(y,real),while(bTrue,[if(b,break(null),assign(y,2)),assign(x,7)]),call(writeInt,[x]),call(writeInt,[y])])] Program(List(Const(bTrue,BoolLit(true)), Func(main,List(Var(b,PrimitiveType(boolean))),PrimitiveType(boolean),Block(List(Var(x,PrimitiveType(real)), Var(y,PrimitiveType(real)), While(Id(bTrue),Block(List(If(Id(b),Break(),Some(Assign(Id(y),IntLit(2)))), Assign(Id(x),IntLit(7))))), ProcCall(writeInt,List(Id(x))), ProcCall(writeInt,List(Id(y)))))))) Not Defined Before Used: x [065] constbTrue=true; functionmain(b:boolean):boolean; begin varx,y:real; whilebdobegin x:=7; end x:=x; returnfalse; end; [const(bTrue,true),func(main,[par(b,boolean)],boolean,[var(x,real),var(y,real),while(b,[assign(x,7)]),assign(x,x),return(false)])] Program(List(Const(bTrue,BoolLit(true)), Func(main,List(Var(b,PrimitiveType(boolean))),PrimitiveType(boolean),Block(List(Var(x,PrimitiveType(real)), Var(y,PrimitiveType(real)), While(Id(b),Block(List(Assign(Id(x),IntLit(7))))), Assign(Id(x),Id(x)), Return(BoolLit(false))))))) Not Defined Before Used: x [066] constbTrue=true; functionmain(b:boolean):boolean; begin varx:real; whiletruedobegin whiletruedobreak; x:=2; end x:=x; whiletruedobegin whilefalsedo whilefalsedo break; return1>1; end end; [const(bTrue,true),func(main,[par(b,boolean)],boolean,[var(x,real),while(true,[while(true,break(null)),assign(x,2)]),assign(x,x),while(true,[while(false,while(false,break(null))),return(greater(1,1))])])] Program(List(Const(bTrue,BoolLit(true)), Func(main,List(Var(b,PrimitiveType(boolean))),PrimitiveType(boolean),Block(List(Var(x,PrimitiveType(real)), While(BoolLit(true),Block(List(While(BoolLit(true),Break()), Assign(Id(x),IntLit(2))))), Assign(Id(x),Id(x)), While(BoolLit(true),Block(List(While(BoolLit(false),While(BoolLit(false),Break())), Return(BinaryOp(greater,IntLit(1),IntLit(1))))))))))) [067] functionmain(x:boolean):real; begin ifxthenreturn1; end; [func(main,[par(x,boolean)],real,[if(x,return(1))])] Program(List(Func(main,List(Var(x,PrimitiveType(boolean))),PrimitiveType(real),Block(List(If(Id(x),Return(IntLit(1)),None)))))) Function Not Return: main [068] functionmain(x:boolean):real; begin ifxortruethenreturn1; end; [func(main,[par(x,boolean)],real,[if(bor(x,true),return(1))])] Program(List(Func(main,List(Var(x,PrimitiveType(boolean))),PrimitiveType(real),Block(List(If(BinaryOp(bor,Id(x),BoolLit(true)),Return(IntLit(1)),None)))))) Function Not Return: main [069] functionmain(x:boolean):real; begin iftrueorxthenreturn1; end; [func(main,[par(x,boolean)],real,[if(bor(true,x),return(1))])] Program(List(Func(main,List(Var(x,PrimitiveType(boolean))),PrimitiveType(real),Block(List(If(BinaryOp(bor,BoolLit(true),Id(x)),Return(IntLit(1)),None)))))) Function Not Return: main [070] functionmain(x:boolean):real; begin ifnot(falseandx)thenreturn1; end; [func(main,[par(x,boolean)],real,[if(bnot(band(false,x)),return(1))])] Program(List(Func(main,List(Var(x,PrimitiveType(boolean))),PrimitiveType(real),Block(List(If(UnaryOp(bnot,BinaryOp(band,BoolLit(false),Id(x))),Return(IntLit(1)),None)))))) Function Not Return: main [071] proceduremain(); begin varva:array[10]ofreal; constca=[1;2;3;4]; va[10]:=2; ca[3]:=2; end; [proc(main,[],[var(va,arr([10],real)),const(ca,array([1,2,3,4])),assign(ele(va,[10]),2),assign(ele(ca,[3]),2)])] Program(List(Proc(main,List(),Block(List(Var(va,Arr(List(IntLit(10)),PrimitiveType(real))), Const(ca,ArrayLit(List(IntLit(1), IntLit(2), IntLit(3), IntLit(4)))), Assign(Ele(va,List(IntLit(10))),IntLit(2)), Assign(Ele(ca,List(IntLit(3))),IntLit(2))))))) Cannot Assign To Constant: assign(ele(ca,[3]),2) [072] functionmain():real; begin constca=[1;2;3;4]; returnca[1]-ca[1,2]; end; [func(main,[],real,[const(ca,array([1,2,3,4])),return(sub(ele(ca,[1]),ele(ca,[1,2])))])] Program(List(Func(main,List(),PrimitiveType(real),Block(List(Const(ca,ArrayLit(List(IntLit(1), IntLit(2), IntLit(3), IntLit(4)))), Return(BinaryOp(sub,Ele(ca,List(IntLit(1))),Ele(ca,List(IntLit(1), IntLit(2)))))))))) Type Mismatch In Expression: ele(ca,[1,2]) [073] functionmain():real; begin vara:array[10]ofinteger; vars:string; a[3]:=7-3; s:='hello'; return2; end; [func(main,[],real,[var(a,arr([10],integer)),var(s,string),assign(ele(a,[3]),sub(7,3)),assign(s,string(""'hello'"")),return(2)])] Program(List(Func(main,List(),PrimitiveType(real),Block(List(Var(a,Arr(List(IntLit(10)),PrimitiveType(integer))), Var(s,PrimitiveType(string)), Assign(Ele(a,List(IntLit(3))),BinaryOp(sub,IntLit(7),IntLit(3))), Assign(Id(s),UnaryOp(string,StringLit(""'hello'""))), Return(IntLit(2))))))) Type Mismatch In Statement: assign(s,string(""'hello'"")) [074] varglobalX,globalY:real; functionmain():real; begin vara:array[10]ofreal; varlocalX,localY:real; localY:=globalY; globalX:=localX; return2; end; [var(globalX,real),var(globalY,real),func(main,[],real,[var(a,arr([10],real)),var(localX,real),var(localY,real),assign(localY,globalY),assign(globalX,localX),return(2)])] Program(List(Var(globalX,PrimitiveType(real)), Var(globalY,PrimitiveType(real)), Func(main,List(),PrimitiveType(real),Block(List(Var(a,Arr(List(IntLit(10)),PrimitiveType(real))), Var(localX,PrimitiveType(real)), Var(localY,PrimitiveType(real)), Assign(Id(localY),Id(globalY)), Assign(Id(globalX),Id(localX)), Return(IntLit(2))))))) Not Defined Before Used: localX [075] varx:boolean; procedureproc(y:integer;j:integer); begin vara:integer; x:=a-true; end; [var(x,boolean),proc(proc,[par(y,integer),par(j,integer)],[var(a,integer),assign(x,sub(a,true))])] Program(List(Var(x,PrimitiveType(boolean)), Proc(proc,List(Var(y,PrimitiveType(integer)), Var(j,PrimitiveType(integer))),Block(List(Var(a,PrimitiveType(integer)), Assign(Id(x),BinaryOp(sub,Id(a),BoolLit(true)))))))) Not Defined Before Used: a [076] proceduref(a:real); begin varf:real; end; [proc(f,[par(a,real)],[var(f,real)])] Program(List(Proc(f,List(Var(a,PrimitiveType(real))),Block(List(Var(f,PrimitiveType(real))))))) Redeclared Variable: f [077] proceduredemo(); begin y:=true; vary:integer; y:=0; end; vary:boolean; [proc(demo,[],[assign(y,true),var(y,integer),assign(y,0)]),var(y,boolean)] Program(List(Proc(demo,List(),Block(List(Assign(Id(y),BoolLit(true)), Var(y,PrimitiveType(integer)), Assign(Id(y),IntLit(0))))), Var(y,PrimitiveType(boolean)))) [078] vary,z:integer; proceduremain(); begin y:=1; writeRealLn(foo(y)); end; constx=1.2e3; functionfoo(p:integer):real; begin returnp*x; end; [var(y,integer),var(z,integer),proc(main,[],[assign(y,1),call(writeRealLn,[call(foo,[y])])]),const(x,1.2e3),func(foo,[par(p,integer)],real,[return(times(p,x))])] Program(List(Var(y,PrimitiveType(integer)), Var(z,PrimitiveType(integer)), Proc(main,List(),Block(List(Assign(Id(y),IntLit(1)), ProcCall(writeRealLn,List(FuncCall(foo,List(Id(y)))))))), Const(x,FloatLit(1200.0)), Func(foo,List(Var(p,PrimitiveType(integer))),PrimitiveType(real),Block(List(Return(BinaryOp(times,Id(p),Id(x)))))))) [079] vara:array[5]ofinteger;//globalvariable procedurefill(x:array[5]ofinteger); begin vara:real;//supersedingglobalvariablea //varx:real;//WRONGbecauseparameterxhasthesamename a:=5.9; init(x); end; procedureinit(x:array[5]ofinteger); begin vari:integer;//blockvariable i:=0; x[i]:=a[i];//aisglobalvar. end; proceduremain(); begin fill(a); end; [var(a,arr([5],integer)),proc(fill,[par(x,arr([5],integer))],[var(a,real),assign(a,5.9),call(init,[x])]),proc(init,[par(x,arr([5],integer))],[var(i,integer),assign(i,0),assign(ele(x,[i]),ele(a,[i]))]),proc(main,[],[call(fill,[a])])] Program(List(Var(a,Arr(List(IntLit(5)),PrimitiveType(integer))), Proc(fill,List(Var(x,Arr(List(IntLit(5)),PrimitiveType(integer)))),Block(List(Var(a,PrimitiveType(real)), Assign(Id(a),FloatLit(5.9)), ProcCall(init,List(Id(x)))))), Proc(init,List(Var(x,Arr(List(IntLit(5)),PrimitiveType(integer)))),Block(List(Var(i,PrimitiveType(integer)), Assign(Id(i),IntLit(0)), Assign(Ele(x,List(Id(i))),Ele(a,List(Id(i))))))), Proc(main,List(),Block(List(ProcCall(fill,List(Id(a)))))))) [080] varvar2:integer; functionfun1(var1:integer):integer; begin vara:integer; return0; end; proceduremain(); begin var2:=3; constconst2=2.2; //var2:=var2+fun1(const2); fun1(const2); end; [var(var2,integer),func(fun1,[par(var1,integer)],integer,[var(a,integer),return(0)]),proc(main,[],[assign(var2,3),const(const2,2.2),call(fun1,[const2])])] Program(List(Var(var2,PrimitiveType(integer)), Func(fun1,List(Var(var1,PrimitiveType(integer))),PrimitiveType(integer),Block(List(Var(a,PrimitiveType(integer)), Return(IntLit(0))))), Proc(main,List(),Block(List(Assign(Id(var2),IntLit(3)), Const(const2,FloatLit(2.2)), ProcCall(fun1,List(Id(const2)))))))) Type Mismatch In Statement: call(fun1,[const2]) [081] varvar2:integer; procedurefun1(var1:real;var3:integer); begin vara:integer; end; proceduremain(); begin var2:=3.1; constconst2=2; //var2:=var2+fun1(const2); fun1(const2,var2); end; [var(var2,integer),proc(fun1,[par(var1,real),par(var3,integer)],[var(a,integer)]),proc(main,[],[assign(var2,3.1),const(const2,2),call(fun1,[const2,var2])])] Program(List(Var(var2,PrimitiveType(integer)), Proc(fun1,List(Var(var1,PrimitiveType(real)), Var(var3,PrimitiveType(integer))),Block(List(Var(a,PrimitiveType(integer))))), Proc(main,List(),Block(List(Assign(Id(var2),FloatLit(3.1)), Const(const2,IntLit(2)), ProcCall(fun1,List(Id(const2), Id(var2)))))))) Type Mismatch In Statement: assign(var2,3.1) [082] varvar2:integer; procedurefun1(var3,var4:array[2,1]ofreal); begin vara:integer; end; proceduremain(); begin varvar4:real; var4:=3.1; constconst2=2; varmyArr:array[2,1]ofinteger; varmyArr2:array[2,1]ofreal; fun1(myArr,myArr); fun1(myArr,myArr2); fun1(myArr,[[100];[200]]); constarrConst=[[101];[201]]; fun1(myArr,arrConst); fun1(myArr,[[[102]];[[202]]]); end; [var(var2,integer),proc(f"
Nhan Nguyen Van,1,12/17/2011,Re:Testcase,function main():string; begin return 'a'; end; Ra gi ?
FirstName LastName,1,12/17/2011,Re:Testcase,ủa nóđúng sao lại báo lỗi
FirstName LastName,1,12/17/2011,Re:Testcase,"constarrConst=[[101];[201]]; fun1(myArr,arrConst); fun1(myArr,[[[102]];[[202]]]); m ìnhđang thắc mắc là cái dòng fun1ở trên vàở dưới có khác gì nhau mà sao cái dòng dưới lại báo lỗi nhỉ p/s:ở test 82"
nguyen dung,1,12/17/2011,Re:Testcase,"LHS trong đặc tả không nói kiểu String nhưng mà trong file lại định nghĩa 2 proc sau Symbol(""writeStr"",ProcType(List(PrimitiveType(""string""))),""Procedure"") Symbol(""writeStrLn"",ProcType(List(PrimitiveType(""string""))), ""Procedure"") Vậy là chạy 2 proc này luôn báo lỗi,có mâu thuẫn gì không nhỉ ?"
TAM NGOC,1,12/17/2011,Testcase,"Test79 của bạn vanhoa: Hàm init chưa khai báo mà sử dụng vậy phải báo lỗi là Undeclared Identifier: init Theo mình nghĩ là vậy, bạn xem lại thử nhé."
vanhoa,1,12/18/2011,Testcase,"@MU: dòng dưới là mảng hằng với dim [2,1,1], dòng trên là [2,1]. @TN: tầm vực của một hàm biến/hằngtoàncục là toàn bộ chương trình, bất kể nó khai báo ở đâu :)"
Thanh Pham Minh,1,12/22/2011,Re:Tổng hợp các câu hỏi?,"Câu 3: lệnh gán sau return có tính không. (case h) Câu này nếu xét kỹ sẽ thấy nó không phải vấn đề. Lệnh return đặc biệt hơn lệnh break ở chỗ: sau break sẽ tiếp tục các lệnh ngoài loop, còn sau return sẽ thoat ra hẳn function. :)"
_Tieu_ Doan_Du,1,12/22/2011,Re:Tổng hợp các câu hỏi?,"Thanh Pham Minh wrote: Câu 3: lệnh gán sau return có tính không. (case h) Câu này nếu xét kỹ sẽ thấy nó không phải vấn đề. Lệnh return đặc biệt hơn lệnh break ở chỗ: sau break sẽ tiếp tục các lệnh ngoài loop, còn sau return sẽ thoat ra hẳn function. :) Đó là tư duy thông thường, nếu thế thì chả cần phải nói khái niệm biến phải được gán trước break làm gì, vì theo lẽ thường thì sau break có thực thi đâu."
I love you,1,12/1/2011,Re:Testcase,bạn Văn Hòa luôn là người đầu tiên đưa ra testcase :))
n0b0dy,1,12/1/2011,Testcase,Cảm ơn bạn vanhoa :)
Nhất Tiếu nại Hà,1,12/1/2011,Re:Testcase,thank vì tinh thần nào ...:D:D còn ai về vị trí thứ hai ko post test giúp anh em đi...;))..
Nhan Nguyen Van,1,12/2/2011,Re:Testcase,"Test này: Test #7 Program proceduremain(); begin constv=0; v:=0; end; INPUT [proc(main,[],[const(v,0),assign(v,0)])] OUTPUT Cannot Assign To Constant: v Hình như chưa đúng: Ouput là "" Cannot Assign To Constant: <satement>"" chứ đâu có phải là Cannot Assign To Constant: <identifier> đâu Hòa?"
vanhoa,1,12/2/2011,Testcase,Ok mình đã sửa lại.
Tin Bui,1,12/2/2011,Re:Testcase,"Có bạn nào biết cách chạy chương trình ko? chỉ giúp mình với, nghe thấy nói như trong mục notice mình chả hiểu phải làm sao cả"
vanhoa,1,12/2/2011,Testcase,Bạn nhập cái input của mình và kiểm tra output.
FirstName LastName,1,12/4/2011,Re:Testcase,nhầm :D
vanhoa,1,12/6/2011,Testcase,"Mình mới edit lại test. Sửa từ int thành integer, float thành real."
Nhan Nguyen Van,1,12/8/2011,Re:Testcase,procedure main(); begin const a = [1;2;3]; a := [1;3;4]; end; Test thu.
vanhoa,1,12/8/2011,Testcase,Cannot Assign To Constant
Nhan Nguyen Van,1,12/8/2011,Testcase,"vanhoa  wrote: Cannot Assign To Constant Văn Hòa có sửa lại PT đúng không? Theo mặc định thì Parser xuất ra constant array ở dạng  [1;2;3] nhưng ass 2 yêu cầu dạng array([1,2,3])"
V For,1,12/22/2011,Xin y kien cua a Hung!,"Anh Hung ơi, có 2 ý kiến trái nhau function func(): real; begin var func: real; end; Ý 1: ko lỗi; Ý 2: lỗi. Em thì nghi là ko lỗi. Vậy xin a cho ý kiến, em thấy để sai testcase vì không thống nhất ý kiến thì hơi vô duyên :D"
Phúc Trí,1,12/22/2011,Re:Xin y kien cua a Hung!,"Vo Thanh Hung Last edited: 12/22/2011 08:37:00 AM Messages: 128 Câu hỏi: 1. Truyền tham số , return với kiểu string có chấp nhận. Có áp dụng LHS:=RHS (LHS khác string và array type) Trả lời: Theo đặc tả ngôn ngữ thì chấp nhận. Nhưng ở assignment này đã thu hẹp lại như quy định ở 3d . Vì vậy, các em không cần làm tụi em chưa hiểu ý câu "" Vì vậy, các em không cần làm "" của thầy. ý thầy ko cần làm là ko cần làm j vậy? Nói tóm lại là: Truyền tham số với kiểu string, return với kiểu string và array có chấp nhận hay kh ông vậy thầy? Phần kiểm tra này không khó, nhưng nếu sai vì không hiểu ý thầy thì..."
Ngan Tuyet,1,12/22/2011,Re:Tổng hợp các câu hỏi?,"Thì biết logic là thế! Nhưng đây là crazy language, cái j cg phải hỏi lại cho chắc! Tại đề ko có nói!"
Thanh Pham Minh,1,12/22/2011,Re:Tổng hợp các câu hỏi?,"_Tieu_ Doan_Du wrote: Đó là tư duy thông thường, nếu thế thì chả cần phải nói khái niệm biến phải được gán trước break làm gì, vì theo lẽ thường thì sau break có thực thi đâu. OK, mình sẽ nói kỹ hơn một xíu. Tạm thời chúng ta có 3 lệnh cần quan tâm: lệnh return, lệnh gán, lệnh sử dụng (biến). Giờ xem như chưa có lệnh return: trong function chỉ có lệnh gán và lệnh sử dụng. Chúng ta sẽ đưa lệnh return vào sau để thấy được sự logic thông thường. Trường hợp 1: không thể chắc chắn lệnh gán xảy ra, lúc này ở lệnh sử dụng sẽ bị lỗi Not Defined Before Use. Giờ dù ta có đưa return vào chỗ nào đi nữa cũng không thay đổi được vấn đề (lệnh gán vẫn không thể chắc chắn xảy ra hay không => ở lệnh sử dụng vẫn lỗi). Trường hợp 2: lệnh gán chắc chắn xảy ra, lúc này ở lệnh sử dụng không có lỗi. 2a) Giờ nếu ta đưa return vào sau cả hai lệnh trên thì vẫn không có lỗi. 2b) Nếu ta đưa return vào giữa 2 lệnh trên. Chia ra: i) Nếu return xảy ra => lệnh sử dụng (nằm sau lệnh return) không thể xảy ra => không thể có lỗi (vẫn giống lúc không có return). ii)) Nếu return không xảy ra: trước lệnh sử dụng vẫn chắc chắn có lệnh gán (nếu không chắc chắn có lệnh gán thì rơi vào trường hợp 1 rồi nhé) => vẫn không thể có lỗi. iii) Return không chắc có xảy ra không: dù thế nào cũng là 1 trong 2 cái (i, ii) đã nói ở trên. 2c) Nếu ta đưa lệnh return vào trước 2 lệnh trên. Chia ra: i) Nếu return xảy ra => lệnh sử dụng (nằm sau lệnh return) không thể  xảy ra => không thể có lỗi (vẫn giống lúc không có return). ii)) Nếu return không xảy ra: trước lệnh sử dụng vẫn chắc chắn có lệnh  gán (nếu không chắc chắn có lệnh gán thì rơi vào trường hợp 1 rồi nhé)  => vẫn không thể có lỗi. iii) Return không chắc có xảy ra không: dù thế nào cũng là 1 trong 2 cái (i, ii) đã nói ở trên. Ok, rất là dài dòng, nhưng nếu bạn suy nghĩ được một cách thông thường thì không khó hiểu lắm đâu. Giờ đơn giản nhất là bạn hãy lấy một ví dụ để thấy rằng khi có và không có return thì kết quả (lỗi hay không lỗi Not Define...) thay đổi (theo ý mà bạn đầu topic đã nói). Nếu tìm được, tức là mình sai (& vice versa). Edit: à, mình hiểu rồi, thực ra bạn nhầm ở chỗ này. Sau break các lệnh nằm ngoài loop (vẫn trong function) CÓ thực thi bạn nhé => biến local của function vẫn còn. Còn sau return thì thoát khỏi function mất rồi, biến global thì mặc định được coi là đã define (theo đặc tả)."
nguyenducminhkhoi,1,12/22/2011,Re:Tổng hợp các câu hỏi?,"Thanh Pham Minh wrote: _Tieu_ Doan_Du wrote: Đó là tư duy thông thường, nếu thế thì chả cần phải nói khái niệm biến phải được gán trước break làm gì, vì theo lẽ thường thì sau break có thực thi đâu. OK, mình sẽ nói kỹ hơn một xíu. Tạm thời chúng ta có 3 lệnh cần quan tâm: lệnh return, lệnh gán, lệnh sử dụng (biến). Giờ xem như chưa có lệnh return: trong function chỉ có lệnh gán và lệnh sử dụng. Chúng ta sẽ đưa lệnh return vào sau để thấy được sự logic thông thường. Trường hợp 1: không thể chắc chắn lệnh gán xảy ra, lúc này ở lệnh sử dụng sẽ bị lỗi Not Defined Before Use. Giờ dù ta có đưa return vào chỗ nào đi nữa cũng không thay đổi được vấn đề (lệnh gán vẫn không thể chắc chắn xảy ra hay không => ở lệnh sử dụng vẫn lỗi). Trường hợp 2: lệnh gán chắc chắn xảy ra, lúc này ở lệnh sử dụng không có lỗi. 2a) Giờ nếu ta đưa return vào sau cả hai lệnh trên thì vẫn không có lỗi. 2b) Nếu ta đưa return vào giữa 2 lệnh trên. Chia ra: i) Nếu return xảy ra => lệnh sử dụng (nằm sau lệnh return) không thể xảy ra => không thể có lỗi (vẫn giống lúc không có return). ii)) Nếu return không xảy ra: trước lệnh sử dụng vẫn chắc chắn có lệnh gán (nếu không chắc chắn có lệnh gán thì rơi vào trường hợp 1 rồi nhé) => vẫn không thể có lỗi. iii) Return không chắc có xảy ra không: dù thế nào cũng là 1 trong 2 cái (i, ii) đã nói ở trên. 2c) Nếu ta đưa lệnh return vào trước 2 lệnh trên. Chia ra: i) Nếu return xảy ra => lệnh sử dụng (nằm sau lệnh return) không thể  xảy ra => không thể có lỗi (vẫn giống lúc không có return). ii)) Nếu return không xảy ra: trước lệnh sử dụng vẫn chắc chắn có lệnh  gán (nếu không chắc chắn có lệnh gán thì rơi vào trường hợp 1 rồi nhé)  => vẫn không thể có lỗi. iii) Return không chắc có xảy ra không: dù thế nào cũng là 1 trong 2 cái (i, ii) đã nói ở trên. Ok, rất là dài dòng, nhưng nếu bạn suy nghĩ được một cách thông thường thì không khó hiểu lắm đâu. Giờ đơn giản nhất là bạn hãy lấy một ví dụ để thấy rằng khi có và không có return thì kết quả (lỗi hay không lỗi Not Define...) thay đổi (theo ý mà bạn đầu topic đã nói). Nếu tìm được, tức là mình sai (& vice versa). Edit: à, mình hiểu rồi, thực ra bạn nhầm ở chỗ này. Sau break các lệnh nằm ngoài loop (vẫn trong function) CÓ thực thi bạn nhé => biến local của function vẫn còn. Còn sau return thì thoát khỏi function mất rồi, biến global thì mặc định được coi là đã define (theo đặc tả). Cái này chỉ cần anh Hùng nói một câu thì khỏi mất công suy diễn, mong anh Hùng giải đáp, sắp đến deadline rồi ạ."
vanhoa,1,12/8/2011,Testcase,Bạn cứ sửa lại PT để xuất ra dạng như mình đi :)
FirstName LastName,1,12/9/2011,Re:Testcase,"nghe thầy notice về file PT rồi, thấy ko cần sửa file PT j mà ta, h nghe PT tới muốn loạn"
Nhan Nguyen Van,1,12/10/2011,Re:Testcase,function readInt(d: real): real; begin var d : real; return 0; end; => Redeclared Variable: d hayRedeclared Function: readInt? Phải kiểm tra hàm trước rồi mới kiểm tra biến chứ nhỉ?
vanhoa,1,12/10/2011,Testcase,Function bạn.
minhtu nguyen,1,12/13/2011,Testcase,"theo mình nghĩ thì là Variable, bản thân phần khai báo của hàm phải đúng đã nó mới được xem là một Function Declaration, từ đó mới kiểm tra."
Bruce Wayne,1,12/14/2011,Re:Testcase,"Test này: function b(t:integer):integer; begin return 1; end; procedure q(); begin b:=1; end; Output:: Undeclared Identifier: b Đúng ko vậy mọi người Còn nữa: Input: function p(x:integer;y:integer):integer; begin return 0; end; procedure q(); begin p(0,1); end; Output là gì?"
nguyen dung,1,12/14/2011,Re:Testcase,"Nếu trong procedure có return thì báo lỗi Type Mismatch In Statement phải không mấy bạn, trong đặc tả hình như không nói."
Nhan Nguyen Van,1,12/14/2011,Re:Testcase,Testcase 1: function func(): integer; begin var a : integer; if true then a := 0; return 0; end; Testcase 2: function func(): integer; begin while true do begin end return 0; end; Trường hợp function not return Kết quả là gì mọi người?
FirstName LastName,1,12/14/2011,Re:Testcase,"mấy bạn cho hỏi thầy bảo upload file PT.scala rồi nhưng mình vào phần module ko thấy trongassignment2->down lại -> ko thấy assignment 1->down lại->vẫn file cũ Vậy xin hỏi là cái file PT.scala nó nằmởđâu ngoài cái máy mình vậy Nếu có upload rồi, mà vì lý do jđó mình k thấy(quyền hạn thành viên, hoặc là mình cận nặng quá, gà mờ ko thấy), thì bạn nàođó upload lên host nàođóđể mình download với. Cámơn rất nhiều. Bổ sung: vì mìnhđang dùngass1 của mìnhđể sinh test case choass2 , tiện cho việc code, nên cần file này. cámơn"
pham luk,1,12/15/2011,Re:Testcase,"Manchester United wrote: mấy bạn cho hỏi thầy bảo upload file PT.scala rồi nhưng mình vào phần module ko thấy trongassignment2->down lại -> ko thấy assignment 1->down lại->vẫn file cũ Vậy xin hỏi là cái file PT.scala nó nằmởđâu ngoài cái máy mình vậy Nếu có upload rồi, mà vì lý do jđó mình k thấy(quyền hạn thành viên, hoặc là mình cận nặng quá, gà mờ ko thấy), thì bạn nàođó upload lên host nàođóđể mình download với. Cámơn rất nhiều. Bổ sung: vì mìnhđang dùngass1 của mìnhđể sinh test case choass2 , tiện cho việc code, nên cần file này. cámơn mình cũng không thấy file PT mới ở đâu,bạn nào biết thì chỉ giúp"
Thanh Pham Minh,1,12/22/2011,Re:Tổng hợp các câu hỏi?,"Vo Thanh Hung wrote: Câu hỏi: Case h: assign sau break và continue ko tính. Thế sau return có tính ko? Trả lời: assign sau break và continue sẽ không tính, tương tự sau return. Tuy nhiên, các dòng lệnh sau các phần này vẫn sẽ kiểm tra như bình thường (dù assign thì không tính) Em không đồng ý ở điểm này. Nếu assign sau return không tính thì nó đã mâu thuẫn với luật tổng quát hơn và hiển nhiên đúng là: khi dùng một biến, nếu chắc chắn biến đó đã được gán thì không báo Not Defined Before Used nữa. Lấy ví dụ sau: if (true) then begin if (x) then return 0; //(1) a:= 5; //(2) end a:= a;   //(3) Áp dụng luật: ""An local variable must be initialized (by an assignment) before used "". Để cho a được use thì execution path phải đi qua (3), mà đã tới được (3) thì khi đó nó chắc chắn execution path đã đi qua (2). Nếu execution path không đi qua (2) thì chắc chắn nó đã đi qua (1). Và như vậy (3) không xảy ra, nghĩa là a đã không được use, mà không use thì không thể nói Not Defined Before Used. Đây có vẻ (chỉ là có vẻ) là kiểm tra ở mức run-time nhưng thực sự thì ở mức static check hoàn toàn có thể (một cách logic) kiểm tra được việc này rồi. //Eclipse:"
Phúc Trí,1,12/22/2011,Re:Tổng hợp các câu hỏi?,"Câu hỏi: Case h: assign sau break và continue ko tính. Thế sau return có tính ko? Trả lời: assign sau break và continue sẽ không tính, tương tự sau return. Tuy nhiên, các dòng lệnh sau các phần này vẫn sẽ kiểm tra như bình thường (dù assign thì không tính)"
Thanh Pham Minh,1,12/22/2011,Tổng hợp các câu hỏi?,đừng phức tạp hóa vấnđề nữa Thànhơi. Thầyđã nói cái phầnđó thuộc checkunreachable code. Mình không cần làm rồi mà. :)
Minh Nguyen,1,12/22/2011,Re:Tổng hợp các câu hỏi?,@H.T.P (^_^) : theo bạn dòng code nào là unreachable?
Ngan Tuyet,1,12/23/2011,Re:Tổng hợp các câu hỏi?,"Minh Nguyen wrote: Vo Thanh Hung wrote: Kid  wrote: thêm một câu nữa mong thầy giải đáp: Return trong procedure có được phép không? chỗ này trong đặc tả không rõ ràng và dễ hiểu nhầm. Đọc kỹ yêu cầu assignment xem, nếu em muốn báo lỗi thì nó sẽ là lỗi gì? Theo em hiểu trong đề có đặc tả: For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type. Lúc này return statement không xác định được kiểu trả về và báo lỗi Type Mismatch In Statement Đây là cách hiểu của em. Em hiểu đúng vấn đề về đặc tả rồi, bình thường, procedure không trả về sẽ được coi như trả về void, và nếu kiểm tra thì sẽ Type Mismatch In Statement, tuy nhiên, ở trong assignment này mình không cho nó kiểu gì cả, bởi vậy kiểu trả về của nó là không xác định như em nói. Không xác định tức là chưa biết, và vì đề đã bỏ qua không nói bất cứ ràng buộc nào bởi vậy những lỗi như vậy sẽ không kiểm tra. Đây là một trường hợp đơn giản, nhưng còn rất nhiều ràng buộc khác về ngôn ngữ nữa mà chúng ta không làm ở assignemnt này, nếu để viết một compiler thực sự thì sẽ rất nhiều thời gian và công sức. Vì vậy, những ràng buộc mà đề không nói tới dù nhiều ngôn ngữ thực tế có làm, thì các em không nên quan tâm tới"
Minh Nguyen,1,12/23/2011,Tổng hợp các câu hỏi?,"Vậy tóm lại là trong ass 2 này, return trong procedure là ko báo lỗi hay thầy sẽ ko ra testcase như thế ạ!"
Nhan Nguyen Van,1,12/15/2011,Re:Testcase,"Hòa coi lại Test #13 nha Type Mismatch In Statement: <statement> is released. The type rules for statements are as follows: - The type of a conditional expression in an if, or while statement must be boolean. - The type of the expression in a loop statement must be integer. - For an assignment statement, the LHS can be in real, integer or boolean type. The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. In Crazy, just the integer can coerce to the real. Cái này thì chỉ có thể là Variable real, integer hoặc boolean thôi. test 13 gán cho function thì báo lỗi Type Mismatch In Statement: assign(f,add(add(sub(a),times(b,d)),call(f,[1]))) Ko cần check vế phải nữa."
Nhan Nguyen Van,1,12/15/2011,Re:Testcase,"Test 15: proceduretest(a:string);begin end; proceduremain();begin test(1); end; Output phải là chứ Type Mismatch In Statement: call(test,[1]) test(1); là câu lệnh mà"
vanhoa,1,12/15/2011,Testcase,Uhm sr mình sai test 15 :) Test 13 mình nghĩ ý thầy là mình phải kiểm tra lá trong cây phân tích cú pháp trước khi kiểm tra gốc. Mình đã update.
Nhan Nguyen Van,1,12/15/2011,Re:Testcase,Test 35 functionmain():real; begin while1=1do return1; loop1do return1; if1=1thenreturn1; end; => None vay bay gio them 1 dong lenh vao functionmain():real; begin while1=1do return1; loop1do return1; if1=1thenreturn1; var a: real; end; => Ket qua la : "Function Not Return: main" hay la None?
FirstName LastName,1,12/15/2011,Re:Testcase,"proceduremain();begin vara,b,c,d,e:integer; varr,r1,r2:array[10]ofreal; r[r1divr2]:=0; end; Ở test 21 r1 là dạng mảng, nên ko thể dùng cho phép div cho nên trả về sẽ là : Type Mismatch In Expression: idiv(r1,r2) chứ k phải là Not define beforeuse mình nghĩ vậy"
vanhoa,1,12/15/2011,Testcase,Vẫn None bạn.
Vinh Nguyễn,1,12/23/2011,Xin y kien cua a Hung!,ko cần làm => ko có testcase đó chăng???
V For,1,12/23/2011,Re:Xin y kien cua a Hung!,"Vo Thanh Hung wrote: tran ngoc duc wrote: Anh Hung ơi, có 2 ý kiến trái nhau function func(): real; begin var func: real; end; Ý 1: ko lỗi; Ý 2: lỗi. Em thì nghi là ko lỗi. Vậy xin a cho ý kiến, em thấy để sai testcase vì không thống nhất ý kiến thì hơi vô duyên :D Nếu em nào cho rằng trường hợp này lỗi thì chưa nắm vững nội dung lý thuyết rồi, đọc lại lý thuyết và đặc tả. Vậy kết luận KO LỖI. THanks a !!!"
Thanh Cao,1,12/23/2011,Re:Xin y kien cua a Hung!,nếu tính hết tất cả các loại lỗi thì nó vẫn lỗi: function not return
Nguyen Vo,1,12/23/2011,Re:Xin y kien cua a Hung!,Thế thì trường hợp này cùng ko lỗi phải ko procedure b(b: integer); begin end;
Thanh Cao,1,12/23/2011,Re:Xin y kien cua a Hung!,chicken _ wrote: Thế thì trường hợp này cùng ko lỗi phải ko procedure b(b: integer); begin end; procedure b(b: integer); begin var a:real; b(a);  // thế chỗ cái b này nó lấy cái b nào end //còn cái này function main(main: real): real; begin if 10 > 20 then return 10; else return main(12) + 3; //cái main nó lấy cái biến hay lấy hàm end; //nếu lấy biến thì sao đệ quy // còn lấy hàm thì chả lẽ lờ đi cái biến -> Chả lẽ phải làm thêm cơ chế phân biệt hàm và biến
Nguyen Vo,1,12/23/2011,Re:Xin y kien cua a Hung!,"function a():real; begin return 0; end; function func(): real; begin var a,func: real; a:=0; func:=a();//1 return 9; end; Có che đc ko."
Nguyen Vo,1,12/23/2011,Re:Xin y kien cua a Hung!,oh no. Nếu vậy thì có lẽ sẽ gọi hàm chứ không phải gọi biến main. Có lẽ nó sẽ gọi hàm Main. oh No Thầy cho ý kiến cái thầy. Còn vài tiếng deadline mà. hu hu
V For,1,12/23/2011,Xin y kien cua a Hung!,"O_$  wrote: chicken _ wrote: procedure b(b: integer); begin var a:real; b(a);  // thế chỗ cái b này nó lấy cái b nào end //còn cái này function main(main: real): real; begin if 10 > 20 then return 10; else return main(12) + 3; //cái main nó lấy cái biến hay lấy hàm end; //nếu lấy biến thì sao đệ quy // còn lấy hàm thì chả lẽ lờ đi cái biến -> Chả lẽ phải làm thêm cơ chế phân biệt hàm và biến 1/ Lấy b ở trong: Type Mismatch In Statement: call(b,[a]) // dù chổ này a là integer vẫn lỗi. 2/ Lấy main ở trong Type Mismatch In Expression: call(main,[12])"
Sieutoc,1,12/23/2011,Hội những người Crazy.,"Sau Assignment 2 kì này, bạn nào bị assignment làm cho crazy thì vào đây bùng nổ tâm sự cùng với mọi người nhé. Bản thân mình thì thật sự bị crazy rồi, làm xong rồi sửa, sửa xong rồi làm lại, làm lại rồi lại sửa, cứ thế như một vòng lạp while(true) do sửa vậy. Quả thật đúng như tên gọi của nó. Chỉ còn vài tiếng nữa thôi là chúng ta đc giải thoát rồi. Cuối cùng chúc các bạn sẽ gặt hái được thật nhiều testcase nhé."
M.U.,1,12/23/2011,Hội những người Crazy.,"Mai Hoa Đạo  wrote: Sau Assignment 2 kì này, bạn nào bị assignment làm cho crazy thì vào đây bùng nổ tâm sự cùng với mọi người nhé. Bản thân mình thì thật sự bị crazy rồi, quả thật đúng như tên gọi của nó. Chỉ còn vài tiếng nữa thôi là chúng ta đc giải thoát rồi. Cuối cùng chúc các bạn sẽ gặt hái được thật nhiều testcase nhé. vậy bạn có file main.scala để test trên cywin ko, chia sẻ mình với, mình đã đánh liều nộp đại luôn, chua test dc thế nào trên cywin nữa..."
Sieutoc,1,12/23/2011,Hội những người Crazy.,"M.U.  wrote: vậy bạn có file main.scala để test trên cywin ko, chia sẻ mình với, mình đã đánh liều nộp đại luôn, chua test dc thế nào trên cywin nữa... sorry bạn, mình cũng không có test tren cygwin nên không có. Chắc không sao đâu, bạn yên tâm đi."
vo danh,1,12/23/2011,Re:Hội những người Crazy.,haiz làm xong thấy nhức cả dau. ma sao test 65 mình ra khác văn hòa nhĩ thoi nop dai lun
V For,1,12/23/2011,Lỗi utf ???,Theo mình được biết lỗi UTF xay ra khi dùng tiếng việt có dấu. Vậy tại sao mình được nghe nói có 1 bạn bị lỗi UTF ass1 stage2. Bạn đó sửa lỗi bằng cách delete hết tất cả các comment ==> code không thể có dấu và resubmit Nhưng vẫn bị lỗi.?????
Đỗ Sỹ Hưng,1,12/23/2011,Re:Lỗi utf ???,"Bạn thử copy code rồi paste vào Notepad, lưu lại file khác. Trong hộp thoại Save As..., mục Encoding chọn ANSI --> Save. Mở lại file đó rồi copy code vào trình biên dịch coi còn lỗi không?"
Phúc Trí,1,12/23/2011,Thầy cho em hỏi cú chót,"function a():real; begin return 0; end; function func(): real; begin var a,func: real; a:=0; func:=a(); //1 return 9; end; Thầy cho e hỏi biến a có che hàm a() không? Ngay tại câu lệnh số 1 có báo lỗi không. nếu thầy trả lời kịp thì sửa, còn không kịp thì mai mốt cũng biết sai chỗ nào. :D Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block"
Nguyen Vo,1,12/23/2011,Re:Thầy cho em hỏi cú chót,Ko che được. => Ko báo lỗi.
V For,1,12/23/2011,Re:Thầy cho em hỏi cú chót,chicken _ wrote: Ko che được. => Ko báo lỗi. Trong block thì che được chứ bạn. Nhìn thấy khai báo gần nhất là biến a. Nhưng vẫn báo lỗi vì gọi a() là sai!
Huỳnh Trọng Khiêm,1,11/8/2011,Giúp mình xử lý trường hợp này với ,procedure main(); begin a:=1 +- (2); a:=1 *- (2); end; Chỗ "+-" liên tiếp xử lý sao vậy các bạn?
Nhất Tiếu nại Hà,1,11/8/2011,Giúp mình xử lý trường hợp này với ,Lions wrote: procedure main(); begin a:=1 +- (2); a:=1 *- (2); end; Chỗ "+-" liên tiếp xử lý sao vậy các bạn? đọc kỹ đặc tả đi bạn...+- là các toán hạng cung độ ưu tiên
M.U.,1,11/8/2011,Giúp mình xử lý trường hợp này với ,"Lions wrote: procedure main(); begin a:=1 +- (2); a:=1 *- (2); end; Chỗ ""+-"" liên tiếp xử lý sao vậy các bạn? kết quả nè bạn [proc(main,[],[assign(a,add(1,sub(2))),assign(a,times(1,sub(2)))])]"
Huỳnh Trọng Khiêm,1,11/8/2011,Re:Giúp mình xử lý trường hợp này với ,"Mình viết thế này def expr1: Parser[ExprPT] = expr2~rep((""+"" | ""-"") ~ expr2) ^^ { case a ~ lst => (a /: lst) { case (x,""+"" ~ y) => new AddExprPT(x, y) case (x,""-"" ~ y) => new SubExprPT(x, y) } } nó chỉ xử lý được a:=1 + 2; :("
M.U.,1,11/8/2011,Re:Giúp mình xử lý trường hợp này với ,"Lions wrote: Mình viết thế này def expr1: Parser[ExprPT] = expr2~rep((""+"" | ""-"") ~ expr2) ^^ { case a ~ lst => (a /: lst) { case (x,""+"" ~ y) => new AddExprPT(x, y) case (x,""-"" ~ y) => new SubExprPT(x, y) } } nó chỉ xử lý đượca:=1 + 2; :( cái toán tử dấu âm: - ở đây bạn cho độ ưu tiên thấp hơn +|-, và dùng sub 1 ngôi, ví dụ cho bạn dễ hiểu, mình chỉ ví dụ thôi, vì còn độ ưu tiên khác nữa như nhân chia ... rồi mới đến số âm (dấu - 1 ngôi) def expr1: Parser[ExprPT] = expr2~rep((""+"" | ""-"") ~ expr2) ^^ { case a ~ lst => (a /: lst) { case (x,""+"" ~ y) => new AddExprPT(x, y) case (x,""-"" ~ y) => new SubExprPT(x, y) } } def expr2: Parser[ExprPT] = rep(""-"") ~ expr3 ^^ { case lst ~ a => (lst :\ a) { case (""-"", a) => new SubExprPT(a) } } | expr3 Cái này chỉ mang tính chất minh họa, để parse dc cái input trên thôi nhé, bạn bám theo nó là die rất nhìu trường hợp đó"
free_love,1,11/8/2011,Re:Giúp mình xử lý trường hợp này với ,"[proc(main,[],[assign(a,add(1,bnot(2))),assign(a,times(1,bnot(2)))])]"
M.U.,1,11/8/2011,Re:Giúp mình xử lý trường hợp này với ,"free_love  wrote: [proc(main,[],[assign(a,add(1,bnot(2))),assign(a,times(1,bnot(2)))])] trường hợp -2 ở đây ko phài là not đâu bạn, thầy Hùng đã notice roài SubExprPT sử dụng cho toán tử trừ, bao gồm cả 1 ngôi vd: -2, hay 2 ngôi vd: 2-3"
baran,1,11/8/2011,"Gấp gấp, các bạn giúp mình với, đây là code mình bị lỗi giải thuật chỗ nào vậy?","def expr: Parser[ExprPT] = (expr1) ~ rep((""+"" | ""-"") ~ expr1) ^^ { case a ~ lst => (a /: lst) { case (x, ""+"" ~ y) => new AddExprPT(x, y) case (x, ""-"" ~ y) => new SubExprPT(x,y) } } // code sua them vao ham not and or + - * / def expr1: Parser[ExprPT] = expr2 ~ rep((""*""|""/""|""div""|""mod"") ~expr2) ^^ { case a ~ lst => (a /: lst) { case (x, ""*"" ~ y) => new TimesExprPT(x,y) case (x, ""/"" ~ y) => new RdivExprPT(x,y) case (x, ""div"" ~ y) => new IdivExprPT(x,y) case (x, ""mod"" ~ y) => new ImodExprPT(x,y) } } def expr2: Parser[ExprPT] = expr3 ~ rep((""=""|""<>"")~expr3) ^^ { case a ~ lst => (a /: lst) { case (x, ""="" ~ y) => new EqlExprPT(x,y) case (x, ""<>"" ~ y) => new NeExprPT(x,y) } } def expr3: Parser[ExprPT] = expr4 ~ rep(("">""|"">=""|""<""|""<="") ~ expr4) ^^ { case a ~ lst => (a /: lst) { case (x, "">"" ~ y) => new GreaterExprPT(x,y) case (x, "">="" ~ y) => new GeExprPT(x,y) case (x, ""<"" ~ y) => new LessExprPT(x,y) case (x, ""<="" ~ y) => new LeExprPT(x,y) } } def expr4: Parser[ExprPT] = expr5 ~ rep(""or"" ~ expr5) ^^ { case a ~ lst => (a/: lst) { case (x, ""or"" ~ y) => new BorExprPT(x,y) } } def expr5: Parser[ExprPT] = expr6 ~ rep(""and"" ~ expr6) ^^ { case a ~ lst => (a /: lst) { case (x, ""and"" ~ y) => new BandExprPT(x,y) } } def expr6: Parser[ExprPT] = (opt(""not""|""-"") ~ expr7) ^^ { case None ~ a => a case Some(""not"") ~ a => new BnotExprPT(a) case Some(""-"") ~ a => new SubExprPT(a) } def expr7: Parser[ExprPT] = intLiteral | realLiteral |stringLiterals | arrayLiteral | booleanLiteral | variable | arrayVariable | const |""("" ~> expr <~ "")"" // sao mình thực hiện hàm procedure thì cho này ko parse được vậy: v7:=not 1 and 2 or 3 and not not not not 4; mà nó baó lỗiline 3:30: unexpected token: not"
M.U.,1,11/8/2011,"Re:Gấp gấp, các bạn giúp mình với, đây là code mình bị lỗi giải thuật chỗ nào vậy?","cái phép toán not | - bạn lặp lại nhìu lần nhưng ở hàm bạn viết thì chỉ tồn tại hay ko, ko thể hiện việc lặp đi lặp lại nên die ngay cái not thứ 2"
baran,1,11/8/2011,"Re:Gấp gấp, các bạn giúp mình với, đây là code mình bị lỗi giải thuật chỗ nào vậy?",pan co the goi y them cho minh dc ko :)
M.U.,1,11/8/2011,"Re:Gấp gấp, các bạn giúp mình với, đây là code mình bị lỗi giải thuật chỗ nào vậy?",baran  wrote: pan co the goi y them cho minh dc ko :) thay opt bằng rep
free_love,1,11/8/2011,them test cho may pro thu suc !,procedure main(); begin kingoff(foo(fal(li(lee[1 + f[a]])))); a := b[f(c[i])]; end;
M.U.,1,11/8/2011,them test cho may pro thu suc !,"[proc(main,[],[call(kingoff,[call(foo,[call(fal,[call(li,[ele(lee,[add(1,ele(f,[a]))])])])])]),assign(a,ele(b,[call(f,[ele(c,[i])])]))])]"
LAV,1,11/8/2011,them test cho may pro thu suc !,"[proc(main,[],[call(kingoff,[call(foo,[call(fal,[call(li,[ele(lee,[add(1,ele(f,[a]))])])])])]),assign(a,ele(b,[call(f,[ele(c,[i])])]))])]"
free_love,1,11/8/2011,Re:them test cho may pro thu suc !,hay wa ! ^^ procedure main(); begin kingoff(foo(fal(li(lee[1 + f(a)])))); a := b[f(c[i])]; end;
M.U.,1,11/8/2011,Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,"function testStruct(): boolean; begin loop 1 do begin a:=1; b:=2; break; end ; end; procedure main(); begin fill(a); end; có dấu ; ngay sau end của loop Việc ko có dấu ; parse dc thì ko nói gì, nhưng việc có dấu ; này ko bít paser dc ko ta còn trường hợp này: var a:integer ;; ko bít parse dc ko Thanks all."
Thanh Pham Minh,1,11/8/2011,Testcase cuối cùng.,Input: procedure theLastTest(henxui: boolean); begin 'full_string expected but but_only_part_found // /* found */'; end; Output: line 3:1: unexpected token: 'full_string expected but but_only_part_found // /* found */'
Sieutoc,1,11/8/2011,Re:Testcase cuối cùng.,zz Chỗ này cố tình bẫy cái def show đây mà. procedure theLastTest(henxui: boolean); begin 'identifier ab'; end;
M.U.,1,11/8/2011,Re:Testcase cuối cùng.,"thanks bạn testcase này, mém tý nữa die lun sửa cái này, dính chuỗi khác, thui potay :<"
Sieutoc,1,11/8/2011,Re:Testcase cuối cùng.,assignment kì này sôi nổi quá nhỉ. Số lượng topic đến hơn 1000. Bây giờ thì mọi người dc nghỉ ngơi rồi.
Huỳnh Trọng Khiêm,1,11/8/2011,Re:Testcase cuối cùng.,Không biết ass2 có liên quan tới stage 2 này ko ta? stage này sai từa lưa hết à :(
facebook.com,1,11/8/2011,Testcase cuối cùng.,Bị chậm vài giây. đau quá!!!
Thanh Pham Minh,1,11/8/2011,Testcase cuối cùng.,Test này không thuộc trọng tâm của bài tập nên cũng có thể thầy sẽ không test. :D
Thanh Pham Minh,1,11/8/2011,Re:Testcase cuối cùng.,"Phan Nguyen wrote: Trong thời điểm hiện tại, đừng ai chơi dại bấm nút resubmit thêm cái nữa, nếu không thì ...( tự biết hậu quả đê), mà nếu lõ tay kiểu đó thì bị trự bi nhiêu vậy các bác? Đúng 4:00:00pm mình kiểm tra thì đã khóa submit rồi mà bạn. Hay bạn load trang đó trước rồi đến sau deadline mới bấm submit?"
vua doi bom,1,11/8/2011,Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,var a:integer;; line 1:15: unexpected token: ;
free_love,1,11/8/2011,Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,"co dau ; ko parse ban ah ; = <eof> ,có cáiđó là kết thúc 1 cấu trúc gọi từ program xuống,nhưng beginở trên vẫn chưa có ead lên báo lỗi ;"
M.U.,1,11/8/2011,Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,"free_love  wrote: co dau ; ko parse ban ah ; = ,có cáiđó là kết thúc 1 cấu trúc gọi từ program xuống,nhưng beginở trên vẫn chưa có ead lên báo lỗi ; bạn nói trường hợp 1 hay 2?"
free_love,1,11/8/2011,Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,trường hợp 1...begin chưa có end lên chưa có <eof> dc
vua doi bom,1,11/8/2011,Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,truong hop 1: line 7:4: unexpected token: ;
M.U.,1,11/8/2011,Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,"trường hợp 1 có thể hiểu dc do trong statement thì ko có ; sau end Nhưng còn trường hợp 2, khai báo, và kết thúc bằng 1 loạt dấu ;"
free_love,1,11/8/2011,Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,trường hợp 2 cũng dễ hiểu thôi...đấu ;đầu tiên là kết thúc của cấu trúc var...khi bắtđầu cấu trúc mới gặp ngay ; nữa mà ko có cấu trúc nào như vậy lên báo lỗi thôi...thân
M.U.,1,11/8/2011,Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,"free_love  wrote: trường hợp 2 cũng dễ hiểu thôi...đấu ;đầu tiên là kết thúc của cấu trúc var...khi bắtđầu cấu trúc mới gặp ngay ; nữa mà ko có cấu trúc nào như vậy lên báo lỗi thôi...thân thanks bạn, vì mình ko thấy đặc tả ghi rõ về ; , mình nghĩ trong các ngôn ngữ khác thì dấu ; sau khai báo bao nhiu lần cũng dc nên hỏi cho chắc cú."
Sieutoc,1,11/8/2011,Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!!,M.U.  wrote: function testStruct(): boolean; begin loop 1 do begin a:=1; b:=2; break; end ; end; procedure main(); begin fill(a); end; line 7:4: unexpected token: ; M.U.  wrote: var a:integer ;; line 1:15: unexpected token: ;
Sieutoc,1,11/8/2011,Re:Testcase cuối cùng.,Sao mình resubmit quá trời mà cái này ko có gì thay đổi nhỉ. Number of resubmissions allowed: 10
facebook.com,1,11/8/2011,Testcase cuối cùng.,
Long Nguyễn,1,11/25/2011,TO DO trong Utils.scala,"Đề yêu cầu chỉ nộp file StaticChecker.scala, nhưng trong file Utils.scala lại có mấy dòng //TO DO... Vậy mấy dòng này chỉ để chơi vậy thôi chứ tụi em đâu cần làm gì phải không thầy?"
Tin Bui,1,11/25/2011,Re:TO DO trong Utils.scala,"Theo em thấy: Như những lần ass trước thì chỉnh sửa trongfile nào thì thường có những ghi chú nhỏ về vị trí chỉnh sửa trong file đấy, nếu kì này làm trong file StaticChecker.scala mà ko có ghi chú thì có vẻ khó cho người mới bắt đầu :(("
LAV,1,12/11/2011,Unary expression!,"Thầy cho em hỏi, cái unary expression có type rule làPrimitiveType(""boolean"") giống NOT phải không thầy. Trong Ass1 Spec thầy chỉ ghi chú cho dấu trừ thôi, còn unary em không thấy! Cảm ơn thầy!"
FirstName LastName,1,12/14/2011,Re:Unary expression!,"The keyword boolean denotes a boolean type. The following operators accept their operands in boolean type: = <> not and or The keyword integer is used to represent an integer type. Integer values can be operands of the following operators: div mod + - * / < <= > >= = <> ^ The keyword real represents a real type. The operands of the following operators can be in real type: + - *  /  < <= >  >= In general, the operands of an operator must be in the same type. However, for + - * /, their operands can be in mixed types: integer and real. In this case, the integer operand will automatically be converted into real type. ----------------------------------- not, and, or, >, <, >=, <=, <>, = => boolean div, mod, ^ => integer +, - ,* => integer if both operands are integers, otherwise real. / => real ------------------------------- Đoạn 1 là các phép toán của các toán hạng đoạn 2 là các kiểu trả về của các toán tử"
V For,1,12/17/2011,chạy thử test!,"var global : boolean; procedure tmp(); begin var tmp1: integer; tmp1 := - 'd'; end; [var(global,boolean),proc(tmp,[],[var(tmp1,integer),assign(tmp1,sub('d'))])] output là j nhỉ ?"
Nguyen Vo,1,12/17/2011,Re:chạy thử test!,Type Mismatch In Expression: sub("'d'")
Forever Alone,1,12/14/2011,Cannot Assign To Constant,"Anh Hùng ơi cho em hỏi là trong phần này thì chỗ <statement> mình sẽ xuất ra theo nguyên mẫu input hay xuất ra theo cây cú pháp ạ? Vd : const d = 10; var a : integer; begin d := a; end; Vậy thì sẽ báo lỗi là : Cannot Assign To Constant: d := a hay là Cannot Assign To Constant :Assign(Id(d),Id(a)) Em cảm ơn."
Phúc Trí,1,12/14/2011,[da xu ly]lỗi trong file Util.scala. Mong anh Hùng xem lại giúp,"E đã chỉnh sửa trong file PTđể rađúngđịnh dạng trongIntermediateCrazyParser là các phần tử củaarray ngăn cách nhau bởi dấu phẩy. quađược cái IntermediateCrazyParser thìđếnASTGenerator lại bị lỗi ngay cái hàm def lit(item: Item): Literal . hình như bị lỗiở case Term(""array"", List(ItemList(lits))) => ArrayLit(lits.map(lit _)) VD: const x=[9;8]; Mong anh Hùng xem lại, updateđể tụi e còn làm sớm, sắp deadline rồi"
nguyen dung,1,12/15/2011,Re:lỗi trong file Util.scala. Mong anh Hùng xem lại giúp,"Chắc bạn sửa chưa hết cái PT rồi mình chạy bt : Program(List(Const(x,ArrayLit(List(IntLit(9), IntLit(8)))))) Bạn xemArrayLiteralPT trong PT có xuất ra thế này không override def toString = ""array"" +""(["" + (if (!ele.isEmpty) (ele.head.toString /: ele.tail)(_ + "","" + _) else """") + ""])"""
Phúc Trí,1,12/15/2011,Re:lỗi trong file Util.scala. Mong anh Hùng xem lại giúp,được rồi. cảm ơn Dung.
Nhat Nguyen,1,12/16/2011,[da xu ly]lỗi trong file Util.scala. Mong anh Hùng xem lại giúp,Mình cũng bị lỗi như zậy ? Bạn sửa sao vậy ?
Bruce Wayne,1,12/16/2011,Phần tử của mảng,Trong đặc tả có nói phần tử của mảng đánh chỉ số từ 0. Vậy test sau báo lỗi gì vậy mọi người: function p():integer; begin var a:array[2] of integer; a[-1]:=1; return 1; end;
nguyen dung,1,12/16/2011,Re:Phần tử của mảng,"Trong đặc tả cũ có ghi :The first index of a dimension is 0 Còn cái đặc tả mới : For an array subscripting A[E1,E2,...,En], A must be declared as an n-dimensionarray and the type of all Ei must be integer. Trong typeof có đoạn check !indexes.forall(typeof(_, symbols,declare) == PrimitiveType(""integer"") mà -1 ->PrimitiveType(integer). Vậy chỉ số mảng ở đây có được âm không ? Nếu index >=0 thì sẽ phải tính cái expr, khá mắc công ----------- Mấy bạn chạy thử VD này: procedure main(); begin var x : array[3] of integer; const y = 7; x[a(y) + b()] := 1; end; function a(y: integer):integer; begin y:= y-10; return y-1; end; function b():integer; begin return -8; end;"
Phúc Trí,1,12/15/2011,Re:Cannot Assign To Constant,"Type Mismatch In Statement: assign(x,a). bạn cứ gọi hàm report của thầy làđược. thầyđã xử lýđịnh dạng xuất rồi."
V For,1,12/15/2011,Re:Cannot Assign To Constant,"H.T.P (^_^)  wrote: Type Mismatch In Statement: assign(x,a). bạn cứ gọi hàm report của thầy làđược. thầyđã xử lýđịnh dạng xuất rồi. Ở đâu vậy bạn, bài cua mình thì mình tự làm : report(""Cannot Assign to Constant: assign("" + left.item + "","" + right.item + "")""); ????"
Vu Dang,1,12/15/2011,Re:Cannot Assign To Constant,"H.T.P (^_^)  wrote: Type Mismatch In Statement: assign(x,a). bạn cứ gọi hàm report của thầy làđược. thầyđã xử lýđịnh dạng xuất rồi. i think so ^ ^"
V For,1,12/15/2011,Re:Cannot Assign To Constant,"ass2  wrote: H.T.P (^_^)  wrote: Type Mismatch In Statement: assign(x,a). bạn cứ gọi hàm report của thầy làđược. thầyđã xử lýđịnh dạng xuất rồi. i think so ^ ^ làm sao vậy bạn ! ???"
Phúc Trí,1,12/15/2011,Re:Cannot Assign To Constant,trong file staticcheck có sẵn 3 hàm report rồi mà. bạnđọc 3 hàmđóđi là hiểu
abc,1,12/15/2011,Re:Cannot Assign To Constant,"ok đã sửa được, xóa"
.duc hoang,1,11/24/2011,Làm sao để chạy thử test???,Để chạy thử test làm thế nào mọi người???
Nguyen Vinh,1,11/24/2011,Re:Làm sao để chạy thử test???,Anh Hùng cho em hỏi input là testcase của thầy hay kết qủa chấm ass1 vậy???
Sieutoc,1,12/16/2011,Khai báo đè,Các bạn ơi trong cái block thứ 2 có phải là x đã bị đè rồi không ? procedure main(); begin var x: integer; begin const x = 3; end; end;
Đặng Toàn Trí,1,12/17/2011,Type!!!!,Các đồng chí cho mình hỏi test này: function a(): real; begin end; procedure main(); begin var a : integer; var x : real; x = a(); end; Có lỗi hay không nhỉ? :D
n0b0dy,1,11/25/2011,Làm sao để chạy thử test???,Nếu là Ass 1 thì những ng làm ass1 fail như mình chết à @__@
n0b0dy,1,12/1/2011,Làm sao để chạy thử test???,Đến bây giờ vẫn chưa thấy file PT của thầy :)
Quái,1,12/1/2011,Re:Làm sao để chạy thử test???,Cứ xài tạm file PT của mình vậy... Mà với file PT của mình thì cái phần Redeclare có vẻ đúng cả rồi ;))
M.U.,1,12/5/2011,Re:Làm sao để chạy thử test???,"mình add file PT của ass1 vào, chạy file main hay làm sao vậy bạn."
Quái,1,12/5/2011,Re:Làm sao để chạy thử test???,"mình lấy cái input như là assignment1 á, rồi parse ra được cái output (out put này của Assignment 1 nè). Rồi sau đó chạy file main.scala , nhập input vào console ở dưới, nhần Ctrl + Z  ....."
M.U.,1,12/5/2011,Re:Làm sao để chạy thử test???,"Rec4rx  wrote: mình lấy cái input như là assignment1 á, rồi parse ra được cái output (out put này của Assignment 1 nè). Rồi sau đó chạy file main.scala , nhập input vào console ở dưới, nhần Ctrl + Z  ..... cám ơn Rec4rx nhìu nha."
Tin Bui,1,12/5/2011,Re:Làm sao để chạy thử test???,"Rec4rx  wrote: mình lấy cái input như là assignment1 á, rồi parse ra được cái output (out put này của Assignment 1 nè). Rồi sau đó chạy file main.scala , nhập input vào console ở dưới, nhần Ctrl + Z  ..... Cho mình hỏi là vậy có cần phải test đúng all case của ass1 thì ass2 mới có thể đúng hết, vì như bạn nói thì với 1 cái input ass1 phải đúng 100% mới parse đc cái cây đề làm input cho ass2, => vậy ass1 mà điểm ko cao là ass2 cố mấy cũng an phận dưới trung bình??? ;(( Hay là thây sẽ cung cấp hẳn 1 cái output ( hay parsetree) của ass1 lun, mình chỉ cần bỏ vào input của ass2 để làm thôi ( vậy điểm ass2 sẽ ko ảnh hưởng ass1) Em đã Đọc mục Notice rồi mà vẫn ko hiểu, mong mọi người chỉ rõ để mình còn định hướng"
Quái,1,12/5/2011,Re:Làm sao để chạy thử test???,"à, Phần này thầy có nói, bạn có thể tham khảo source của bạn nào mà assignment 1 được full để chạy. Vì file assigngment 1 chỉ là công cụ tạo testcases cho assignment 2, sẽ không được chấm và cũng sẽ ko bị coi là copy... Riêng về file PT.scala thầy sẽ sớm up lên để chúng ta có input cho đúng ""chuẩn""..."
Vu Dang,1,12/16/2011,Khai báo đè,"Mai Hoa Đạo  wrote: Các bạn ơi trong cái block thứ 2 có phải là x đã bị đè rồi không ? procedure main(); begin var x: integer; begin const x = 3; end; end; trường hợp của bạn thì x bị đè. nhưng không phải là x trong block thứ 2. vd: procedure main(); begin var x: integer; begin const x = 3; x:=8; end; end; dong màu xanh đó, x sẽ được hiểu là const x."
Sieutoc,1,12/17/2011,Re:Khai báo đè,Cảm ơn bạn
kid_ chem_ gio,1,12/17/2011,Type!!!!,"nếu mặc định xài hàm lookup của thầy. Type Mismatch In Expression: call(a,[])"
Sieutoc,1,12/17/2011,Re:Type!!!!,line 9:8: unexpected token: =
FirstName LastName,1,12/17/2011,Re:Type!!!!,"Function not return nếu k check lỗi này thìType Mismatch In Expression: call(a,[])"
Phúc Trí,1,12/16/2011,Re:Làm sao để chạy thử test???,"Guest User wrote: Anh Hùng hoặc bạn nào có thể gửi lại cho mình file PT.scala để mình kiểm tra BT lớn 2 được không ? Mình đang làm luận văn nên cần kết thúc BTL2 sớm, cảm ơn anh và các bạn nhiều Share cho bạn: dl.dropbox.com/u/5754896/PT.rar"
Phúc Trí,1,12/17/2011,Re:Làm sao để chạy thử test???,"Guest User wrote: Cảm ơn bạn nhiều, không hiểu sao mình đăng nhập rồi mà vẫn là ""Guest User"" nữa ? up lại cho bạn: www.mediafire.com/"
3N,1,12/18/2011,Khi array là tham số  của hàm,""" In the case that the argument is an array, the corresponding parameter must be in the array type with the same number of dimension, same size of each dimension. The element type of the argument array must be either the same as or coercible to the element type of the parameter array. "" ""The type of all elements of an array must be the same . "" Như vậy là, nếu một phần tử của mảng bị ép kiểu nghĩa là tất cả còn lại đều phải bị ép kiểu không? Và trong trường hợp nó không đóng vai trò là tham số thì không được phép ép kiểu!"
Bruce Wayne,1,12/18/2011,Khi array là tham số  của hàm,"Mình nghĩ là kiểu của các phần tử trong một mảng luôn phải giống nhau dù là tham số của hàm hay không, khi đó kiểu của mảng sẽ là kiểu của các phần tử và ép kiểu ở đây là ép kiểu cho cả một mảng chứ ko phải cho từng phần tử."
minhtu nguyen,1,12/18/2011,Báo lỗi thế nào ???,"input: procedure main(); begin pr(1,2,3); end; procedure pr(x: integer; x: real; y: integer); begin end; có phải là Redeclared Parameter: x"
Bruce Wayne,1,12/18/2011,Báo lỗi thế nào ???,procedure p(); begin end; procedure p(); begin var a:integer; var a:real; end; Báo lỗi redeclared function hay redeclared variable vậy mấy bạn!
Bruce Wayne,1,12/18/2011,Báo lỗi thế nào ???,procedure p(); begin a:=true;     //( 1) end; var a:array[0] of integer;     //( 2) Báo lỗi Type mismatch ở dòng (1) hay Size is not zero ở dòng (2)
minhtu nguyen,1,12/18/2011,biến có thể khai báo nằm sau câu lệnh gọi nó được không?,với input này thì có báo lỗi không: procedure main(); begin x := 100; var x: integer; end;
Forever Alone,1,12/18/2011,Re:biến có thể khai báo nằm sau câu lệnh gọi nó được không?,"Báo lỗi : Undeclared Identifier: x Bạn đọc kĩ đặc tả có nói ở đây : The scope of a global variable: the entire program. The scope of a variable in a block (i.e., local variable): from the point where it is declared to the end of the block."
minhtu nguyen,1,12/18/2011,Re:biến có thể khai báo nằm sau câu lệnh gọi nó được không?,"thank bạn, mình cứ tưởng giống hàm và thủ tục"
Sieutoc,1,12/18/2011,Size Must Be Integer,Các bạn ơi trong đặc tả không có nói đến thông báo lỗi này: Size Must Be Integer Mà lỗi này mình nghĩ nó nằm trong phần Expression vậy mình có nên sửa lại thành: Type Missmatch In Expression hay vẫn giữ nguyên như của thầy.
Phúc Trí,1,12/18/2011,Re:Size Must Be Integer,Sẽ không có trường hợpđó xảy rađâu bạn. Vìở phần Parse tree mìnhđã bắt buộc nó là Integer rồi
Sieutoc,1,12/18/2011,Re:Size Must Be Integer,àh thì ra là vậy. Cảm ơn bạn
Nhan Nguyen Van,1,12/8/2011,câu lệnh Return ,"Thấy cho em hỏi. Trong đặc tả có đoạn như thế này: For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . For an assignment statement, the LHS can be in real, integer or boolean type . The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. In Crazy, just the integer can coerce to the real. Vậy nếu xem kiểu trả về như là một LHS thì kiểu trả về chỉ có thể là real, integer hoặc boolean. Không được trả về kiểu string hay array đúng không ạ? For a call statement, the callee must be in procedure type and the number of arguments must be equal to that of callee parameters. In addition, for parameter passing, the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS. Tương tự, parameter có thể là kiểu string không?"
Phúc Trí,1,12/15/2011,Re:câu lệnh Return ,Cũngđang thắc mắc cái này.
Phúc Trí,1,12/15/2011,Re:câu lệnh Return ,đọc lại mới thấy trongđặc tảass1 thì parameter có thể là kiểu String vàarray. ass2 lại ko cho truyền tham số kiểu String???? Bây h chẳng biết làm theo cái nào.Cáiđề mập mờ quá. Mong thầy sớm giải thíchđể còn biết mà sửa. :(
3N,1,12/17/2011,câu lệnh Return ,"Cho mình hỏi, câu lệnh return chỉ xuất hiện khi viết một function thôi đúng không bạn,  xem thử 3 vd này function main2(): integer; begin return false; end; procedure main(); begin return 9; end; procedure main(); begin if (true) then return false; end; Có phải cả 3 câu return đều sai hết đúng không?"
Sieutoc,1,12/17/2011,Re:câu lệnh Return ,"Đúng thật là assignment 2 spec ko có nói gì đến string hay array. Mình cũng có một lỗi không biết là do PT.scala hay code của mình nữa, có ai gặp lỗi này như mình chưa? procedure main(a:string); begin a:='maihoadao'; end Cứ mỗi lần mình gán một biến string thì chương trình hoàn toàn không chạy được. Ngay cả AST cũng chưa được sinh ra."
Sieutoc,1,12/17/2011,Re:câu lệnh Return ,"Mình có một cách hiểu câu lệnh return như thế này: Cũng giống như break và continue phải nằm loop và while vậy, return phải nằm trong một function nào đó. Tuy đặc tả không nói, nhưng mình thấy return cũng có họ hàng bà con xa với break và continue vậy. ^^"
Sieutoc,1,12/18/2011,Re:câu lệnh Return ,Kid  wrote: @mai hoa dao: bạn dùng ass1 để parser hả? sửa lại chỗ string thêm dấu " vào đầu và cuối chuỗi thử . mình sửa lại vậy và chạy dc Cảm ơn bạn @Kid. Cuối cùng nó đã chạy được.
minhtu nguyen,1,12/14/2011,Thứ tự kiểm tra,"với đoạn chương trình sau thì sẽ báo Redeclared Variable: x hay Redeclared Procedure: readInt , mong thầy trả lời giúp em. procedure readInt(x: real); begin var x : integer; return 0; end;"
Phúc Trí,1,12/15/2011,Re:Thứ tự kiểm tra,Redeclared Procedure: readInt đó bạn.
Phúc Trí,1,12/15/2011,Re:Thứ tự kiểm tra,"Thầy cho em hỏi luôn thứ tự check của toàn bộ chương trình. việc kiểm tra và báo lỗi sẽ theo thứ tự các câu lệnh trong cấu trúc chương trình input hay theo thứ tự trong fileđặc tả. VD: procedure proc(y:integer;j:integer); begin var h:real; h:=true; var h:integer; end; thì sẽ báo lỗi Type Mismatch In Statement:assign(h,true) hay là RedeclaredVariable: h"
FirstName LastName,1,12/15/2011,Re:Thứ tự kiểm tra,"Type Mismatch In Statement:assign(h,true)"
Phúc Trí,1,12/16/2011,Re:Thứ tự kiểm tra,"var x:boolean; procedure proc(y:integer;j:integer); begin var a:integer; x:=a-true; end; Type Mismatch In Expression: sub(a,true) hay Not Defined Before Used: a Mình muốn biết thứ tựưu tiên 1 cách tổng quát mà chưathấy thầy trả lời."
Bruce Wayne,1,12/16/2011,Thứ tự kiểm tra,"function p():integer; begin const a=1; a:=b; end; Báo lỗi: Cannot Assign To Constant: Assign(Id(a),Id(b)) hay là: Undeclared Identifier: b"
Bruce Wayne,1,12/16/2011,Re:Thứ tự kiểm tra,"Kid  wrote: Cannot Assign To Constant: assign(a,b) , không phải Cannot Assign To Constant: Assign(Id(a),Id(b)) đâu nhé, cẩn thận đó bạn :D Ui! Thanks bạn, giờ mới để ý"
Thanh Pham Minh,1,12/16/2011,Re:Thứ tự kiểm tra,"Cannot Assign To Constant: Assign(Id(a),Id(b)) đâu nhé, cẩn thận đó bạn :D"
Phúc Trí,1,12/16/2011,Re:Thứ tự kiểm tra,"H.T.P (^_^)  wrote: Mình muốn biết thứ tựưu tiên 1 cách tổng quát mà chưathấy thầy trả lời. Trích đặc tả: One program have maximum 1 semantic error. Nên thứ tựưu tiên không quan trọng nữa. Ngoài ra: <statement>, <expression>, <declaration> (c, d, e, f) is in parse tree format . :) Mình thấy lần này thầy dứt khoát không trả lời các câu đặc tả đã nói. Nên chúng ta rút kinh nghiệm nếu không thấy thầy trả lời thì phải xem lại thôi :p"
Thanh Pham Minh,1,12/16/2011,Re:Thứ tự kiểm tra,"mình check 1 cách tuần tự trên xuống dưới à. nếu 1 dòng có 2 lỗi thì báo lỗi nào.như VD này: var x:boolean; procedure proc(y:integer;j:integer); begin var a:integer; x:=a-true; end; Type Mismatch In Expression: sub(a,true) hay Not Defined Before Used: a"
Phúc Trí,1,12/17/2011,Re:Thứ tự kiểm tra,@ H.T.P (^_^): chương trình có TỐI ĐA MỘT lỗi. Nghĩa là cho dù một dòng hay bảy mươi lần bảy dòng cũng chỉ có tối đa một lỗi.
Thanh Pham Minh,1,12/17/2011,Re:Thứ tự kiểm tra,"H.T.P (^_^)  wrote: Vậy câu "" One program have maximum 1 semantic error, your program will be stopped after found first error."" có nghĩa là 1 chương trình có thể có nhiều dòng có lỗi, nhưng tất cảđều cùng 1 loại (về ngữ nghĩa). Nên gặp dòngđầu tiên là báo lỗi ngay dòngđó vàexit. Mình hiểu vậy cóđúng chưa nhỉ? Tùy theo cách đếm ""semantic error"". Mình không chắc lắm nhưng mình nghĩ là có hơi thừa chữ ""first"". Nhưng nếu không thừa thì cách hiểu có bạn khá hợp lý :D"
Phúc Trí,1,12/17/2011,Re:Thứ tự kiểm tra,Input 1: procedure a() begin end; procedurea () //1 begin var b:real; var b:real;//2 end; báo lỗi ở 1 hayở 2. input 2: procedurea () /1 begin var b:real; var b:real;//1 end; procedure a()//2 begin end; báo lỗi ở 1 hayở 2.
Thanh Pham Minh,1,12/17/2011,Re:Thứ tự kiểm tra,"@H.T.P (^_^): One program have maximum 1 semantic error, your program will be stopped after found first error. Mình vẫn nghĩ rằng chỉ có một lỗi, chứ không phải nhiều lỗi mà cùng một loại. Hơn nữa ""stopped after found first error"" phụ thuộc vào cách mỗi người xử lý mà cái nào found trước found sau, khác với ""stopped after the first error"" chỉ phụ thuộc vào source code. Nên cũng theo mình nghĩ, sẽ không có hai ví dụ bạn đưa ra ở trên (trong bộ testcase của thầy)."
Phúc Trí,1,12/17/2011,Re:Thứ tự kiểm tra,"Thanh Pham Minh wrote: @H.T.P (^_^): One program have maximum 1 semantic error, your program will be stopped after found first error. Mình vẫn nghĩ rằng chỉ có một lỗi, chứ không phải nhiều lỗi mà cùng một loại. Hơn nữa ""stopped after found first error"" phụ thuộc vào cách mỗi người xử lý mà cái nào found trước found sau, khác với ""stopped after the first error"" chỉ phụ thuộc vào source code. Nên cũng theo mình nghĩ, sẽ không có hai ví dụ bạn đưa ra ở trên (trong bộ testcase của thầy). Hy vọng như thế."
Phúc Trí,1,12/17/2011,Thứ tự kiểm tra,CHỜ THẦY XÁC NHẬN 1 CÁI CHO YÊN TÂM. Vì chấm theo solution của thầy và testcase khôngđược công bố nên có sai cũng chẳng biết sai chỗ nàođể màý kiến
TAM NGOC,1,12/18/2011,Re:Thứ tự kiểm tra,[deleted]
Sieutoc,1,12/18/2011,Re:Thứ tự kiểm tra,"procedure pleaseTellMeWhy(); // (1) begin h:=true; var h:boolean; end; -------------------------------------------------------- procedure pleaseTellMeWhy(); // (2) begin var h:real; h:=true; var h:boolean; end; Type Mismatch In Statement:assign(h,true) hay là RedeclaredVariable: h Mình có một mâu thuẫn là: (1) thì chắc chắn không báo lỗi. Vì trước khi kiểm tra phép gán StaticCheck sẽ tìm xem biến h đã được khai báo hay chưa. Nếu chưa thì báo lỗi: Undeclared Identifier: h (2) Nếu theo như cách StaticCheck kiểm tra trong đoạn chương trình (1) của mình ở trên. Thì (2) sẽ báo lỗi: Redeclared Variable: h Cuối cùng ý mình muốn nói là khi vào kiểm tra một block thì điều đầu tiên là StaticCheck sẽ làm là kiểm tra các khai báo rồi xem chúng có bị Redeclared hay không, sau đó mới kiểm tra các statement. Hay là StaticCheck kiểm tra lỗi từ trên xuống, thấy chỗ nào là bụp chỗ đó liền."
Sieutoc,1,12/18/2011,Re:Thứ tự kiểm tra,"Còn trường hợp này thì sao? procedure why(); begin var a: array[3,3,3] of integer; a[1,8,1]:= c end; => Undeclared Identifier:<> hay Type Missmatch In Statement: <>"
Sieutoc,1,12/18/2011,Re:Thứ tự kiểm tra,Mình hiều nhầm biến h là local var chứ không phải global var. ^^
Sieutoc,1,12/18/2011,Re:Thứ tự kiểm tra,"Assignment này nhiều mâu thuẫn quá. Ngay cả trong gin code của thầy cũng đã có mâu thuẫn. Cách thầy checkUnique trong Program thì đi từ trên xuống, chỗ nào Redeclared thì bụp chỗ đó liền. Còn khi checkUnique trong Function hoặc Procedure thì thầy lại gom các Var lại rồi check 1 lần sau đó thì mới check đến các phần trong block. ... checkUnique(paramSymbols2 ++ varConstSyms(getVarConst(body.body), symbols)) checkBlock(body, paramSymbols2 ++ symbols, false) ..."
Vu Dang,1,12/18/2011,định dạng output!,"A statement must conform the corresponding type rules for statements, otherwise the error message Type Mismatch In Statement : <statement> - The type of a conditional expression in an if , or while statemen t must be boolean. - The type of the expression in a loop statement must be integer. <statement> ở đây sẽ đình dạng xuất ra thế nào các bác? vd: procedure main(); begin if 1 then begin var a: string; a:= 'ass'; end end; output = ???"
Sieutoc,1,12/18/2011,Re:định dạng output!,"Type Missmatch In Statement: if(1,[var(a,string),assign(a,""'ass'"")])"
pham luk,1,12/19/2011,Re:định dạng output!,"các bạn cho hỏi mình có được sửa hàm report ko? vd của thầy là def report(reason: String, offending: WithItem): Type = { report(reason + "": "" + offending.item ) } minh sửa thành def report(reason: String, offending: WithItem): Type = { report(reason + "": "" + offending ) }"
FirstName LastName,1,12/19/2011,Re:định dạng output!,"Trongđặc tả có nói, ko nên sửa, nhưng nếu sửa thì ok thôi, nhưng lưuý là phải ra outputđúng làđược"
V For,1,12/19/2011,Re:định dạng output!,"pham luk wrote: các bạn cho hỏi mình có được sửa hàm report ko? vd của thầy là def report(reason: String, offending: WithItem): Type = { report(reason + "": "" + offending.item ) } minh sửa thành def report(reason: String, offending: WithItem): Type = { report(reason + "": "" + offending ) } Ko cần đâu bạn report(""Type Mismatch In Expression "", expr); report(""Type Mismatch In Statement"", stat); report(""Cannot Assign To Constant"", stat); .... Minh thay ok ca ma ????"
Phúc Trí,1,12/17/2011,trong if mà có break và continue hay không?,"ass1: The break and continue are only used inside a loop or while statement. They are always terminated by a semi-colon ass2: after an if statement if the variable is assigned in both branches of the if statement, before the first break or continue in either branch (or a nested if statement with a break or continue). cuối cùngtrongif mà có break và continue hay không?"
Forever Alone,1,12/17/2011,Re:trong if mà có break và continue hay không?,"A break/continue statement must be enclosed directly or indirectly in a loop statement (i.e., while or loop statement), otherwise the error message Như vậy break và continue có thể xuất hiện trong if nếu if nằm trong while hoặc loop."
V For,1,12/19/2011,Re:trong if mà có break và continue hay không?,"Em yêu Scala ♥♥♥ wrote: A break/continue statement must be enclosed directly or indirectly in a loop statement (i.e., while or loop statement), otherwise the error message Như vậy break và continue có thể xuất hiện trong if nếu if nằm trong while hoặc loop. Vậy càng khỏe, cứ while, loop gặp break/continue thì ok :D"
V For,1,12/18/2011,string trong Assign ?,"Trong đặc tả ass2 có ghi rỏ ở mục d: Type Mismatch In Statement như sau: ĐỐi với phép gán: LHS có thể là real, integer, boolean. [Hết] VẬY có nghĩa là phép gán không được thực hiện trên string hả các bạn. Mình thấy cái này hơi vô lý; var a: string; var b: string; a := b; // Ko lẽ sai ???"
Phúc Trí,1,12/18/2011,string trong Assign ?,"tran ngoc duc wrote: Trong đặc tả ass2 có ghi rỏ ở mục d: Type Mismatch In Statement như sau: ĐỐi với phép gán: LHS có thể là real, integer, boolean. [Hết] VẬY có nghĩa là phép gán không được thực hiện trên string hả các bạn. Mình thấy cái này hơi vô lý; var a: string; var b: string; a := b; // Ko lẽ sai ??? quảđúng là như vậyđấy bạn. nếu hợp lý thìđâu cóđặc tên là Crazy Language"
Phúc Trí,1,12/18/2011,Kiểu của Parameter???,"Trong phần Funccall: In addition, for parameter passing, the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS. rule ởđây là ( typeof(LHS) = typeof(RHS) ) hay là ( typeof(LHS) = typeof(RHS) vàtypeof(LHS) = integer,real,boolean)"
Sieutoc,1,12/18/2011,Re:string trong Assign ?,Lúc đầu mình nghĩ là string thì phải tự hiểu mà thêm vào. Giờ nghe các bạn nói vậy nghĩa là nếu mình hiện thực điều mình nghĩ là hợp lý thì thật ra nó là điều vô lý trong Crazy à ?
_Tieu_ Doan_Du,1,12/18/2011,string trong Assign ?,"Nói chung thì với môn này chỉ nên làm những gì mà đặc tả nói, nghi ngờ những gì đặc tả mơ hồ, còn nếu đặc tả không nói thì đừng nghĩ đến làm gì :D"
nguyen dung,1,12/19/2011,Re:string trong Assign ?,Như vậy là phép gán này cũng lỗi luôn à: var a: array[2] of real; .... a[0]:= 2.1; LHS không có array type ??
Phúc Trí,1,12/19/2011,Re:string trong Assign ?,nguyen dung wrote: Như vậy là phép gán này cũng lỗi luôn à: var a: array[2] of real; .... a[0]:= 2.1; LHS không có array type ?? a[0] là ele kiểu real. a mới là kiểuarray. nên phép gánđó hợp lệ.
V For,1,12/19/2011,Re:string trong Assign ?,Vậy còn cái này test:= 'string test'; // test là REAL nha vậy nó báo là String không được tham gia vào phép gán Hay không tương thích kiểu p/s: mình nghĩ là String không được tham gia vào phép gán
nguyenducminhkhoi,1,12/19/2011,string trong Assign ?,"2 lỗi đó cùng định dạng mà bạn: Type Mismatch In Statement: assign(test,""'string test'"")"
_Tieu_ Doan_Du,1,12/19/2011,Re:string trong Assign ?,"tran ngoc duc wrote: Vậy còn cái này test:= 'string test'; // test là REAL nha vậy nó báo là String không được tham gia vào phép gán Hay không tương thích kiểu p/s: mình nghĩ là String không được tham gia vào phép gán Như bạn trên đã nói, cái này là type mismatch in statement."
Sieutoc,1,12/19/2011,Re:Kiểu của Parameter???,"Trong trường hợp này kiểu string vẫn không được chấp nhận đâu bạn. Theo mình thì kiểu string chẳng có tác dụng gì cả ngoài làm cảnh ( không gán được, không truyền tham số được)."
Phúc Trí,1,12/19/2011,Re:Kiểu của Parameter???,Spec ass1  wrote: Return type and parameter type can be primitive type or array type. mình nghĩ luật này là luật KT giá trị 2 vế có tưng thích hay khôngđó bạn.
Phúc Trí,1,12/19/2011,Re:Kiểu của Parameter???,"mình nghĩ làđượcđó bạn. nếu kiểu String kođược chấp nhận cho para thì nóđã loại bỏ từ phần parse rồi. bạnđọc lại Spec ass1 đi, có cau minh vừa nóiđó. mình nghĩ xem para như 1 lhsởđây là dùngđể kiểm tra type của para và arg có tương thích hay không như của phép gán thôi."
Phúc Trí,1,12/20/2011,Re:Kiểu của Parameter???,có. tầm vực của 1 FuncVar bao gồm cả block statment của nó.
Sieutoc,1,12/17/2011,file PT.scala,"Xin lỗi mọi người nếu như câu hỏi của mình là spam. Thầy nói là đã up file PT.scala đã được chỉnh sửa lên lâu rồi. Nhưng thực sự mình đã tìm khắp trong mục Assignment, Module và trong Discussion rồi mà vẫn không thấy. Bạn nào biết thầy đã up ở đâu xin chỉ giúp mình, mình đang cần cái PT.scala đó để test. Xin cảm ơn."
Nhan Nguyen Van,1,12/17/2011,Re:file PT.scala,"Tình hình là thầy chưa up đâu, hỏi quá trời mà thấy chưa trả lời, bạn chỉ cần fix lại PT.scala của Ass1 một chút là ok"
Sieutoc,1,12/17/2011,Re:file PT.scala,Cảm ơn bạn
pham luk,1,12/20/2011,Input String ???????,"Khai báo const c = 'asadasd'; var b : string; => INPUT :[const(c,'asadasd'),var(b,string)] => không chuyển thành AST được [const(c,'asadasd'),var(b,string)] Exception in thread ""main"" java.lang.RuntimeException: No result when parsing failed at scala.sys.package$.error (package.scala:27) at scala.util.parsing.combinator.Parsers$NoSuccess.get (Parsers.scala:141) at scala.util.parsing.combinator.Parsers$NoSuccess.get (Parsers.scala:130) at Main$.main (Main.scala:10) at Main.main(Main.scala) bạn nào biết chỉ giúp mình nhé"
Bernkastel 奇跡の魔女,1,12/20/2011,Re:Input String ???????,"thêm end line (xuống hàng) cuối cái input nữa bạn, tức là nhập: [const(c,'asadasd'),var(b,string)] rồi mới cho ctrl + z"
V For,1,12/19/2011,Re:file PT.scala,"thấy nhiều bạn phàn nàn về file PT quá. Mình có xin đc filePT của 1 đứa mọi người có thế dùng, hiện tại mình dùng chưa thấy sai :D [mediafire] http://www.mediafire.com/?n4zh41afx2srqar"
n0b0dy,1,12/20/2011,file PT.scala,"import util.parsing.combinator.JavaTokenParsers import scala.io._ object Main { def main(args: Array[String]): Unit = { val inputFile = ""input.txt"" val lines = Source.fromFile(inputFile).getLines val input = if (!lines.isEmpty) lines.reduceLeft[String](_ + '\n' + _) else """" //val input = if (args.size == 0) scala.io.Source.fromInputStream(System.in).mkString //else scala.io.Source.fromFile(inputFile).mkString //val input = scala.io.Source.fromFile(inputFile).mkString val parser = new IntermediateCrazyParser val result = parser.parse(parser.item, input) //println(result) val ast = ASTGenerator.program(result.get) // In your project, process the tree instead of printing it println(ast) Checker.check(ast) val out=new java.io.FileWriter(""output.txt"") out.write(ast.toString()) out.close() } } Đây là file Main đã đc chỉnh lại để có thể chạy đc test của bạn VanHoa . Bạn chỉ việc copy cái parser vào file input và kết quả sẽ đc xuất ra màn hình lẫn file output.txt"
Sieutoc,1,12/19/2011,Vắng TA,Trong assignment này còn nhiều mâu thuẫn đang chờ thầy giải quyết. Nhưng sao gần đến deadline rồi mà vẫn không thấy thầy trả lời. Mong thầy sẽ sớm xuất hiện để giải quyết các mâu thuẫn của chúng em.
vanhoa,1,12/18/2011,Function Not Return,Ý mình là các đoạn dead code ấy :)) Nó chỉ kiểm tra dead code của if thôi thì phải :P
Forever Alone,1,12/18/2011,Re:Function Not Return,"Cái deadcode đó thì mình đã từng thấy trong Netbeans, còn Eclipse thì chưa. Mà hiện thực như kiểu Netbeans thì.... :-s"
Clapika,1,12/18/2011,Re:Function Not Return,Mình cũng thử if (true) return 1; Kết quả là vẫn báo lỗi trên cả Netbeans lẫn Eclipse
_Tieu_ Doan_Du,1,12/18/2011,Function Not Return,"Mình thấy nhiều topic thảo luận các vấn đề này lắm, tốt nhất là dừng lại đi. Nếu không có ý kiến chính thức của TA thì không ai biết là ai đúng ai sai đâu :-ss"
Minh Nguyen,1,12/20/2011,Function Not Return,Đã có giải đáp của thầy trong notice. Mọi người vào xem. Ass2 đã khó giờ còn khó hơn. Chẳng biết sửa lại kịp trước deadline không. :(
Phúc Trí,1,12/20/2011,Cau lệnh Return nằm sau Break thì có được tính hay không?,"Trong phần check Function Not Return Câu lệnh Return nằm sau Break,continue thì có được tính hay không?."
Nha Nguyen,1,12/19/2011,Return statement!,"Cho mình hỏi tí , nếu trong procedure ma co return thi sao ? minh co báo lỗi gì không ! vd procedure f(a:real); begin return true; end;"
Sieutoc,1,12/19/2011,Re:Return statement!,Một function phải có ít nhất một return trong các execution path. Nhưng một return không bắt buộc phải nằm trong 1 function. Vì vậy không báo lỗi.
Ngan Tuyet,1,12/20/2011,Re:Return statement!,Mình nghĩ là test trên nó sẽ báo lỗi Type Mismatch In Statement
Huỳnh Tiến Tài,1,12/20/2011,Re:Return statement!,"Đề bài không hề nói tới vấn đề đó, vậy tại sao phải check và tại sao phải báo lỗi nhỉ???"
Nha Nguyen,1,12/20/2011,Re:Return statement!,"Nhưng trong spec thầy không không mô tả trường hợp này ! mấy bạn test thử cái này xem: procedure demo(); begin var a:array[1,2] of real; a[2,2] := 5.0; // chỗ này có báo lỗi không end;"
cong thanh,1,12/20/2011,Re:Return statement!,"mình nghĩ nên báo lỗi vì procedure k có kiểu trả về, mà k có kiểu trả về sau câu lệnh return sẽ parser k được, nên câu lệnh return ở đây vẫn lỗi:D"
Ngan Tuyet,1,12/20/2011,Case h: Not Defined Before Used?,"Cho mình hỏi trong 2 code này, thì cái nào báo lỗi và báo chỗ nào? VD1: function func(): integer; begin var n: integer; var x: integer; var m:integer; while (1> 0) do begin n:= 1; break; m:=1; x:=n+m; end return x; end; VD2: var x: integer; procedure main(); begin while (1>x) do begin var z:real; begin break; end z := 1; z := z; //(1) end end; p/s: Theo ý mình thì lỗi: VD1 : ""Not Defined Before Used: x"" . VD2 : ko có lỗi"
LAV,1,12/19/2011,Array làm thông số hàm! ,Mình thấy trong đề ghi: "The element type of the argument array must be either the same as or coercible to the element type of the parameter array." vậy theo mình hiểu nếu theo dòng này thì ví dụ dưới đây sẽ đúng phải ko? var s1: real; procedure main(a: real); begin var v1: array[1] of integer; main1(v1); end; procedure main1(a : array[1] of real); begin end; *** v1 là array kiểu integer gán vào thông số của main1 là array kiểu real !
V For,1,12/19/2011,Re:Array làm thông số hàm! ,k loi
Vinh Nguyễn,1,12/21/2011,Re:Array làm thông số hàm! ,Vậy giả sử thay biến v1 ko phải array nữa mà là kiểu integer lun thì sao? Code: var s1: real; procedure main(a: real); begin var v1: integer; main1(v1); end; procedure main1(a : array[1] of real); begin end;
Vinh Nguyễn,1,12/21/2011,Re:Array làm thông số hàm! ,"Guest User wrote: Vinh Nguyen Truong wrote: Vậy giả sử thay biến v1 ko phải array nữa mà là kiểu integer lun thì sao? Code: var s1: real; procedure main(a: real); begin var v1: integer; main1(v1); end; procedure main1(a : array[1] of real); begin end; In the case that the argument is an array, the corresponding parameter must be in the array type Ngược lại thì sao nhỉ ? Có lẽ bạn hiểu nhầm thì phải. Cái câu :"" In the case that the argument is an array, the corresponding parameter must be in the array type "" giải quyết việc argument là array thì parameter tương ứng với nó phải là array. Còn trong ví dụ của mình thì ý mình là nếu ngược lại, parameter là array thì argument như thế nào, array luôn chăng?"
tuong vo,1,12/21/2011,Re:Array làm thông số hàm! ,"mình nghĩ sẽ báo lỗi : Type Mismatch In Statement: call(main1,[v1])"
V For,1,12/21/2011,Re:Array làm thông số hàm! ,"Vinh Nguyen Truong wrote: Vậy giả sử thay biến v1 ko phải array nữa mà là kiểu integer lun thì sao? Code: var s1: real; procedure main(a: real); begin var v1: integer; main1(v1); end; procedure main1(a : array[1] of real); begin end; Type Mismatch In Statement: call(main1,[v1])"
Minh Nguyen,1,12/20/2011,Case h: Not Defined Before Used?,"VD1: Not Defined Before Used: m Theo mình là như thế này, vì theo như đề: A variable is assigned: after a do statement if the variable is assigned before the first break or continue (or a nested if statement with a break or continue) in the body Cái assign m không tính. ^^!"
Ngan Tuyet,1,12/20/2011,Re:Case h: Not Defined Before Used?,@Minh: Theo Ngân assign chỉ ko tính khi câu đó x:=m+n nằm ngoài while thui. Theo logic thì phải thế chứ! Chắc ngôn ngữ này là Crazy cũng phải có logic chứ!
Phúc Trí,1,12/20/2011,Re:Case h: Not Defined Before Used?,thực chất t hi 2 câu lệnh m:=1; x:=n+m; s ẽ ko bao hđược thực thi nên ko ai KT làm j. nhưng do mình ko làm phầnđó (Unreachable Code) nên câu lệnh x:=m+n mình vẫn test nên nó báo lỗi. còn nếu m làm luôn Unreachable Code thì nó se bao loi va cau truc t est của mình nó cũng khác :D
Phúc Trí,1,12/20/2011,Re:Case h: Not Defined Before Used?,"Thầy cho em hỏi nếu trường hợpwhile(false) Như VD: funtion... begin var x:integer; while( false ) begin x:=9; end x:=x+1; //1 end; tại câu lệnh số 1, xđã có giá trị hay chưa?"
Phúc Trí,1,12/20/2011,Re:Case h: Not Defined Before Used?,"var x:integer; function a():real; begin var b:boolean; var c,s:real; b:=false; while (b) do if (b) then begin return 3; s:=3; end else s:=5; c:=s; return 9; end; cho hỏi test này báo lỗi hay ko vậy mấy bác! và báo lỗi gì? (neu co)"
Nhan Nguyen Van,1,12/14/2011,Function Not Return,"Thưa thầy cho em hỏi: function test() : integer; begin var a : integer; if true then a := 0; return 0; end Vậy có báo lỗi ""Function Not Return: test"" không? Trong đặc tả có đoạn :In each path of the execution of the function, there is at least a return statement, otherwise, the error message. Nhưng chương trình trên chắc chắn chạy câu lện return cuối cùng?"
V For,1,12/20/2011,khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,procedure main(); begin var a: array[4] of integer; a[1000]:= 1000; end; Lỗi k các bác?? K thấy trong đặc tả >?
Phuc Ly,1,12/21/2011,Thắc mắc về String Literal.,"Thầy cho em hỏi dòng: ""case Term(""str"", List(StringItem(value))) => StringLit(value) // TODO check"" trong file Utils có nhầm lẫn không? Trong khi phía trên là: ""case Term(""string"", List(StringItem(value))) => StringLit(value)"". Em thử chạy input: [const(a,string(""'abc'"")),var(b,string),proc(test,[],[assign(b,string(""'abc'""))])] thì thu được kết quả của ASTgenerator: Program(List(Const(a ,StringLit(""'abc'"") ), Var(b,PrimitiveType(string)), Proc(test,List(),Block(List(Assign(Id(b) ,UnaryOp(string,StringLit(""'abc'"")) ))))))"
Thanh Pham Minh,1,12/14/2011,Function Not Return,@nhan: Theo bạn ví dụ này thì sao :) function foo(a: integer): integer; begin if (a > 0) then return 0; else return 1; writeLn('this line never runs'); end và ví dụ này :D function bar(): integer; begin if true then return 0; else writeLn('this line never runs'); end
nguyen dung,1,12/14/2011,Re:Function Not Return,"Theo như đặc tả thì chỉ cần return xuất hiện trong func là đủ, ngay cả khi nó không bao giờ chạy => test trên bt"
Thanh Pham Minh,1,12/15/2011,Re:Function Not Return,"nguyen dung wrote: Theo như đặc tả thì chỉ cần return xuất hiện trong func là đủ, ngay cả khi nó không bao giờ chạy => test trên bt Có lẽ bạn hiểu sai đặc tả. Trong mỗi đường thực thi của một function, cần có ít nhất một lệnh return. Hai ví dụ mình đưa ra là để làm rõ thế nào là ""đường thực thi"" (execution path). Theo mình thì đường thực thi sẽ được xác định ở mức độ cấu trúc chương trình, chứ không phải ở mức độ chạy chương trình. Nghĩa là cho dù có một đường thực thi về mặt ngữ nghĩa/ logic không bao giờ được thực hiện, nó vẫn phải có ít nhất một lệnh return. Nên ví dụ thứ 2 cần có thêm một lệnh return cho đường thực thi đi qua nhánh else (return trong else; hoặc sau else và trước end) Ở ví dụ thứ nhất, cho dù xét ở mức cấu trúc chương trình, trên mỗi đường thực thi đều đã có một lệnh return, nên mình nghĩ sẽ không báo lỗi ở đây. Tuy nhiên mình chưa bắt đầu làm nên không chắc lắm vấn đề này."
nguyen dung,1,12/15/2011,Re:Function Not Return,"Cảm ơn bạn, mình không đọc kỹ chỗ excution path nên hèn chi tưởng chỗ đó dễ òm :)"
Phúc Trí,1,12/15/2011,Re:Function Not Return,Cho hỏi ngoài lề 1 tí. nếu trong Proceduce có lệnh return thì xử lý làm sao?
Thanh Pham Minh,1,12/15/2011,Re:Function Not Return,"H.T.P (^_^)  wrote: Cho hỏi ngoài lề 1 tí. nếu trong Proceduce có lệnh return thì sử lý làm sao? * For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type. * The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. Procedure có return type là gì nhỉ :p Nên mình nghĩ sẽ xuất lỗi Type Mismatch In Statement:."
Nhan Nguyen Van,1,12/15/2011,Re:Function Not Return,"Thanh Pham Minh wrote: H.T.P (^_^)  wrote: Cho hỏi ngoài lề 1 tí. nếu trong Proceduce có lệnh return thì sử lý làm sao? * For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type. * The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. Procedure có return type là gì nhỉ :p Nên mình nghĩ sẽ xuất lỗi Type Mismatch In Statement:. Type Mismatch In Statement: Có nghĩa là câu lệnh này bị sai kiểu, còn return trong procedure là sai câu lệnh, nếu có kiểm tra thì parser phải kiểm tra chứ, theo mình nghỉ là StaticChecker không kiểm tra cái này."
Thanh Pham Minh,1,12/15/2011,Re:Function Not Return,"nhan nguyen van wrote: Thanh Pham Minh wrote: H.T.P (^_^)  wrote: Cho hỏi ngoài lề 1 tí. nếu trong Proceduce có lệnh return thì sử lý làm sao? * For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type. * The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. Procedure có return type là gì nhỉ :p Nên mình nghĩ sẽ xuất lỗi Type Mismatch In Statement:. Type Mismatch In Statement: Có nghĩa là câu lệnh này bị sai kiểu, còn return trong procedure là sai câu lệnh, nếu có kiểm tra thì parser phải kiểm tra chứ, theo mình nghỉ là StaticChecker không kiểm tra cái này. Bạn đã đọc kỹ đặc tả và hai dòng có dấu * mình trích dẫn chưa :)"
Nhan Nguyen Van,1,12/15/2011,Re:Function Not Return,Vậy như thế nào là một đường thực thi? function main():real; begin var a: real; end; trong begin...end; có tính là 1 đường ko? Nếu có => yêu cầu phải có return => Ví dụ: function foo(a: integer): integer; begin if (a > 0) then return 0; else return 1; writeLn('this line never runs'); end cũng phải cần 1 câu lệnh return sau dòng WriteLn
nguyen dung,1,12/16/2011,Re:Function Not Return,"VD này function foo() : real; begin var a: real; while(1>0) do if (1>0) then return 1; else return 0; end; Return trong while đã đủ , còn trong Block thì có cần không và ,(nếu cần) thì trước hay sau While cũng được đúng không ?"
Sieutoc,1,12/20/2011,Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,same size of each dimension => báo lỗi bạn.
nguyen dung,1,12/20/2011,Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,"Bổ sung câu hỏi trên nếu gọi a[-4] có lỗi không, trong đặc tả chỉ nói A[E1,E2...] thì Ei là kiểu integer thôi"
nguyen dung,1,12/20/2011,Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,"^ Chỗ bạn nói đâu phải luật của phép gán, nó là kt tương thích của param và argue mà"
vanhoa,1,12/20/2011,khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,"Static check chỉ check số chiều, không check boundary mỗi chiều đâu bạn."
V For,1,12/20/2011,Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,"Mai Hoa Đạo  wrote: same size of each dimension => báo lỗi bạn. same size of each dimension theo mình hiểu là: Các chiều của mảng phải cũng kích thước procedure testArr(); begin var a: array[3] of real; a[1] := 10; end; => Ko loi procedure testArr(); begin var a: array[3,3] of real; a[1,2] := 10; end; => Ko loi procedure testArr(); begin var a: array[3,3] of real; a[1] := 10; end; =>Type Mismatch In Expression: ele(a,[1]) ??? còn trường hợp mình nói là nó đã same size of demension rồi, vấn đề là mảng có tối đa 4 phần tử mà mình gọi a[1000] là lỗi ấy, có làm chổ này k???"
Minh Nguyen,1,12/20/2011,khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,theo mình là ko báo lỗi
FirstName LastName,1,12/20/2011,Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,"ko báo lỗi thử vào c tạo cái mảng 3 phần tử rồi gọi a[4] xem nó có báo gì ko phần checkđó thuộc về dynamic rồi bạn, khi thực thi mới có lỗi"
Sieutoc,1,12/20/2011,Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,Cảm ơn các bạn. Do mình hiểu sai đặc tả nên làm vậy. Thanks mọi người
V For,1,12/20/2011,Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,"Manchester United wrote: ko báo lỗi thử vào c tạo cái mảng 3 phần tử rồi gọi a[4] xem nó có báo gì ko phần checkđó thuộc về dynamic rồi bạn, khi thực thi mới có lỗi Ok bạn, nói thế này dễ hiểu nè. :)"
Vu Dang,1,12/21/2011,khai báo a: array[4] --> gọi a[1000] Lỗi hay k?,tran ngoc duc wrote: procedure main(); begin var a: array[4] of integer; a[1000]:= 1000; end; Lỗi k các bác?? K thấy trong đặc tả >? --> None
M.U.,1,12/20/2011,Chương trình như vậy output thế nào vậy?,"var a: array[5] of integer; // global variable procedure fill(x:array[5] of integer); begin var a:real; // superseding global variable a var x:real; // WRONG because parameter x has the same name a:=5.9; init(x); end; procedure init(x:array[5] of integer); begin var i:integer; //block variable i:=0; x[i]:=a[i]; // a is global var. end; procedure main(); begin fill(a); end; Chương trình này trong mục 5 của file đặc tả scala, ở đây mình thấy ở procedure fill sử dụng hàm init, nhưng procedure init lại dc khai báo sau procedure fill. Như vậy output sẽ thế nào vậy? Cám ơn mọi người."
M.U.,1,12/20/2011,Re:Chương trình như vậy output thế nào vậy?,ai giúp mình trả lời nhanh nhanh :( mình hy vọng cái program trên sai cho đỡ phiền =.=
Thanh Pham Minh,1,12/16/2011,Re:Function Not Return,//lăn chuột hơi mỏi tay
Vu Dang,1,12/16/2011,Re:Function Not Return,quá dài dòng! nhìn là không muốn đọc rồi
Thanh Pham Minh,1,12/16/2011,Re:Function Not Return,"ass2  wrote: quá dài dòng! nhìn là không muốn đọc rồi Oh, xin lỗi bạn nhé, mình cũng không cố ý để bạn nhìn thấy ;))"
Vu Dang,1,12/16/2011,Re:Function Not Return,"Thanh Pham Minh wrote: ass2  wrote: quá dài dòng! nhìn là không muốn đọc rồi Oh, xin lỗi bạn nhé, mình cũng không cố ý để bạn nhìn thấy ;)) lỡ nhìn mất rồi! làm sao bi giờ? ((:"
Phúc Trí,1,12/18/2011,Re:Function Not Return,Còn trường hợp returnở trong vòngwhile mà nằm sau break; thì sao. đường thực thiđi quawhile cóđược tính là có return rồi hay ko??
Thanh Pham Minh,1,12/18/2011,Re:Function Not Return,H.T.P (^_^)  wrote: Còn trường hợp returnở trong vòngwhile mà nằm sau break; thì sao. đường thực thiđi quawhile cóđược tính là có return rồi hay ko?? 01. Nhưng bạn vẫn phải có return cho execution path không đi qua while. 02. Execution path đi qua while chứa execution path không đi qua while. => có hay không có return trong while không thay đổi được gì cả :)
vanhoa,1,12/18/2011,Function Not Return,Có 2 loại while: 1. while chắc chắn được thực hiện (while có mệnh đề điều kiện luôn đúng): mình xem thân nó như một block bình thường. 2. while không chắc đúng hoặc while luôn sai: không cần xem xét. Tương tự cho loop.
Thanh Pham Minh,1,12/18/2011,Function Not Return,vanhoa  wrote: Có 2 loại while: 1. while chắc chắn được thực hiện (while có mệnh đề điều kiện luôn đúng): mình xem thân nó như một block bình thường. 2. while không chắc đúng hoặc while luôn sai: không cần xem xét. Tương tự cho loop. var a: integer; function foo(a: integer): integer; begin if (a >= 1) then a:= 0; while(a < 1) do return 0; a:= 1; end; procedure main(); begin var b: integer; a:= 100; b:= foo(a); end; Theo cách chia đó thì ví dụ trên thuộc loại 1 hay 2? Nếu thuộc loại 1 nghĩa là bạn đã chạy chương trình? Nếu thuộc loại 2 thì có nên chia giữa "chắc chắn" và "không chắc". Loại 2 đã một phần chứa loại 1 (tùy việc bạn hiện thực tới mức nào). Logic thì phải là "chắc chắn có" và "chắc chắn không" mới không bị overlap.
Vu Dang,1,12/21/2011,Chương trình như vậy output thế nào vậy?,sẽ không xảy ra lỗi như bạn mong đợi đâu bạn! hàm init co tầm vực toàn chương trình mà! cho nên khai bao trước hay sau đều ok!
Vu Dang,1,12/21/2011,Re:Chương trình như vậy output thế nào vậy?,các bác cho em hỏi test này các bác ra kết quả thế nào vậy?
V For,1,12/21/2011,Re:Chương trình như vậy output thế nào vậy?,Test đó lỗi: Redeclared Variable: x Nếu xong dòng var x:real; // WRONG because parameter x has the same name thì ko lỗi
vanhoa,1,12/18/2011,Function Not Return,Đây là static check :)
Thanh Pham Minh,1,12/18/2011,Function Not Return,vanhoa  wrote: Đây là static check :) Đó chính là cái mình muốn nói. Static check thì bạn không thể xét expression trong while có luôn đúng hay không.
vanhoa,1,12/18/2011,Function Not Return,"có chứ, vd while true."
Sieutoc,1,12/18/2011,Re:Function Not Return,"Thưa thầy Hưng chúng em cần thầy xác nhận vấn đề này: Nếu return không nằm trong 1 function nào đó thì: 1. Báo lỗi: Type Missmatch In Statement:<statement> 2. Báo lỗi: Return Must Be In Function 3. Bỏ qua, không kiểm tra."
vanhoa,1,12/18/2011,Function Not Return,các bạn cứ yên tâm là cái nào k có trong đặc tả sẽ k có trong testcase:p
Thanh Pham Minh,1,12/18/2011,Function Not Return,"vanhoa  wrote: có chứ, vd while true. vậy đâu còn là s tatic check nữa :) cứ cho là ""true"" ok vì không phải eval gì cả, ""1 > 0"" thì sao :)"
vanhoa,1,12/18/2011,Function Not Return,"1>0 vẫn là true :))Thựcchấtstaticcheckcũngbaogồmnhữngcáinàynữa,tuỳvàongườiđịnhnghĩathôi,VDnhưmấycáiIDEjavađó,netbeans hoặcEclipsechẳnghạn,nóvẫncheckmấycáiđóđó :D Cái này a Hùng bảo làm chứ nếu không thì ass này đơn giản quá, còn có test hay ko thì mình ko rõ :))"
FirstName LastName,1,12/18/2011,Re:Function Not Return,"đặc tả chả nói tới check ngữ nghĩa jở trong hàm, chỉ check kiểu, như vậy chắc ko test, bạn vanhoa làm tốt ko có nghĩa là nhiều bạn khác làm tốt, vì nhiều bạn ko làm dc cáiass ""đơn giản quá"" như bạn nói"
vanhoa,1,12/18/2011,Function Not Return,"Hi thựcsựnếunỏđi cácthứ khóthìbạnsẽthấynórấtdễ :) ^^ Nói chung các bạn có làm hay ko thì tuỳ, nếu không làm cái đó, thì các execution path sẽ loại bỏ hoàn toàn các vòng lặp (mặc định xem như nó ko đc thực thi), lúc đó mọi chuyện lại quá đơn giản :)."
Phúc Trí,1,12/18/2011,Re:Function Not Return,Đơn giản hay phức tạp ko quan trọng. Vấnđềởđây là yêu cầu của thầy là như thế nào?Chứ khó hay dễ thì vẫn phải cắn răng mà làm thôi. Đằng nàytrong fileđặc tả ko hề ghi 1 câuđịnh nghĩa thì biết làm thế nào mớiđúngý thầy. @@
Forever Alone,1,12/18/2011,Function Not Return,"vanhoa  wrote: 1>0 vẫn là true :))Thựcchấtstaticcheckcũngbaogồmnhữngcáinàynữa,tuỳvàongườiđịnhnghĩathôi,VDnhưmấycáiIDEjavađó,netbeans hoặcEclipsechẳnghạn,nóvẫncheckmấycáiđóđó :D Cái này a Hùng bảo làm chứ nếu không thì ass này đơn giản quá, còn có test hay ko thì mình ko rõ :)) Mới vừa code thử dòng này trong eclipse và kq là chẳng báo gì :| while(true) return; return;"
nguyen dung,1,11/27/2011,Cho em hỏi về PrimitiveType,"Thưa thầy trong file StaticCheck.scala có dòngcase FloatLit(_) => PrimitiveType(""real"") . Còn trong parser tree thìnó raPrimitiveType(""float""). Vậy nếu làmcase BinaryOp(...) trong hàm typeof thìcase PrimitiveType(""float"") => PrimitiveType(""float"") chứ không phảicase PrimitiveType(""float"") => PrimitiveType(""real"") ?? Tương tự có vd: var man:integer; Parse ra :Program(List(Var(man,PrimitiveType(int)))) Còntrong hàm typeof case IntLit(_) => PrimitiveType(""integer"") ------------------------------------------------------------------------------ P/S: Còn 1 điểm nữa là nếu tự định nghĩa 1 Function sau: function a():integer; begin return readInt(); end; thì bảng symbols: List(Symbol(a,FuncType(List(), PrimitiveType(int)) ,FuncVar), Symbol(readInt,FuncType(List(), PrimitiveType(integer)) ,Function)) Tương tự là trường hợp real và float function a():real; begin return readReal(); end; List(Symbol(a,FuncType(List(), PrimitiveType(float)) ,FuncVar), Symbol(readReal,FuncType(List(), PrimitiveType(real)) ,Function)) Xin thầy xác nhận là chỗ này để nguyên hay cần sửa lại gì không ạ ?"
Nguyen Vo,1,12/21/2011,Test này ra gì.,procedure a(); begin end; procedure b(); begin a:=3; end; ra undeclare hay type mismatch..... Thanks.
Vu Dang,1,12/21/2011,Test này ra gì.,"chicken _ wrote: procedure a(); begin end; procedure b(); begin a:=3; end; ra undeclare hay type mismatch..... Thanks. Type Mismatch In Statement: assign(a,3)"
librastar,1,12/3/2011,Some Questions ,"Cho em hỏi 2 câu sau: 1) Trong 1 lời gọi hàm nếu arg là kiểu array, theo như spec thì arg và param tương ứng(cũng có kiểu array) chỉ cần giống nhau về bound, như vậy ko cần giống nhau về base type? 2) Trong 1 vòng lặp, nếu xuất hiện break/continue thì những statement sau có cần check ""Not Defined Before Used"" không ạ?"
librastar,1,12/3/2011,Re:Some Questions ,3) Với trường hợp này: function fill(x:array[5] of integer) : boolean; begin return false; end; procedure fill(x:array[5] of integer; y:string; z:real); begin end; procedure main(); begin end; Sẽ báo lỗi " Redeclared Procedure: fill" hay " Redeclared Function: fill" ?
FirstName LastName,1,12/4/2011,Re:Some Questions ,"Redeclared Variable/Constant/Function/Procedure/Parameter An identifier must be declared before used. However, the declaration must be unique in its scope. Otherwise, the error messages Redeclared <kind>: <identifier> is released, where <kind> is the kind of the identifier in the second declaration."
librastar,1,12/4/2011,Re:Some Questions ,"Manchester United wrote: Redeclared Variable/Constant/Function/Procedure/Parameter An identifier must be declared before used. However, the declaration must be unique in its scope. Otherwise, the error messages Redeclared : is released, where is the kind of the identifier in the second declaration. Thanks.:)"
facebook.com,1,11/29/2011,Cấu trúc điểm của Assignment_2,"Thưa thầy, cho em hỏi cấu trúc điểm của Assignment_2 này như thế nào? và đối với điểm Bonus, thì nếu chúng em (lớp thường) làm hơn 100% thì phần dư (Bonus) của Assignment_2 có được cộng dồn vào điểm của Assignment_1 không? Em xin cám ơn!"
Nhan Nguyen Van,1,12/3/2011,Thầy cho em hỏi vê hàm Typeof ,Trong hàm typeof có đoạn: case IntLit(_) => PrimitiveType("integer") case FloatLit(_) => PrimitiveType("real") case BoolLit(_) => PrimitiveType("boolean") khi gọi typeof cho một số nguyên (ví dụ là số 3) thì sẽ ra kiểu là : integer còn khi khai báo một biến kiểu nguyên thì do parser của Assignment 1 quy đinh thì sẽ có kiểu là : int => khi so kiểu sẽ không trùng. Vậy PT của Assignment 1 sẽ được sửa lại hay là em có thể sửa trong hàm typeof : case IntLit(_) => PrimitiveType("integer") thànhcase IntLit(_) => PrimitiveType("int")
V For,1,12/21/2011,Re:Test này ra gì.,Guest User wrote: theo mình thì undeclare vì a đâu phải fun call a đã được declare rồi. ==> Lỗi undeclare hoàn toàn k hợp lý!
Bruce Wayne,1,12/21/2011,Test này ra gì.,Mình nghĩ undeclared vì chỉ có procedure a() được khai báo. Còn biến a đâu có được khai báo!
Nhan Nguyen Van,1,12/3/2011,Lỗi array constant,procedure main(); begin var c:array[0] of real; c := [1.2]; end; sử dụng array constant bất kỳ chổ nào đều bị báo lỗi: Exception in thread "main" scala.MatchError: [1.2] (of class ItemList) do class ItemList không hiểu [1.2]. Thầy cho em hỏi: Vậy trong chương trình có sử dụng array constant như trên không ạ?
minhtu nguyen,1,12/10/2011,Thắc mắc về báo lỗi trong Call Statement và Function Call,"Trong assignment có đoạn: For a call statement, ..., for parameter passing, the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS . trước đó có đoạn: For an assignment statement, the LHS can be in real, integer or boolean type . Như vậy có nghĩa là tham số truyền vào của Procedure (Function) chỉ có thể có kiểu integer, real hoặc boolean. Mà kiểu của tham số được xác định ngay từ lời khai báo Procedure (Function), vậy thì phải báo lỗi ở lời khai báo luôn hay sao? Và nếu báo lỗi thì báo thế nào?"
MFC.Maximus,1,12/12/2011,OneStmt and Stat,"case class Block(body: List[OneStmt]) extends Stat // TODO fix cái này có phải sửa lại là body : List[Stat] không thầy, lúc check em không thể cast từ OnStmt sang Stat được, em cảm ơn"
librastar,1,12/13/2011,Re:OneStmt and Stat,Dùng asInstanceOf[Stat]
MFC.Maximus,1,12/13/2011,Re:OneStmt and Stat,"librastar  wrote: Dùng asInstanceOf[Stat] dùng asInstanceOf bị lỗi bạn, trait OneStmt abstract class Stat extends WithItem with OneStmt hình như không thể cast từ OneStmt sang Stat được"
MFC.Maximus,1,12/13/2011,Re:OneStmt and Stat,"Kid  wrote: trong hàm checkBlock mình code val symsN = (symbols /: block.body)((a, b) => { b match { ..... case stmt => checkStatement(b.asInstanceOf[Stat],a,inLoop) } nhưng bị báo lỗi: type mismatch;found:Any required : List[Symbols] bạn nào chỉ giúp mình với nha. xem lại kiểu trả về của hàm checkStatement, vì cài hàm(symbols /: block.body) ((a,b) nó yêu cầu trả về kiểu List[Symbol]"
Vu Dang,1,12/2/2011,hàm withItem!,"cho mình hỏi cái hàm này làm cái gì vậy? def withItem[T <: WithItem](item: Item, w: T) = { w.item = item; w }"
_Đào_Hoa_Đảo_Chủ_,1,12/14/2011,Re:hàm withItem!,"Đọc code nản thật, không comment j hết :-"""
FirstName LastName,1,12/14/2011,Re:hàm withItem!,"Đúng là ko biết chỗ nào cần thêm nữa, Nhìnđúng là loạnóc, hại não thật"
Forever Alone,1,12/14/2011,Re:hàm withItem!,Lập team 10 người hùn tiền lại thuê người comment dùm đi ;))
Vu Dang,1,11/9/2011,code,cac ban co the share code cho minh khong? de lam tot ass2 thank!
V For,1,11/11/2011,Re:code,"share thi ok, neu full test. Van de o cho thay co cho share k thoi !"
mr. Ben,0,11/8/2011,ai cứu với hix hix...,"mình bị sai giải thuật phần nào ko bit, test tất cả các function..., đều báo lỗi ngay chính từ khóa function, ...."
thinh van,1,11/8/2011,Re:ai cứu với hix hix...,"pó tay lun, làm vầy hok dc đâu bạn ơi:("
Nguyen Xuan Sang,1,11/18/2011,Về kết quả ass1 stage2,"Thưa thầy, trong ass1 starge 2 do sơ suất nên em đã định dạng output trong hàm show sai một lỗi nhỏ (thiếu một trong 2 dấu "":"") nên kết quả của em failed rất nhiều (30 test) về lỗi đó. Mong thầy châm chước cho em được sửa lại lỗi đó, em xin chấp nhận bị trừ một số test ạ. Em xin cảm ơn. Nguyễn Xuân Sang MSSV: 50902233"
free_love,1,11/18/2011,Re:Về kết quả ass1 stage2,thay oi em cung bi nhu vay ...mong thay cham truoc cho:( MSSV 50801987 cam on thay!
hoang nguyen,1,11/18/2011,Re:Về kết quả ass1 stage2,Chào anh . Em tên : Nguyễn Giang Phương Hoàng MSSV: 50800709 em xin sửa lại file nộp bài . vì lúc nộp em thấy chú thích file nộp là crazy2011.scala . nên em đã sửa lại tên nên kết quả là file không tìm thấy. Mong anh xem lại giúp em. Em không chú ý state1 vì em nghĩ anh đã update lại là như vậy . em cảm ơn anh.
TV,1,11/18/2011,Re:Về kết quả ass1 stage2,E ko hiểu sao bài làm vẫn chạy bình thường trên máy e mà bị lỗi UTF-8 vậy thầy? MSSV: 50903391
Huỳnh Tiến Tài,1,11/18/2011,Re:Về kết quả ass1 stage2,"Em cũng bị lỗi như bạn Xuan Sang, sai định dạng output line 1:5 : unexpected token: A line 1:5 : unexpected token: A Còn lại thì cả line và token lỗi đều đúng hết. Không biết chúng em có được du di không? Vì đã bỏ công sức khá nhiều nhưng cuối cùng lại sai nhiều quá! Em cảm ơn thầy!"
Tran Thanh,1,11/19/2011,Re:Về kết quả ass1 stage2,"Thưa thầy,em cũng bị trường hợp như mấy bạn,định dạng output của em dư 1 dấu cách,làm fail nhiều test,bao nhiêu công sức bỏ ra....mong thầy xem xét dùm em ạ. Trần Ngọc Thành MSSV: 50902484"
Tong Ngoc Hoa,1,11/19/2011,Về lỗi utf8,Thầy cho em hỏi là thầy xài bản scala bao nhiêu vậy? Vi em thấy trong file đặc tả không hề ghi Em cũng đã test trên linux (backtrack 4 chắc chắn là cũ hơn ubuntu 11.04) trước khi nộp rồi mà vẫn bị lỗi này mong thầy nói rõ để lần này em không bị sai nữa. Cảm ơn thầy!
M.U.,1,11/8/2011,Re:ai cứu với hix hix...,"def funcDec: Parser[FuncDecPT] = (""function"" ~> ident) ~(""("" ~> paramList <~ "")"") ~ ("":"" ~> varType <~ "";"") ~ ( "";"" ~ > blockStmt <~ "";"") ^^ { case a ~ b ~ c ~ d => new FuncDecPT(new IdPT(a), b, c, d) } chỗ này bạn sai: xóa cái phần mình tô màu đỏ đi."
Đỗ Sỹ Hưng,1,11/8/2011,Re:ai cứu với hix hix...,"xóa cái code đi bạn, lỡ ai chép lại bi gian lận nữa"
Forever Alone,1,11/8/2011,ai cứu với hix hix...,"Quoc Anh Nguyen Bui wrote: mình bị sai giải thuật phần nào ko bit, test tất cả các function..., đều báo lỗi ngay chính từ khóa function, .... Trả lời trễ rồi nhưng có thể do bạn quên thêm từ khóa function vào trong list reserved"
n0b0dy,1,9/25/2011,Thắc mắc KQ Test2,`const' identifier d `=' 1.23e-1 `;' `const' identifier e `=' 12 `;' `const' identifier f `=' "'qeqwe''qwrqwr'" `;' `const' identifier g `=' `true' `;' `const' identifier h `=' `[' 23 `;' 45 `;' 2 `]' `;' EOF Cho em hỏi là tại sao true trong trường hợp này lại có dấu ` ' ở ngoài . Xin cảm ơn anh .
MFC.Maximus,1,9/29/2011,a?  = 0 or 1 ,các bác giúp em với =.=! code : import scala.uti.matching._ val re = new Regex("[1234]\\.(0|0*[123])([eE][123])") val x = "1.0000002e3" val kq = re.findAllIn(x) kq.foreach(println) kết quả là 1.0000002e3 còn nếu val re = new Regex("[1234]\\.(0|0*[123])([eE][123])?") thì lúc này kết quả chỉ ra 1.0 cho em hỏi dấu ? trong đoạn code trên có phạm vi ảnh hưởng ntn. ([eE][123]) thôi hay là (0|0*[123])([eE][123])
thinh van,1,9/29/2011,Re:a?  = 0 or 1 ,"x=""123,0000000000002"" đâu có trùng với định dạng trong Regex đâu muk sao ra kq hay vậy bạn?????"
MFC.Maximus,1,9/29/2011,Re:a?  = 0 or 1 ,"ah sr để mình edit lại bài, ""123.000002""-> ""1.000003e2"""
Nguyễn Đức Huy,1,9/30/2011,Hỏi 1 tí về hàm oneDec và procDec,"trong phần parser có khai báo: def oneDec: Parser[List[SubtinePT]] = varDec | procDec trong đó def varDec: Parser[List[VarDecPT]] thì mình thấy hợp lý, vì lớp VarDecPT đc extends từ lớp SubtinePT nên List[VarDecPT] cũng là List[SubtinePT] . Nhưng còn khai báo của procDec thì mình ko hiểu nha: tại sao lại là def procDec: Parser[ProcDecPT] trong khi oneDec trả về Parser[List[...]] cơ mà Cao nhân nào giải thích giúp?"
librastar,1,9/30/2011,Re:Hỏi 1 tí về hàm oneDec và procDec,"Khai báo đầy đủ của hàm oneDec: def oneDec: Parser[List[SubtinePT]] = varDec | procDec ^^ { case a => List(a) } Bạn chú ý phần phía sau, procDec được đóng gói trong List rùi mới trả về."
Sy Nguyen,0,10/2/2011,hỏi về "delim" trong class CrazyLexical,"Thầy/các bạn cho hỏi về hàm delim trong hàm toke. nó có ý nghĩa gì,tìm nó ở đâu(trong class nào) với Scala doc"
Quái,1,10/2/2011,Re:hỏi về "delim" trong class CrazyLexical,Mình nghĩ nó là viết tắt của delimiters... còn tìm nó ở đâu thì... ;))ì
nguyen dung,1,9/25/2011,Thắc mắc về output,"Thưa thầy cho em hỏi 2 vấn đề 1- Nếu có hằng 1.2e0 không thỏa thì sẽ báo lỗi fail hay xuất ra 1.2identifier e0 ?, tương tự cho các trường hợp chuỗi và mảng. 2-Trong đề có ghi trường hợp .3e-30 là sai, trong đặc tả ghi sau e là chuỗi không rỗng , không bắt đầu bằng 0 chứ không nói là kết thúc phải khác 0 . Xin thầy giải đáp dùm, em xin cảm ơn."
n0b0dy,1,9/25/2011,Re:Thắc mắc về output,Cho em hỏi trường hợp [+-] phía trước số thực lun . Em thấy trong Đặc tả ko nêu trường hợp này Và cả trường hợp 1.2e0 nữa :)
nguyen dung,1,9/26/2011,Re:Thắc mắc về output,Cảm ơn thầy đã giải đáp
Hieu Bui,0,10/2/2011,Eclipse hông tạo ra scala Project,"hix...hông hiểu sao đang vik bt. thì dạo này mình import vô thì eclipse cứ mặc định tạo ra project của java.(có chứ J to tướng ở chỗ tên Project) Nên cái ass mỗi lân Run ... là nó thông báo hông có main Type. Thầy và các bạn ơi, giúp mình với..."
Quái,1,10/2/2011,Re:Eclipse hông tạo ra scala Project,"Thử tạo trước một cái Scala Project rỗng, rồi import mấy file đó vô, chắc ổn..."
Forever Alone,1,10/3/2011,Re:Eclipse hông tạo ra scala Project,Chọn File -> New -> Project -> Scala Wizard -> Scala Project xong rồi Next rồi đặt tên project là ra được Scala project (có chữ S nằm kế bên tên project). Còn lúc Run thì run file TestToken.scala vì hàm main nằm trong file đó mà.
Jang,1,9/26/2011,Re:Thắc mắc KQ Test2,Bạn xem lại kỹ đề đi.Đó là kiểu Boolean mà output ra 1 token như vậy là đúng rồi
n0b0dy,1,9/26/2011,Re:Thắc mắc KQ Test2,Ko bạn . Ra như vậy thì true phải là 1 keyword hoặc là 1 Operater . Ở đây trong đặc tả của thầy ko hề có key word là true hay false hoặc operator .
Thong Nguyen,1,9/28/2011,Thắc mắc KQ Test2,"Nếu true / false là keywords thì case class BooleanLit  không có tác dụng gì cả. Vả lại dòng 13 trang 2 lại không liệt kê true, false là keywords."
Nguyễn Đức Huy,1,10/1/2011,Re:Hỏi 1 tí về hàm oneDec và procDec,"Hì, cảm ơn bạn. Nhưng mình vẫn thắc mắc :( Bạn có thể giải thích tại sao các thầy lại khai báo procDec như vậy, để rồi ""đóng gói vào List trước khi trả về"". Khai báo def procDec: Parser[List[ProcDecPT]] luôn có phải tiện không? À, kí hiệu ^^ trong phần khai báo có nghĩa là gì vậy?"
librastar,1,10/1/2011,Re:Hỏi 1 tí về hàm oneDec và procDec,"Theo van Nasregas wrote: Hì, cảm ơn bạn. Nhưng mình vẫn thắc mắc :( Bạn có thể giải thích tại sao các thầy lại khai báo procDec như vậy, để rồi ""đóng gói vào List trước khi trả về"". Khai báo def procDec: Parser[List[ProcDecPT]] luôn có phải tiện không? À, kí hiệu ^^ trong phần khai báo có nghĩa là gì vậy? Kí hiệu '^^' bạn có thể xem trong doc hay là đọc ở bài viết này (nói chi tiết hơn một chút). Về hàm procDec, nếu để kiểu trả về là List[ProcDecPT]] cũng ko tiện hơn bao nhiêu, vẫn phải qua bước chuyển thành List. Kiểu trả về ProcDecPT vẫn hợp lý hơn,vì chức năng của hàm này chỉ parse 1 procedure mỗi lần được gọi."
Tin Bui,1,9/26/2011,Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala,"1/ Cho em hỏi là số real có các trường hợp này không: 0e-4 , e-5 2/ Một câu lệnh bình thường thì trong regex là ([a-z][a-zA-Z]*) còn trong scala thì lại ghi là (""[a-z][a-zA-Z]*"".r) thì em muốn hỏi cái ""..."".r là mục đích gì ? giả sử 1 câu regex có dạng như là (....)* thì phải ghi thế nào trên scala cho đúng? em ghi toàn mắc lỗi, Hix"
thanhnghi_py,1,10/6/2011,Hàm whitespace: Parser[Any] ?,Cho mình hỏi hàm whitespace: Parser[Any] trong file Crazy.scala để làm gì vậy? Có phải dùng để nhận dạng comment không.
MFC.Maximus,1,9/28/2011,Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala,"nếu bạn để ý một xíu khi đặt chuột lên trên chữ r thi nó có dạngdef r : scala.util.matching.Regex => r là một hàm va return type của nó là 1 Regex, bạn mở interpreter trong eclipse ra, gõ : import scala.util.matching._ val s = ""123"" s: java.lang.String = 123 s.r res0: scala.util.matching.Regex = 123 tới đây mình có thể hiểu r là 1 method cua lớp string thừa kế từ java :) to be continue.... thân"
Forever Alone,1,9/30/2011,Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala,.r có nghĩa là cho cái String đó thành kiểu Regex đó. Ở trên có hàm regex (r : Regex) nên biến truyền vào phải là 1 kiểu regex. Cái chuỗi "([a-z][a-zA-Z]*)" chỉ là một kiểu String thôi nên .r nữa nó mới thành kiểu Regex.
tuong vo,1,9/30/2011,Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala,cho em hỏi kiểu thực có chấp nhận số thực âm không? ví dụ: -1.02 có được chấp nhận không
Peter,1,10/1/2011,Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala,Guest User wrote: cho em hỏi kiểu thực có chấp nhận số thực âm không? ví dụ: -1.02 có được chấp nhận không Được chấp nhận đấy bạn. giả sử 1 số nguyên âm nhân với 1 số thực dương. kết quả sẽ là 1 số âm có kiểu thực
Forever Alone,1,10/1/2011,Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala,Peter-0989  wrote: Guest User wrote: cho em hỏi kiểu thực có chấp nhận số thực âm không? ví dụ: -1.02 có được chấp nhận không Được chấp nhận đấy bạn. giả sử 1 số nguyên âm nhân với 1 số thực dương. kết quả sẽ là 1 số âm có kiểu thực Mình thấy trong đặc tả đâu có nói phần sẽ có dấu "-" phía trước số thực hoặc số nguyên đâu. Anh Hùng ơi vô trả lời dùm tụi em với.
.                                . Kazumi              ..,1,10/6/2011,Re:giúp đỡ về xử lí số thực,cái này phải xét độ ưu tiên. cho phần o. lên trước thì phải.chưa test nữa.
Phạm Nguyên Trình,1,10/6/2011,Có số âm hay không?,"Theo như đặc tả thì Crazy Language của chúng ta không có số âm?! Thầy Hùng confirm lại giúp chúng em nhé. Kẻo làm ko có, tới khi testcase có thì chết chắc @@"
tuong vo,1,10/6/2011,Re:Có số âm hay không?,thày trả lời không rồi bạn
Trịnh Văn Giang,1,10/3/2011,Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala,"số real có các trường hợp này không: 0e-4 , e-5 Vậy trường hợp này có được chấp nhận không anh"
Bruce Wayne,1,10/3/2011,Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala,"Guest User wrote: số real có các trường hợp này không: 0e-4 , e-5 Vậy trường hợp này có được chấp nhận không anh Bạn xem kĩ lại trong file CrazySpec: ""Except a fraction portion may appear alone, at least 2 parts must appear together at the same time"" Vì vậy theo mình: 0e-4 được chấp nhận. Còn e-5 ko được chấp nhận (vì chỉ có phần exponent)"
xuan vinh,1,9/25/2011,dấu chấm,mọi người cho mình hỏi: khi mình chay ở chế độ interpreter mình import scala.util.matching._ vidu val regex=new Regex(" [1-9]\.[1-9] ") thì nó bão lỗierror: invalid escape character tại dấu chấm em chỉnh lại thành \\. và test thử thì chính xác nhưng lúc em hiện thực vào trong Crazy2011.scala và chạy test 1.3 thì nó báo lỗi sai ở dấu chấm với cả 2 cách trên có bạn nào biết trả lời giùm mình code: regex("[1-9]\.[1-9]".r)
Why So Serious,1,9/25/2011,dấu chấm,Vinh Vu Xuan wrote: mọi người cho mình hỏi: khi mình chay ở chế độ interpreter mình import scala.util.matching._ vidu val regex=new Regex(" [1-9]\.[1-9] ") thì nó bão lỗierror: invalid escape character tại dấu chấm em chỉnh lại thành \\. và test thử thì chính xác nhưng lúc em hiện thực vào trong Crazy2011.scala và chạy test 1.3 thì nó báo lỗi sai ở dấu chấm với cả 2 cách trên có bạn nào biết trả lời giùm mình code: regex("[1-9]\.[1-9]".r) Bạn thử "[1-9].[1-9]" xem thử?
Thanh Pham Minh,1,10/5/2011,Tên file cần nộp.,"Mong thầy xác nhận lại là tên file nộp có cần phân biệt chữ hoa, chữ thường không. Trong đặc tả và trên Sakai ghi là nộp file "" crazy2011.scala "" còn trong thư mục src thì có file "" Crazy2011.scala"" . Em cảm ơn."
.                                . Kazumi              ..,1,10/5/2011,Re:Tên file cần nộp.,"oh. Xem giờ mới để ý. Cái này quan trọng mà sao ko ai nói gì hết vậy. Lỡ phân biệt chử hoa, chữ thường thì công toi à."
Bruce Wayne,1,10/1/2011,Trường hợp tồn tại dấu nháy đơn trong chuỗi,Anh Hùng cho em hỏi là trong chuỗi có tồn tại 2 dấu nháy đơn nhưng cách nhau bởi các kí tự có được chấp nhận ko .Vd như: 'abc'de'fgh' có phải là chuỗi hợp lệ ko ạ
Lê Quốc Nam,1,10/1/2011,Re:Trường hợp tồn tại dấu nháy đơn trong chuỗi,Theo mình thì trường hợp này sẽ ra là "'abc'" identifer de "'fgh'"
xuan vinh,1,9/25/2011,Re:dấu chấm,"cũng ko đc luôn, mà nếu để dấu chấm đó thì nó hiểu là ký tự bất kỳ chán thật"
Jang,1,9/26/2011,Re:dấu chấm,Mình dùng \\. chạy ok mà bạn
Why So Serious,1,9/26/2011,Re:dấu chấm,"Vinh Vu Xuan wrote: cũng ko đc luôn, mà nếu để dấu chấm đó thì nó hiểu là ký tự bất kỳ chán thật À vậy là mình hiểu nhầm :D"
MFC.Maximus,1,9/28/2011,Re:dấu chấm,mấy bạn cho mình hỏi dấu ? có sử dụng trong scala được không khi mình test regex("1?".r) thì nó sẽ chạy vô hạn dấu xuống dòng =.=!
Bernkastel 奇跡の魔女,1,10/4/2011,Re:dấu chấm,"MFC.Maximus wrote: mấy bạn cho mình hỏi dấu ? có sử dụng trong scala được không khi mình test regex(""1?"".r) thì nó sẽ chạy vô hạn dấu xuống dòng =.=! Tại vì '?' là có hoặc ko, trong trường hợp này là ""1"" hoặc rỗng - tức là """", trong Scala bạn dùng regex rỗng sẽ chạy mãi đấy, thế nên khi thiết kế đừng để trường hợp rỗng xuất hiện. Vinh Vu Xuan wrote: val regex=new Regex("" [1-9]\.[1-9] "") thì nó bão lỗierror: invalid escape character tại dấu chấm em chỉnh lại thành \\. và test thử thì chính xác nhưng lúc em hiện thực vào trong Crazy2011.scala và chạy test 1.3 thì nó báo lỗi sai ở dấu chấm với cả 2 cách trên có bạn nào biết trả lời giùm mình code: regex(""[1-9]\.[1-9]"".r) tốt nhất là cậu đổi lại thành (""""""[1-9]\.[1-9]"""""" .r) sẽ chạy bình thường."
Phạm Nguyên Trình,1,10/6/2011,Re:dấu chấm,"Vừa được 1 pro chỉ giáo, để thế này cũng chạy bình thường nè :D (""""""[1-9][.][1-9]"""""" .r)"
Phạm Nguyên Trình,1,10/6/2011,Re:Tên file cần nộp.,File zip tải về thế nào thì giữ nguyên như vậy mà nộp. Chắc thầy hok rảnh đi đổi tên file đâu =))
FirstName LastName,1,10/6/2011,Re:Tên file cần nộp.,Thầyơi xác nhận lại có cầnđổi tên file ko vậy @@
sat long,1,10/6/2011,Re:Tên file cần nộp.,chết thật!
Forever Alone,1,10/6/2011,Re:Tên file cần nộp.,Chắc do có vấn đề nhầm lẫn trong lúc gõ tên. Chắc thầy không bắt bẻ mấy vụ này đâu :D
Thanh Pham Minh,1,10/6/2011,Tên file cần nộp.,Nhưng mình sai thì sẽ có bắt bẻ đấy :p
Bruce Wayne,1,10/1/2011,Re:Trường hợp tồn tại dấu nháy đơn trong chuỗi,"Vậy là có nghĩa là hai dấu nháy đơn liền nhau mới xuất ra nguyên chuỗi, còn nếu cách nhau thì chuỗi sẽ bị tách ra"
walk alone,1,10/1/2011,Re:Trường hợp tồn tại dấu nháy đơn trong chuỗi,"định nghĩa string ở đây là bất cứ gì ở giữa hai dấu '  liên tiếp nhau, nếu trong string mà muốn có ' thì phải thêm một dấu phía sau ' nữa,         nếu xuất hiện chỉ một ' thì sẽ báo error token :-? mình nghĩ thế."
Tong Ngoc Hoa,1,10/7/2011,Re:Trường hợp tồn tại dấu nháy đơn trong chuỗi,Vo Thanh Hung wrote: Phung Chi Kien wrote: Mình ra thế này: " 'abc' " indentifier de " 'fgh' " Không biết các bạn thế nào? :( Đúng rồi. Ủa không có EOF sao thầy?
LAV,1,10/9/2011,Thắc mắc 1 testcase real const,"Theo các bạn, trường hợp này được chấp nhận hay ko? 1e .9e Kết quả là gì? 1e .9e hay 1 identifier e .9 identifier e"
Nhat Nguyen,1,10/9/2011,Thắc mắc 1 testcase real const,"LAV  wrote: Theo các bạn, trường hợp này được chấp nhận hay ko? 1e .9e Kết quả là gì? 1e .9e hay 1 identifier e .9 identifier e 1 identifier e .9 identifier e The exponent part starts with the letter „E‟ or „e‟, followed optionally by the negative sign (i.e. - or none) and a non-empty sequence of digit s that never begins with 0."
Phạm Nguyên Trình,1,10/12/2011,Thắc mắc 1 testcase real const,"LAV  wrote: Theo các bạn, trường hợp này được chấp nhận hay ko? 1e .9e Kết quả là gì? 1e .9e hay 1 identifier e .9 identifier e Đọc ko kỹ đặc tả! >""<"
Tong Ngoc Hoa,1,10/13/2011,Nộp nhầm file,"Chào thầy, Em là: Tống Ngọc Hòa MSSV: 50900960 Em đã nộp nhầm file gốc của thầy mong thầy xem xét Cảm ơn thầy"
Pham  Van Giang,1,10/12/2011,Re:Thắc mắc 1 testcase real const,Do đặc tả viết phần nguyên của số thực giống phần đặc tả số nguyên nên mình ra thế này: 1 identifier e ErrorToken . 9 identifier e EOF (không ra .9 vì theo đặc tả phải là 0.9 mặc dù ví dụ của thầy lại ghi là .3e-30) không biết đúng không nữa
Pham  Van Giang,1,10/12/2011,Re:Thắc mắc 1 testcase real const,vậy .12 khi xuất ra là 0.12 hay .12. theo đặc tả nó phải có phần nguyên và đưcọ ngăn cách với nhau bằng dấu "." . nên khi xuất ra kết quả mình nghĩ phải là : ErrorToken . 12 EOF
Minh Triet Pham Tran,1,10/13/2011,Re:Thắc mắc 1 testcase real const,Pham  Van Giang wrote: vậy .12 khi xuất ra là 0.12 hay .12. theo đặc tả nó phải có phần nguyên và đưcọ ngăn cách với nhau bằng dấu "." . nên khi xuất ra kết quả mình nghĩ phải là : ErrorToken . 12 EOF Mình xuất ra: .12 EOF
nguyen tat an khoa,1,10/6/2011,Mot truong hop trong chuoi string,Cho mình hỏi nếu mình có một chuỗi 'abc ef ' Thì khi output trả về là " ' abc ef ' " hay là `'' identifier abc identifier de `''
.                                . Kazumi              ..,1,10/6/2011,Re:Mot truong hop trong chuoi string,"Cho mình hỏi mấy chuổi sau kết quả như thế nào ( nếu hỏi sai xin nói rõ, đừng buông câu chua chát nha) 'vng anh\kk\naaaa' 'abd""ghai' (dấu ở giữa nháy đôi) 'abd?bac' 'abcabc""abc""abc' (dấu ở giữa nháy đôi) 'aAB5a'"
tuong vo,1,10/6/2011,Re:Mot truong hop trong chuoi string,"Cho mình hỏi mấy chuổi sau kết quả như thế nào ( nếu hỏi sai xin nói rõ, đừng buông câu chua chát nha) 'vng anh\kk\naaaa' 'abd""ghai' (dấu ở giữa nháy đôi) 'abd?bac' 'abcabc""abc""abc' (dấu ở giữa nháy đôi) 'aAB5a' tớ ra giống input của bạn luôn ví dụ : inpt là : 'vng anh\kk\naaaa' output là : ""'vng anh\kk\naaaa'"" EOF"
.                                . Kazumi              ..,1,10/6/2011,Re:Mot truong hop trong chuoi string,"tất cả mọi ký hiệu kể cả khoảng trắng nằm trong 2 nháy đơn đều xuất ra hết luôn à? TH này thì sao: 'abcabc,abc' Op là: error : ' | id: abcabc | ',' | id: abc | error : ' phải ko?"
tuong vo,1,10/6/2011,Re:Mot truong hop trong chuoi string,"kết quả của mình ""'abcabc,abc'"" EOF"
nguyen dung,1,10/6/2011,Re:Mot truong hop trong chuoi string,The character set ∑ of Crazy is the characters in ASCII. Any character in ∑ except a newline character can be appeared in a string constant.
Phạm Nguyên Trình,1,10/6/2011,Mot truong hop trong chuoi string,nguyen tat an khoa wrote: Cho mình hỏi nếu mình có một chuỗi 'abc ef ' Thì khi output trả về là " ' abc ef ' " hay là `'' identifier abc identifier de `'' Của mình là thế này: ErrorToken ' identifier abc identifier ef ErrorToken ' EOF
Phạm Nguyên Trình,1,10/6/2011,Re:Mot truong hop trong chuoi string,"_vQ wrote: Cho mình hỏi mấy chuổi sau kết quả như thế nào ( nếu hỏi sai xin nói rõ, đừng buông câu chua chát nha) 'vng anh\kk\naaaa' 'abd""ghai' (dấu ở giữa nháy đôi) 'abd?bac' 'abcabc""abc""abc' (dấu ở giữa nháy đôi) 'aAB5a' Của tớ: ""'vng anh\kk\naaaa'"" ""'abd""ghai'"" ""'abd?bac'"" ""'abcabc""abc""abc'"" ""'aAB5a'"" EOF"
.                                . Kazumi              ..,1,10/7/2011,Mot truong hop trong chuoi string,Phạm Nguyên Trình wrote: nguyen tat an khoa wrote: Cho mình hỏi nếu mình có một chuỗi 'abc ef ' Của mình là thế này: ErrorToken ' identifier abc identifier ef ErrorToken ' EOF ủa. của mình ra vậy: `'' identifier abc identifier ef `'' EOF
.                                . Kazumi              ..,1,10/7/2011,Re:Mot truong hop trong chuoi string,Ip: ' ' ' ' ' abc'abc abc' 'abc\nabc' Op: "' '" "' '" `'' identifier abc `'' identifier abc identifier abc `'' "'abc\nabc'" EOF có đúng ko ta?
LAV,1,10/7/2011,Re:Mot truong hop trong chuoi string,_vQ wrote: Ip: ' ' ' ' ' abc'abc abc' 'abc\nabc' Op: "' '" "' '" `'' identifier abc `'' identifier abc identifier abc `'' "'abc\nabc'" EOF có đúng ko ta? Mình ra như thế lun đấy
silverit,1,10/10/2011,Các Test Case "Hóc Búa" Về String,Input: Case 1: 'abc\n' Case 2: 'abc de' Output??? ^^
Why So Serious,1,10/10/2011,Các Test Case "Hóc Búa" Về String,Phuong Vo Le Anh wrote: Input: Case 1: 'abc\n' Case 2: 'abc de' Output??? ^^ Của mình: Case 1: "'abc\n'" Case 2: ErrorToken ' identifier abc identifier de ErrorToken '
Cơn Mưa Tình Yêu,1,10/5/2011,Xử lý string,"Các bạn cho mình hỏi test2: const d = 1.23e-1; const e = 12; const f = 'qeqwe''qwrqwr'; const g = true; const h = [23;45;2]; khi phân tích token: const f = 'qeqwe''qwrqwr'; thì có cần dấu ngoặc kép kẹp giữa string 'qeqwe''qwrqwr' , sao mình tìm hoài mà chả biết làm sao để nó xuất ra dấu ngoặc kép nữa. Thanks!"
.                                . Kazumi              ..,1,10/7/2011,Re:Mot truong hop trong chuoi string,"c. ronaldo wrote: Anh Hùng nói ' không phải là token mà, code cho dư, coi ở Notice đi thanks nha. vậy là mình phải xoá đi à. Nhưng mình vẫn khác cronaldo nè. ""' '"" ""' '"" ErrorToken ' identifier abc ErrorToken ' identifier abc identifier abc ErrorToken ' ""'abc\nabc'"" EOF"
hieu nguyen,1,10/10/2011,Re:nộp assignment PPL,Mình cũng thắc mắc giống bạn này. Mong có reply sớm để nộp bài. THANKS.
Quái,1,10/10/2011,Re:nộp assignment PPL,"Chiều thầy có nói, thay tên thầy Hung bằng tên mình, sau đó thêm 1 dòng MSSV nữa..."
.                                . Kazumi              ..,1,10/11/2011,Re:nộp assignment PPL,Không bít Tên có được viết có dấu ko? Lỡ Comment có dấu nó ko dịch được thì khổ.
FirstName LastName,1,10/11/2011,Re:nộp assignment PPL,Sao mình ko nghe j nhỉ @@
tran danh hung,1,10/11/2011,Re:nộp assignment PPL,_vQ wrote: Không bít Tên có được viết có dấu ko? Lỡ Comment có dấu nó ko dịch được thì khổ. mắc cười quá :))
Nhất Tiếu nại Hà,1,10/10/2011,Các Test Case "Hóc Búa" Về String,của mình the same case1: "'abc\n'" EOF case2: ErrorToken ' identifier abc identifier de ErrorToken ' EOF
silverit,1,10/10/2011,Các Test Case "Hóc Búa" Về String,Các bạn có thể cho mình biết ký tự NewLine trong scala là gì không? Tình hình thì NewLine trong AscII là \n (0x0a). Mình code scala trên win.
silverit,1,10/10/2011,Các Test Case "Hóc Búa" Về String,Mình hiểu lý do mình sai rồi! Thanks các bạn :). Nảy để cái regex("""...""") ^^ nên nó không nhận!
Bruce Wayne,1,10/11/2011,Các Test Case "Hóc Búa" Về String,Nhất Tiếu nại Hà  wrote: của mình the same case1: "'abc\n'" EOF case2: ErrorToken ' identifier abc identifier de ErrorToken ' EOF same :D
Tin Bui,1,10/11/2011,Re:Các Test Case "Hóc Búa" Về String,Vậy trong cái StringList mình ghi [^\n] nghĩa là ngăn ko cho xuống hàng phải không?
nguyen dung,1,10/11/2011,Re:Các Test Case "Hóc Búa" Về String,Cho mình hỏi "*" và "/" có phải là delimitter không?
hieu nguyen,1,10/11/2011,Re:Các Test Case "Hóc Búa" Về String,còn thêm test case nào nữa ko các bạn . Thanks
.                                . Kazumi              ..,1,10/11/2011,Re:Các Test Case "Hóc Búa" Về String,"We miss u,mr.Steve Jobs  wrote: Vậy trong cái StringList mình ghi [^\n] nghĩa là ngăn ko cho xuống hàng phải không? HÌnh như là [^\\n]"
Quái,1,10/5/2011,Re:Xử lý string,thêm  "^^ { StringLit(_) } vào cuối cái regex dành cho String thử xem bạn...
Cơn Mưa Tình Yêu,1,10/5/2011,Re:Xử lý string,Rec4rx  wrote: thêm  "^^ { StringLit(_) } vào cuối cái regex dành cho String thử xem bạn... thanks bạn! đúng rồi. Còn có cái hàm đó mà mấy thầy cũng ko cho sẵn luôn.
Phạm Nguyên Trình,1,10/6/2011,Re:Xử lý string,"Nếu input thế này: 'abcde', 'wouldn''t, shouldn''t, couldn''t', '' Thì kết quả trả về sẽ thế nào? Ai làm rùi share kết quả với. của mình, kết quả là: ""'abcde'"" `,' ""'wouldn'"" ErrorToken ' identifier t `,' identifier shouldn ""''"" identifier t `,' identifier couldn ""''"" identifier t ErrorToken ' `,' ""''"" EOF đúng hem ta?"
Nhat Nguyen,1,10/6/2011,Re:Xử lý string,"Phạm Nguyên Trình wrote: Nếu input thế này: 'abcde', 'wouldn''t, shouldn''t, couldn''t', '' Thì kết quả trả về sẽ thế nào? Ai làm rùi share kết quả với. của mình, kết quả là: ""'abcde'"" `,' ""'wouldn'"" ErrorToken ' identifier t `,' identifier shouldn ""''"" identifier t `,' identifier couldn ""''"" identifier t ErrorToken ' `,' ""''"" EOF đúng hem ta? me too"
.                                . Kazumi              ..,1,10/6/2011,Re:Xử lý string,
aa a,0,10/9/2011,Re:Xử lý string,"cho mình hỏi thì theo đề là chuỗi là tập hợp character giữa 2 dấu ' ',và nếu như có 1 dấu ' giữa các chữ thì phải có thêm 1 dấu ' nữa theo ví dụ thì 'abcde', 'wouldn''t, shouldn''t, couldn''t', đều là chuỗi thì nó phải xuất hết ra giữa dấu """" chứ sao lại có kết quả như các bạn"
aa a,0,10/9/2011,Re:Xử lý string,"Guest User wrote: cho mình hỏi thì theo đề là chuỗi là tập hợp character giữa 2 dấu ' ',và nếu như có 1 dấu ' giữa các chữ thì phải có thêm 1 dấu ' nữa theo ví dụ thì 'abcde', 'wouldn''t, shouldn''t, couldn''t', đều là chuỗi thì nó phải xuất hết ra giữa dấu """" chứ sao lại có kết quả như các bạn nếu chuỗi là asd''''fgh(3 dấu ') thì có đúng o"
Tuan Vu Quang,0,10/12/2011,Re:Xử lý string,Rec4rx  wrote: thêm  "^^ { StringLit(_) } vào cuối cái regex dành cho String thử xem bạn... Sao mình thử như bạn thì lại bị lỗi nhỉ
Nguyen Vinh,1,10/12/2011,Re:Những ký tự sử dụng trong String,"Thấy và các bạn cho mình hỏi, những ký tự nào  được sử dung trong một chuỗi (string) vây? Mình đặc biệt muốn nói đến  những ký tự đặc biệt như dấu *, +, ?, \, ""."" . Nhân tiện cho mình hỏi  làm cách nào add nó vào regex mà không bị báo lỗi (nếu chuỗi cho phép  chứa nó). bạn add trong delimiter đó à, cho mình hỏi thêm là các số như 0.0, .0, 0.234E-5, 12.0 có thể xem là các số hợp lệ không? (vừa đúng theo mô tả của đề bài) tất cả đều hợp lệ bạn à!"
Tuan Vu Quang,0,10/12/2011,Những ký tự sử dụng trong String,Cho mình hỏi cái tên khi khai báo mảng và chuỗi hằng là gì vậy Ví dụ Id là processIdent; Int là NumericLit
_Trung_Than_Thong,1,10/12/2011,Re:Những ký tự sử dụng trong String,"Trong Slide bài giảng có một kí tự chấp nhận mọi kí tự (kể cả dấu xuống dòng). Ngĩa là thay vì khi định nghĩa string các bạn liệt kê ra các trường hợp hợp lệ (trong regex) thì hãy liệt kê những trường hợp không hợp lệ (vd: endline character,..) rồi dùng kí tự kia ^ đi"
Phạm Nguyên Trình,1,10/12/2011,Re:Những ký tự sử dụng trong String,Phan Nguyen wrote: s = ' abc(]*+-\?' KQ of mình: identifier s `=' "' abc(]*+-\?'" EOF
Nguyen Vinh,1,10/12/2011,Re:Những ký tự sử dụng trong String,Phạm Nguyên Trình wrote: Phan Nguyen wrote: s = ' abc(]*+-\?' KQ of mình: identifier s `=' "' abc(]*+-\?'" EOF me too!
Minh Triet Pham Tran,1,10/12/2011,Re:Các Test Case "Hóc Búa" Về String,Mình cũng ra kq như bạn Just A Tee .
.                                . Kazumi              ..,1,10/7/2011,Mọi người test thử chuổi này xem,const stringConst1='''a_'''' const stringConst2='''a_''''' const stringConst3=''''a_''' const boolConst1=true const boolConst3=faLse
nguyen dung,1,10/12/2011,Những ký tự sử dụng trong String,"Phan Nguyen wrote: Thấy và các bạn cho mình hỏi, những ký tự nào được sử dung trong một chuỗi (string) vây? Mình đặc biệt muốn nói đến những ký tự đặc biệt như dấu *, +, ?, \, ""."" . Nhân tiện cho mình hỏi làm cách nào add nó vào regex mà không bị báo lỗi (nếu chuỗi cho phép chứa nó). Thì bạn dùng 2 cách 1) Dùng \. 2) Dùng [^(ký tự cần loại ra)] Thường thì mình hay dùng cách 2 trong trường hợp số ký cần loại là ít"
Nhat Nguyen,1,10/7/2011,Re:Mọi người test thử chuổi này xem,c. ronaldo wrote: `const' identifier stringConst1 `=' "'''a_'''" ErrorToken ' `const' identifier stringConst2 `=' "'''a_'''''" `const' identifier stringConst3 `=' "''''" identifier a_ "''" ErrorToken ' `const' identifier boolConst1 `=' `true' `const' identifier boolConst3 `=' identifier faLse EOF mình ra vậy minh cung ra the nay
thinh van,1,10/8/2011,Re:Mọi người test thử chuổi này xem,"ủa, cho mình hỏi sao phân biệt được: '''asass'''' '''sdsd'' là 2 hàng khác nhau hay là một chuỗi như thế này za? ' ''asass'''' ''' sdsd''"
thinh van,1,10/8/2011,Re:Mọi người test thử chuổi này xem,"hix, cho mình hỏi lun sao mà với chuỗi trên output của mình lại ra thế này: "" '''asass''''''' "" identifier sdsd "" ' ' "" EOF thanks bạn :)"
.                                . Kazumi              ..,1,10/8/2011,Re:Mọi người test thử chuổi này xem,c. ronaldo wrote: identifier stringConst3 `=' "''''" identifier a_ "''" ErrorToken ' EOF mình ra vậy phải là vậy chứ: identifier stringConst3 `=' "''''a_''" ErrorToken ' Tại vì: '' '' a_''' ' '''a_' '' ''''a_'' ' phần đỏ là chuỗi
Nhất Tiếu nại Hà,1,10/8/2011,Re:Mọi người test thử chuổi này xem,ban nao test thu cai nay xem: const boolConst1=' 'a_1as_2' const boolConst2="asd___12" ' const boolConst3='a32_23_sda' ' ' " "
Nhất Tiếu nại Hà,1,10/8/2011,Re:Mọi người test thử chuổi này xem,ok.giống tớ khúc đầu...:D:D `const' identifier boolConst1 `=' "''" identifier a_1as_2 ErrorToken ' `const' identifier boolConst2 `=' ErrorToken " identifier asd___12 ErrorToken " ErrorToken ' `const' identifier boolConst3 `=' "'a32_23_sda'''" ErrorToken " ErrorToken " EOF sao chổ này mình khác nhở???? kai String chổ này có chấp nhận phía trong nó nhiều dấu ' ko? nếu chổ này 'a32_23_sda' ' ' " " bác c. ronaldo ra "'a32_23_sda'" "' '" có nghĩa là nó tới dấu ' sau indentifier a32_23_sda là kết thúc 1 chuỗi chia kai ' ' phía sau ra một chuỗi mới nhưng cái test phía trên của bác _vQ : const stringConst1='''a_'''' const stringConst2='''a_''''' const stringConst3=''''a_''' kai Const1 lại là: `const' identifier stringConst1 `=' "'''a_'''" ErrorToken ' `const' chổ này nó mâu thuẫn sao ak' nhở??? đáng lẽ nếu theo bác c. ronaldo nó sẽ chạy là " ' ' " " 'a_' '' " ' ' " ErrorToken '
Nhất Tiếu nại Hà,1,10/8/2011,Re:Mọi người test thử chuổi này xem,bác c. ronaldo có thể nói rõ chổ này tí đc ko? const boolConst3= 'a32_23_sda' ' ' " " đáng lẽ kai mày đỏ là chuổi chứ bác
Nhất Tiếu nại Hà,1,10/8/2011,Re:Mọi người test thử chuổi này xem,"c. ronaldo wrote: chuỗi thì k có xún dòng, bắt đầu và kết thúc chuỗi là kí tự ', nếu ở giữa có xuất hiện ' thì nó phải thuộc ''. cứ thế mà làm thôi bạn '''asass''' ' '''sdsd' ' màu đỏ là chuỗi đó giống như cái này của bác đó"
Nhất Tiếu nại Hà,1,10/8/2011,Re:Mọi người test thử chuổi này xem,c. ronaldo wrote: 'a32_23_sda' ' ' " " bạn chú ý là ở giữa là '' chứ k phải là ' ' ( tồn tại khoảng trắng ở giữa) cái ví dụ bạn đưa là kí tự '' hết kai' tớ đưa là 4 dấu nháy đơn đầu.....và 2 dấu nháy kép cuối đó.............. 'a32_23_sda' ' ' " "
Tuan Vu Quang,0,10/12/2011,Những ký tự sử dụng trong String,"Ẹc, làm 1 hồi giờ cứ String vào là ko chạy được. Chết dở rồi Để regex(""[^\\n]*"".r) ^^ { StringLit(_) } như này cũng lỗi Ai giúp mình cái"
Tuan Vu Quang,0,10/12/2011,Những ký tự sử dụng trong String,"_HNA_  wrote: Tuan Vu Quang wrote: Ẹc, làm 1 hồi giờ cứ String vào là ko chạy được. Chết dở rồi Để regex(""[^\\n]*"".r) ^^ { StringLit(_) } như này cũng lỗi Ai giúp mình cái mình chỉ để ^\n nó vẫn k nhận xún dòng dc mà bạn Ý mình là chuỗi nhận mọi ký tự, trừ ký tự xuống dòng Nhưng mà ý mình hỏi ở đây là bây giờ file input của mình nó chỉ nhận số, còn chữ, chuỗi nó ko nhận được. Kể cả var, const ... nó cũng ko nhận được Ko biết lỗi là ở đâu"
Tuan Vu Quang,0,10/12/2011,Những ký tự sử dụng trong String,"Cũng vậy, mình có thử rồi Bây giờ nếu input chỉ có số thì ok, nếu có cả chữ và số thì nó đơ"
Tri,1,10/12/2011,Những ký tự sử dụng trong String,"Tuan Vu Quang wrote: Cũng vậy, mình có thử rồi Bây giờ nếu input chỉ có số thì ok, nếu có cả chữ và số thì nó đơ ^(\n) thoi ban"
Tuan Vu Quang,0,10/12/2011,Những ký tự sử dụng trong String,"Administrator  wrote: ^(\n) thoi ban Hiện giờ lỗi chính của mình là nó ko nhận số và chữ cùng 1 lúc được Mình nhận thấy nếu ko có FloatLit thì ok, thêm vào thì chỉ có thể nhận được số Bực quá mà chưa biết cách sửa"
Minh Triet Pham Tran,1,10/12/2011,Re:Những ký tự sử dụng trong String,"Phan Nguyen wrote: có lẽ mình diễn đạt kém làm bạn hiểu nhầm ý mình. Ý mình là giả sử ta có biến kiểu string được gán như sau: s = ' abc(]*+-\?' khi đó những ký tự đặc biệt như *, ?.\ phải diễn đạt thế nào trong regex của phần string, bởi vì nó cũng là ký tự điều khiển nên liên tục báo lỗi, mình không biết làm cách nào. còn khai báo trong delimiter thì hình như chỉ có tác dụng khai báo các dấu phân cách thôi mà bạn Kết quả của mình: identifier s `=' ""' abc(]*+-\?'"" EOF"
Nhất Tiếu nại Hà,1,10/8/2011,Re:Mọi người test thử chuổi này xem,"a32_23_sda' ' ' "" "" ý cậu là cái phần màu đỏ là chuỗi hả? k đúng, tại ở giữa chỉ dc là '' ( nháy kép ) chứ k dc là ' ' đâu. cái này chuỗi là 'a32_23_sda' thôi cậu coi lại chỗ '' và ' ' , 2 cái đó khác nhau đó nha ''''a_''' cái này là dấu '' 'a32_23_sda' ' ' "" "" ->dấu ' '"
Nhất Tiếu nại Hà,1,10/8/2011,Re:Mọi người test thử chuổi này xem,"a32_23_sda' ' ' "" "" ý cậu là cái phần màu đỏ là chuỗi hả? k đúng, tại ở giữa chỉ dc là '' ( nháy kép ) chứ k dc là ' ' đâu. cái này chuỗi là"
.                                . Kazumi              ..,1,10/8/2011,Re:Mọi người test thử chuổi này xem,'a32_23_sda'
Tri,1,10/8/2011,Re:Mọi người test thử chuổi này xem,
aa a,0,10/9/2011,Re:Mọi người test thử chuổi này xem,"Đúng là 7 nháy đơn, nhưng ở giữa 2 nháy đơn '' là hợp lệ, còn có khoảng trắng giữa 2 dấu ' thì k dc ' '' a_ '' '' màu đen là nháy kép đó, kết thúc là ', nên nó còn dư ra một dấu '"
nguyen dung,1,10/10/2011,Re:Mọi người test thử chuổi này xem,"c. ronaldo wrote: ' '' a_ '' '' màu đen là nháy kép đó, kết thúc là ', nên nó còn dư ra một dấu ' ok......:D thank bác!...nhầm chổ này tưởng nháy đơn hết...:D:D vì tớ đang thấy đặc tả chổ này có tí vấn đề: If a single-quote belongs to the string constant, it must be duplicated."
Tuan Vu Quang,0,10/12/2011,Mọi người test thử chuổi này xem,"c. ronaldo wrote: Đúng là 7 nháy đơn, nhưng ở giữa 2 nháy đơn '' là hợp lệ, còn có khoảng trắng giữa 2 dấu ' thì k dc ' '' a_ '' '' màu đen là nháy kép đó, kết thúc là ', nên nó còn dư ra một dấu ' @ thiensuvodanh : như vầy nè bạn, bạn hiểu đúng là khi có ' tồn tại trong chuỗi thì nó phải là '' (2 dấu nháy đơn kề nhau). còn cái test ra 2 chuỗi tách biệt dù có 2 dấu nháy đôi phía sau 'A___xxxx' ' ' ''' (tất cả đều là nháy đơn) là do nó có space nên không chấp nhận cùng chuỗi."
Minh Triet Pham Tran,1,10/12/2011,Mọi người test thử chuổi này xem,"c. ronaldo wrote: chuỗi thì k có xún dòng, bắt đầu và kết thúc chuỗi là kí tự ', nếu ở giữa có xuất hiện ' thì nó phải thuộc ''. cứ thế mà làm thôi bạn '''asass''' ' '''sdsd' ' màu đỏ là chuỗi đó sao đề đặt tả là chuỗi đó không được có kí tự xuống dòng Any character in ∑ except a newline character can be appeared in a string constant còn If a single-quote belongs to the string constant, it must be duplicated. nghĩa là gì ?theo mình thì chuỗi đó ở giữa có 1 dấu ' thì phải thêm 1 dấu ' nữa"
Jang,1,9/23/2011,Cách compile các file,Anh Hùng có thể hướng dẫn tụi em cách compile những file này như thế nào được ko ạh?
Nguyễn Đức Huy,1,9/25/2011,Re:Cách compile các file,"Anh ơi hướng dẫn em cách sử dụng Eclipse hỗ trợ Scala với. Sau khi import xong, e chưa chỉnh sửa code gì cả, chỉ chạy bằng menu Run configurations..., chọn Scala Application, Main Class là TestToken. Vậy mà khi chạy nó lại báo lỗi ""Could not find the main class: TestToken. Program will exit"" Ôi, em chưa rành thằng Scala này nên đau đầu quá :(("
Long Hoang Ngoc,0,9/25/2011,Cách compile các file,"Lúc bạn Import xong, ở cái Package Explorer bên trái ấy, bạn mở assignment1->src->(default package). Chuột phải vào cái TestToken.scala, chọn Run as->Scala Application"
facebook.com,1,10/11/2011,Cách compile các file,"Mình mới sử dụng Scala nên chưa biết xài cho lắm. Bạn nào giúp mình biên dịch Scala giùm cái. Mình dùng CMD trong win scalac TeskToken.scala thì nó báo lỗi: 'scalac' is not recognized as an internal or external command, operable program or batch file. Mình không biết phải làm sao nữa. Mong các bạn giúp đỡ... Chân thành cám ơn..."
Quái,1,10/11/2011,Cách compile các file,"Van Persie wrote: Mình mới sử dụng Scala nên chưa biết xài cho lắm. Bạn nào giúp mình biên dịch Scala giùm cái. Mình dùng CMD trong win scalac TeskToken.scala thì nó báo lỗi: 'scalac' is not recognized as an internal or external command, operable program or batch file. Mình không biết phải làm sao nữa. Mong các bạn giúp đỡ... Chân thành cám ơn... Lỗi đó là do bạn chưa cài biến mỗi trường cho cmd, nên nó chưa hiểu đó là lệnh..."
facebook.com,1,10/11/2011,Cách compile các file,Cám ơn bạn! Bạn cho mình hỏi cài BIẾN MÔI TRƯỜNG như thế nào. Cám ơn nhiều
Quái,1,10/11/2011,Re:Cách compile các file,"Đầu tiên bạn vào trang http://www.scala-lang.org/downloads để download 1 phiên bản scala tùy chọn... Sau khi tải về, bạn giải nén ra thư mục nào đó, ví dụ C:\scala. Tiếp theo, bạn vào Start -> chuột phải vào Computer -> Properties -> Advanced System settings -> Environment Variables tới đây, nó hiện ra cửa sổ Environment Variables, bạn tìm đến biến có tên Path ( Hoặc PATH) -> edit, thêm vào đường dẫn đến thư mục \bin trong folder scala vừa mới giải nén, ví dụ nếu giải nén file scala down về như đường dẫn trên, thì bạn thêm ;C:\scala\bin vào... restart cmd, gõ thử scala hay scalac để kiểm tra..."
facebook.com,1,10/11/2011,Cách compile các file,Cám ơn bạn rất nhiều!!!
M.U.,1,10/11/2011,Re:Cách compile các file,Thanks all.
MFC.Maximus,1,10/12/2011,Re:Cách compile các file,"cho mình hỏi, mình đã làm đúng như trên, khi gõ ""scalac TestToken.scala"" thì nó báo lỗi not found : type CrazyLexical val lexical = new CrazyLexical ai biết cách sửa không :D"
Tuan Vu Quang,0,10/12/2011,[Gấp]Lỗi. Mọi người vào giúp,"Lúc đầu chạy rất ok Trongoverride def token, mình viết theo thứ tự Id, String, Float, Int. Test các trường hợp của số thực thấy đúng hết. Khi chuyển sang viết cái String, mình có thêm vào reserved và delimiter Viết regex cho String đơn giản như này  regex(""['][^(\n)][']"".r) ^^ { StringLit(_) } Giờ mình cho in:  var a = true;  thì nó chỉ chạy đến indenti a rồi đơ luôn Còn nếu xóa cái float kia đi thì nó chạy bình thường Có ai biết mình bị sai ở đâu ko, giúp mình cái"
Tin Bui,1,10/12/2011,[Gấp]Lỗi. Mọi người vào giúp,"Tuan Vu Quang wrote: Lúc đầu chạy rất ok Trongoverride def token, mình viết theo thứ tự Id, String, Float, Int. Test các trường hợp của số thực thấy đúng hết. Khi chuyển sang viết cái String, mình có thêm vào reserved và delimiter reserved ++= List(""true"", ""false"",""and"", ""continue"", ""of"", ""then"", ""array"", ""div"", ""function"", ""or"", ""begin"", ""do"", ""if"", ""loop"", ""procedure"", ""boolean"", ""integer"", ""var"", ""break"", ""else"", ""mod"", ""real"", ""while"", ""const"", ""end"", ""not"", ""return"", ""string"") delimiters ++= List("","", "":"", "";"", "":="", ""("", "")"", ""["", ""]"", ""+"", ""-"", ""*"", ""/"", ""="", "">"", "">="", ""<"", ""<="", ""<>"", ""^"", ""."") Viết regex cho String đơn giản như này  regex(""['][^(\n)][']"".r) ^^ { StringLit(_) } Giờ mình cho in:  var a = true;  thì nó chỉ chạy đến indenti a rồi đơ luôn Còn nếu xóa cái float kia đi thì nó chạy bình thường Có ai biết mình bị sai ở đâu ko, giúp mình cái hix! cái này bạn lộ hết bí mật quốc gia rùi ^_^, mình cũng có cấu trúc khá giống như thế, có hơi khác một tí phần tiểu tiết, nêu cũng ko rõ lắm bạn sai cái gì nữa, up lên hộ bạn để ai biết giúp, ko hết deadline"
Tuan Vu Quang,0,10/12/2011,[Gấp]Lỗi. Mọi người vào giúp,Có ai biết lỗi này chỉ mình với. Ức chế quá :((
V For,1,10/12/2011,Re:[Gấp]Lỗi. Mọi người vào giúp,"//Tuan Vu Quang: Viết regex cho String đơn giản như này  regex(""['][^(\n)][']"".r) ^^ { StringLit(_) } trong ví dụ của bạn var a = true; không có string nhưg mà chương trình vẫn bị dừng nên mình nghĩ lỗi chương trình khôgn chạy tiếp được k phải do regex string của bạn Tuy nhiên : Thứ 1: regex của bạn thiếu ở chổ không chấp nhận dấu nháy đơn ' đứng một mình. Thứ 2: Bạn nên viết biểu thức regex ra trên giấy chính xác, sau đó viết lệnh như sau: regex(""""""............."""""".r) ^^ { StringLit(_) } // 6 dấu nháy kép ............. là biểu thức regex của bạn."
Tuan Vu Quang,0,10/12/2011,Re:[Gấp]Lỗi. Mọi người vào giúp,"tran ngoc duc wrote: //Tuan Vu Quang: Viết regex cho String đơn giản như này  regex(""['][^(\n)][']"".r) ^^ { StringLit(_) } trong ví dụ của bạnvar a = true; không có string nhưg mà chương trình vẫn bị dừng nên mình nghĩ lỗi chương trình khôgn chạy tiếp được k phải do regex string của bạn Tuy nhiên : Thứ 1: regex của bạn thiếu ở chổ không chấp nhận dấu nháy đơn ' đứng một mình. Thứ 2: Bạn nên viết biểu thức regex ra trên giấy chính xác, sau đó viết lệnh như sau: regex(""""""............."""""".r) ^^ { StringLit(_) } // 6 dấu nháy kép ............. là biểu thức regex của bạn. Uh, nó thiếu trường hợp dấu nháy đơn đứng 1 mình, nhưng đấy là mình muốn lấy ví dụ để test xem sai ở đâu thôi. Dù sao cũng thank bạn"
Tuan Vu Quang,0,10/12/2011,[Gấp]Lỗi. Mọi người vào giúp,Cho mình hỏi bạn chút [^\\n] hay là [^(\n)] Mình thử cả 2 mà nó vẫn nhận \n
M.U.,1,10/12/2011,Re:Cách compile các file,"MFC.Maximus wrote: cho mình hỏi, mình đã làm đúng như trên, khi gõ ""scalac TestToken.scala"" thì nó báo lỗi not found : type CrazyLexical val lexical = new CrazyLexical ai biết cách sửa không :D đầu tiên bạn scalac *.scala sau đó gõ scala TestToken là xong."
MFC.Maximus,1,10/12/2011,Re:Cách compile các file,thank u :D
Tan Phat,1,11/5/2011,Re:Hỏi về Array Constant,"Mọi người test này thử input: function a():real; begin funSk(); x:=(tFunc() + tFunc2(1,2^3^ not4)) * tFunc3(a[4]); loop func1() and func2() and func3() do x:=5; break; return b(); end; Output: [func(a,[],float,[call(funSk,[]),assign(x,times(add(call(tFunc,[]),call(tFunc2,[1,pow(2,pow(3,not4))])),call(tFunc3,[ele(a,[4])]))),loop(band(band(call(func1,[]),call(func2,[])),call(func3,[])),assign(x,5)),break(null),return(call(b,[]))])]"
Why So Serious,1,11/5/2011,Re:Hỏi về Array Constant,"nguyen dung wrote: Mấy bạn thử cái này xem: function a():real; begin b:=a[4+5, [(3)] , i+j]; end; Cái này sai cú pháp mà. Toán tử [ ] phải có cú pháp là: <id>[<expr>,…,<expr>]"
Ngan Tuyet,1,11/5/2011,Re:Hỏi về Array Constant,"Just A Tee wrote: nguyen dung wrote: Mấy bạn thử cái này xem: function a():real; begin b:=a[4+5, [(3)] , i+j]; end; Cái này sai cú pháp mà. Toán tử [ ] phải có cú pháp là: [ ,…, ] Đâu có! Nó hiu cái [(3)] là expr -> const array -> mới báo lỗi ( do const array ko cho expr :)"
Why So Serious,1,11/5/2011,Re:Hỏi về Array Constant,Cho mình hỏi array constant có phải là expr không?
Đỗ Sỹ Hưng,1,11/5/2011,Re:Hỏi về Array Constant,"vd: const a = ['123']; Trường hợp này parse thành công hay sẽ thông báo lỗi. 1. Parse thành công:Cú pháp chấp nhận, còn kiểu của phần tử array constant có thể được kiểm tra ở bước kiểm tra kiểu. 2. Bị lỗi ở '123'"
Bruce Wayne,1,11/5/2011,Hỏi về Array Constant,Mình thấy đặc tả nói các phần tử của array constant đâu có kiểu string đâu bạn
Đỗ Sỹ Hưng,1,11/5/2011,Hỏi về Array Constant,"T.D.N  wrote: Mình thấy đặc tả nói các phần tử của array constant đâu có kiểu string đâu bạn Mình cũng làm theo ý bạn, nhưng hỏi lại cho chắc ^^"
_Trung_Than_Thong,1,11/6/2011,Re:Hỏi về Array Constant,"Tan Phat  wrote: cùng ý kiến với bạn. output:[func(a,[],float,[assign(b,ele(a,[add(4,5),3,add(i,j)]))])] loop do statement vàwhile do statement ko biết trường hợp này có đc nhiều expression ko nhỉ? hay chỉ có 1 expression sau loop thôi? chẳng hạn như ở c++ while(a <10 && b <10) có 2 expr. Cái này cứ hiểu theo đệ quy đi. Đề đã nói rất rõ ràng cấu trúc là while ..... thì cứ cái expression mà đi sâu vào...... Cái topic ass1 này ngày càng rối lên rồi, ai mà zô tìm gì giờ này chắc đuối"
I love you,1,10/7/2011,Các bạn cho mình hỏi về 1 testcase của chuỗi String,Trường hợp thú vị như sau: input nhập vào là : const f= ''''';  // 5 dấu nháy đơn liên tiếp Vậy output là j thế các bạn ?
Nhat Nguyen,1,10/7/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,c. ronaldo wrote: `const' identifier f `=' "''''" ErrorToken ' `;' EOF me too
Tin Bui,1,10/7/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,Nhat Nguyen wrote: c. ronaldo wrote: `const' identifier f `=' "''''" ErrorToken ' `;' EOF me too Tui cũng too :D
Quái,1,10/3/2011,một testcase phần real.,"Mình có test case này, không biết có được chấp nhận không? -.13e4"
Tong Ngoc Hoa,1,10/3/2011,một testcase phần real.,"Rec4rx  wrote: Mình có test case này, không biết có được chấp nhận không? -.13e4 đọc lại đặc tả đi bạn :))"
Quái,1,10/3/2011,Re:một testcase phần real.,Theo như đặc tả thì sẽ không có số âm??
walk alone,1,10/3/2011,Re:một testcase phần real.,"bạn nên theo dõi cái bài chủ đề khác, có đề cập đó."
Crazy Boy,1,10/3/2011,một testcase phần real.,"lỡ comment gòi thỳ nói cho thèn ku đó bik đy, mất công ẻm...:))"
Thanh Cao,1,11/6/2011,chỉnh sửa program trong code mẫu,"def program: Parser[ProgramPT] = rep( oneDec ) ^^ { case a => { if(test){println(""Vao chuong trinh"")}; new ProgramPT(if (a.isEmpty) List() else (a.head /: a.tail)(_ ++ _)) } } Đoạn này trong code mẫu có sửa gì không mọi người, sao mình thấy nó nhận vào oneDec"
librastar,1,9/28/2011,Hỏi về Array Constant,"Cho em hỏi đối với trường hợp sau: const x = [[1;2];[3];[4]]; sẽ parse thành công hay thất bại ạ? (Các phần tử là kiểu array nhưng dimension khác nhau, cái này em không thấy đặc tả trong spec)"
LongPham,1,10/7/2011,Các bạn cho mình hỏi về 1 testcase của chuỗi String,theo minh` ket qua la` `const' identifier f `=' "''''" ''' `;' EOF
Bruce Wayne,1,10/7/2011,Các bạn cho mình hỏi về 1 testcase của chuỗi String,huongcuibap  wrote: theo minh` ket qua la` `const' identifier f `=' "''''" ''' `;' EOF Thầy nói ' ko phải là token rồi mà bạn. Bạn xem lại phần Notice đi
LongPham,1,10/7/2011,Các bạn cho mình hỏi về 1 testcase của chuỗi String,`const' identifier f `=' "''''" `'' `;' EOF
Vu Dang,1,10/8/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,test nay kq cua cac bo the nao? var a=000: integer; var a=0.00: integer;
Huỳnh Trọng Khiêm,1,10/8/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,quang minh dinh wrote: test nay kq cua cac bo the nao? var a=000: integer; var a=0.00: integer; 0 0 0 và 0.0 0
Vu Dang,1,10/8/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,test nay thi sao cac bo : 0.000e5
Vu Dang,1,10/8/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,c. ronaldo wrote: quang minh dinh wrote: test nay thi sao cac bo : 0.000e5 0.0 0 0e5 EOF sao khong phai la 0.000e5 nhi ban CR7
_Trung_Than_Thong,1,11/4/2011,BooleanLiteral,"1. Giờ mới phát hiện cái booleanLiteral chưa hiện thực và hiện thực thì gặp lỗi.hix. Vì giá trị boolean chỉ có true hoặc false (cái này token mình đâu có kiểm tra trong regex). def boolLiteral: Parser[BooleanLiteralPT] = elem(""boolean"", _.isInstanceOf[lexical.BooleanLit]) ^^ { a => new BooleanLiteralPT(a.chars) } 2. cái tringLiteral của thầy viết trả về kiểu string => như vậy giả sử mình đặt 1 kiểu LiteralPT thì nó báo lỗi vì string k thuộc kiểu này: def literal: Parser[LiteralPT] = intLiteral | stringLiteral .... (cái này dùng để nhận dữ liệu cho array chẳng hạn) Không thật sự hiểu rõ lắm định nghĩa các kiểu dữ liệu này có từ khóa như real, int, string đâu có ảnh hưởng. Mong mọi người giúp đỡ"
Thanh Pham Minh,1,11/4/2011,BooleanLiteral,"_Trung_Than_Thong  wrote: 1. Giờ mới phát hiện cái booleanLiteral chưa hiện thực và hiện thực thì gặp lỗi.hix. Vì giá trị boolean chỉ có true hoặc false (cái này token mình đâu có kiểm tra trong regex). def boolLiteral: Parser[BooleanLiteralPT] = elem(""boolean"", _.isInstanceOf[lexical.BooleanLit]) ^^ { a => new BooleanLiteralPT(a.chars) } 2. cái tringLiteral của thầy viết trả về kiểu string => như vậy giả sử mình đặt 1 kiểu LiteralPT thì nó báo lỗi vì string k thuộc kiểu này: def literal: Parser[LiteralPT] = intLiteral | stringLiteral .... (cái này dùng để nhận dữ liệu cho array chẳng hạn) Không thật sự hiểu rõ lắm định nghĩa các kiểu dữ liệu này có từ khóa như real, int, string đâu có ảnh hưởng. Mong mọi người giúp đỡ 1. Bạn làm một cách đơn giản. booleanLiteral có 2 trường hợp là true và false . Vậy hãy parse 2 trường hợp đó thôi. Đừng để code mẫu của những literal kia làm ảnh hưởng. 2. Bạn sửa sao cho stringLiteral thuộc kiểu StringLiteralPT hoặc một cách nào đó khác!"
_Trung_Than_Thong,1,11/4/2011,BooleanLiteral,"Thanh Pham Minh wrote: 1. Bạn làm một cách đơn giản. booleanLiteral có 2 trường hợp là true và false . Vậy hãy parse 2 trường hợp đó thôi. Đừng để code mẫu của những literal kia làm ảnh hưởng. 2. Bạn sửa sao cho stringLiteral thuộc kiểu StringLiteralPT hoặc một cách nào đó khác! Thanks ban nhieu. Cai stringLiteral của thầy viết vậy là hợp lý rồi tại cái const còn xử lý mà, mình sửa khi đưa về literal = IntLiteral | StringLiteral ^^ { new ...() } không biết bản chất có đúng không nhưng tạm ok"
huongcuibap,0,11/6/2011,Re:BooleanLiteral,mình nghĩ là đúng vì mấy thầy định nghĩa StringLiteralPT là extend của LiteralPT
Quái,1,10/7/2011,Re:một testcase phần real.,"c. ronaldo wrote: `-' .13e4 EOF minh lam ra the, khong co so' am thanks bạn!"
Minh Triet Pham Tran,1,10/12/2011,Re:một testcase phần real.,Mình cũng ra: `-' .13e4 EOF
Long Nguyễn,1,11/6/2011,chỉnh sửa program trong code mẫu,"Đúng mà, đâu cần sửa gì đâu."
Thanh Cao,1,11/6/2011,chỉnh sửa program trong code mẫu,"Long Potter wrote: Đúng mà, đâu cần sửa gì đâu. không biết câu lệnh gán của code mẫu có sai gì không sao mình không chạy được"
Long Nguyễn,1,11/6/2011,chỉnh sửa program trong code mẫu,"Code mẫu đã chạy được input mẫu mà, vậy có khi bạn sửa đâu đó rồi."
librastar,1,9/29/2011,Re:Hỏi về Array Constant,"Vâng, cảm ơn thầy. Cho em hỏi thêm mấy câu sau ạ: 1) trường hợp var x : array[ 0 ] of integer cũng sẽ parse thành công phải ko ạ? 2) Trong spec có ghi 'call statement' tương tự như 'function call' nhưng em không thấy phần đặc tả của 'function call' trong spec?"
kid_ chem_ gio,1,9/30/2011,Hỏi về Array Constant,anh hùng cho em hỏi: const x = [[1;2];[3];[4]]; trong đề ghi là kiểu các phần tử trong mảng phải giống nhau.[1;2] =/=[3] như vậy sao parse thành công được
M.U.,1,9/30/2011,Hỏi về Array Constant,"kid_ chem_ gio wrote: anh hùng cho em hỏi: const x = [[1;2];[3];[4]]; trong đề ghi là kiểu các phần tử trong mảng phải giống nhau.[1;2] =/=[3] như vậy sao parse thành công được mình nghĩ là là trong array [[1;2];[3];[4]] gồm 3 kiểu array là [1,2] , và 2 array 1 phần tử là [3] và [4] nên sẽ parse dc"
Tuan Vu Quang,0,10/12/2011,Hỏi về Array Constant,`const' identifier x `=' `[' `[' 1 `;' 2 `]' `;' `[' 3 `]' `;' `[' 4 `]' `]' `;' EOF Ra như vậy có đúng ko
M.U.,1,10/12/2011,Re:Hỏi về Array Constant,ra nguyên cái [[1;2];[3];[4]] luôn bạn
Bruce Wayne,1,10/8/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,Có vẻ như nhiều bạn ko hiểu đặc tả nói gì
Huỳnh Trọng Khiêm,1,10/9/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,mình thấy biểu diễn dấu chấm không cần phải \\. mà chỉ cần . là đủ vì sao vậy ?
Nhat Nguyen,1,10/9/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,"Trong Khiem Huynh wrote: mình thấy biểu diễn dấu chấm không cần phải \\. mà chỉ cần . là đủ vì sao vậy ? Vì dấu . biểu diễn một kí tự bất kì, cho nên để . nó cũng có thể hiểu."
Minh Triet Pham Tran,1,10/12/2011,Các bạn cho mình hỏi về 1 testcase của chuỗi String,Bill Gates wrote: Trường hợp thú vị như sau: input nhập vào là : const f= ''''';  // 5 dấu nháy đơn liên tiếp Vậy output là j thế các bạn ? Mình ra: `const' identifier f `=' "''''" ErrorToken ' `;' EOF
Minh Triet Pham Tran,1,10/12/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,quang minh dinh wrote: test nay kq cua cac bo the nao? var a=000: integer; var a=0.00: integer; Mình ra kết quả sau: `var' identifier a `=' 0 0 0 `:' `integer' `;' `var' identifier a `=' 0.0 0 `:' `integer' `;' EOF
Minh Triet Pham Tran,1,10/12/2011,Re:Các bạn cho mình hỏi về 1 testcase của chuỗi String,quang minh dinh wrote: test nay thi sao cac bo : 0.000e5 Mình ra kết quả sau: 0.0 0 0e5 EOF
xuan vinh,1,11/4/2011,not,cho minh hỏi trường hợp này function abc() : real; begin a:=not - not 5; end; thì output là j?
facebook.com,1,11/4/2011,Hỏi về Array Constant,còn trường hợp [[1;2];3;true] có parse thành công không? và nếu em xử lý chuỗi đó luôn (báo lỗi) thì có bị sai không?
Sieutoc,1,11/4/2011,Hỏi về Array Constant,Van Persie wrote: còn trường hợp [[1;2];3;true] có parse thành công không? và nếu em xử lý chuỗi đó luôn (báo lỗi) thì có bị sai không? Em cung co cung cau hoi nhu ban nay.
facebook.com,1,11/5/2011,Hỏi về Array Constant,"Cho em hỏi thêm câu nữa: có chấp nhận assignment statement dưới đây không? A[4, C[5]] với A, C là hai array variable và A[4+5, 3, i+j]   => i,j hai biến kiểu integer"
Phúc Trí,1,11/5/2011,Hỏi về Array Constant,"Van Persie wrote: Cho em hỏi thêm câu nữa: có chấp nhận assignment statement dưới đây không? A[4, C[5]] với A, C là hai array variable và A[4+5, 3, i+j]   => i,j hai biến kiểu integer A,C error token rồi bạn"
facebook.com,1,11/5/2011,Hỏi về Array Constant,"sao lại bị error token dc vậy bạn? vd: A[4, C[5]] := 6;"
thanhnghi_py,1,11/5/2011,Re:Hỏi về Array Constant,"librastar  wrote: Cho em hỏi đối với trường hợp sau: const x = [[1;2];[3];[4]]; sẽ parse thành công hay thất bại ạ? (Các phần tử là kiểu array nhưng  dimension khác nhau, cái này em không thấy đặc tả trong spec) parse thành công, cái này qua bước kiểm tra tĩnh mới xử lý. ....................... Nếu trường hợp const x = [[1;2];[];[4]]; thì sao ạ"
Ngan Tuyet,1,11/5/2011,Hỏi về Array Constant,"Van Persie wrote: Cho em hỏi thêm câu nữa: có chấp nhận assignment statement dưới đây không? A[4, C[5]] với A, C là hai array variable và A[4+5, 3, i+j]   => i,j hai biến kiểu integer A,C là ident nên phải bắt đầu bằng chữ thường TH: a[4+5, 3, i+j] thao mình ko parser mà phải ghi là a[(4+5), 3, (i+j)] thì dc (vì cái thứ tự ưu tiên trong bảng) tương tự a[5,(c[5])]; thì parser Ngoài ra cho mình hỏi thêm là cái array access ko cần check cùng type như array literal đúng hok? Nghĩa là ghi a:=s[1;6.9] parser còn a:= [1;6.9] là sai?"
facebook.com,1,11/5/2011,Hỏi về Array Constant,"Theo mình nghĩ thì a[5, i+j] và a[2, c[3]] đúng! chứ có sao đâu. cái này thầy chưa nói rõ lắm..."
nguyen dung,1,11/5/2011,Re:Hỏi về Array Constant,"Mấy bạn thử cái này xem: function a():real; begin b:=a[4+5, [(3)], i+j]; end;"
Tan Phat,1,11/4/2011,not,"Vinh Vu Xuan wrote: cho minh hỏi trường hợp này function abc() : real; begin a:=not - not 5; end; thì output là j? mình ra ntn: [func(abc,[],float,[assign(a,bnot(sub(bnot(5))))])]"
BKIT 09,1,11/4/2011,Re:not,"Mình ra giống vậy: [func(abc,[],float,[assign(a,bnot(sub(bnot(5))))])]"
xuan vinh,1,11/5/2011,Re:not,"ok thank, đã fix lại"
librastar,1,11/5/2011,Re:not,"Scala ^^  wrote: [func(abc,[],float,[assign(a,bnot(bnot(bnot(5))))])] minh ra vậy, dấu - chỗ đó là 1 ngôi mà nếu input là : function abc() : real; begin a:=not 5 - not 5; end; thi ra [func(abc,[],float,[assign(a,sub(bnot(5),bnot(5)))])] dấu '-' 1 ngôi vẫn là sub!"
Nhat Nguyen,1,11/5/2011,Re:not,"Scala ^^  wrote: [func(abc,[],float,[assign(a,bnot(bnot(bnot(5))))])] minh ra vậy, dấu - chỗ đó là 1 ngôi mà nếu input là : function abc() : real; begin a:=not 5 - not 5; end; thi ra [func(abc,[],float,[assign(a,sub(bnot(5),bnot(5)))])] Đồng ý với bạn Scala^^"
Tran Quoc Anh,1,11/5/2011,Re:not,"Phần này chưa làm ngữ nghĩa nên có những case không thực tế là chuyện bình thường mà, với lại - là dấu âm không phải not đâu nên nó là sub ko phải bnot"
thinh van,1,11/5/2011,Re:not,"tui cũng ra vầy [func(abc,[],float,[assign(a,bnot(bnot(bnot(5))))])]"
xuan vinh,1,11/5/2011,Re:not,chú ý: trong file crazy đã đặc tả rõ phần này chỗ expressions - not        Unary minus/logicalnegation nên - ko phải là phép toán logic not đâu nha
Long Nguyễn,1,11/6/2011,not,"Lúc đầu mình cũng làm bnot cho - 1 ngôi, nhưng sau có bạn nhắc là hàm sub thầy có xử lí cho 1 ngôi => dùng hàm sub."
Tan Phat,1,11/5/2011,Re:Hỏi về Array Constant,"nguyen dung wrote: Mấy bạn thử cái này xem: function a():real; begin b:=a[4+5, [(3)], i+j]; end; Của mình ra ntn:line 3:12: unexpected token: ("
nguyen dung,1,11/5/2011,Re:Hỏi về Array Constant,Cái VD ấy ai parse thành công cho mình xin output he.
nguyen dung,1,11/5/2011,Re:Hỏi về Array Constant,@Tan Phat: sửađộ ưu tiên là sao bạn ?
Tan Phat,1,11/5/2011,Re:Hỏi về Array Constant,/* delete */
Nguyen Vo,1,11/5/2011,Re:Hỏi về Array Constant,"nguyen dung wrote: Của mình ra ntn:line 3:12: unexpected token: ( Mình sửa lại code xét độ ưu tiên [expr] thì ra ntn: [func(a,[],float,[assign(b,ele(a,[add(4,5),3,add(i,j)]))])] Ko biết cái nào đúng hay cả 2 đều sai? minh nghi cai tren dung hon. ~~~~~"
FirstName LastName,1,11/5/2011,Re:Hỏi về Array Constant,"[4+5, [(3)], i+j]; Array nhiều kiểuà =)) làm j có trường hợp này dc nhỉ, 4+5 là int, i +j thì ko biết,[(3)] là kiểuarray =>......"
Đỗ Sỹ Hưng,1,11/5/2011,Re:Hỏi về Array Constant,"Mình cũng nghĩ là trường hợp trên mới đúng. Theo đặc tả: The elements may be integer, real, boolean or array constant. Nghĩa là phần tử trong array constant [(3)] không chứa có phần tử (3) vì (3) là 1 biểu thức"
nguyen dung,1,11/5/2011,Re:Hỏi về Array Constant,"Ý của mình giống bạn Hưng, mình để chỗ [(3)] nó là const vậy (3) ?? , trong const nó không biết ""("" nên báo lỗi. Sửa lại cái VD, lần này tất cả đều là expr: function a():real; begin b:=a[4+5, (3), i+j]; end;"
Tan Phat,1,11/5/2011,Re:Hỏi về Array Constant,"nguyen dung wrote: Ý của mình giống bạn Hưng, mình để chỗ [(3)] nó là const vậy (3) ?? , trong const nó không biết ""("" nên báo lỗi. Sửa lại cái VD, lần này tất cả đều là expr: function a():real; begin b:=a[4+5, (3), i+j]; end; cùng ý kiến với bạn. output:[func(a,[],float,[assign(b,ele(a,[add(4,5),3,add(i,j)]))])] loop <expression> do statement vàwhile <expression> do statement ko biết trường hợp này có đc nhiều expression ko nhỉ? hay chỉ có 1 expression sau loop thôi? chẳng hạn như ở c++ while(a <10 && b <10) có 2 expr."
nguyen dung,1,11/5/2011,Re:Hỏi về Array Constant,Nếu chỗ && thay bằng and thì parse bình thường
Forever Alone,1,11/5/2011,Hỏi về phần leftHandSide trong đặc tả,Trong đặc tả phần assignment có đoạn : var a: array[3] of integer; a := [2;3;4]; a[1] := 4; Theo em nghĩ chỗ này phải là const a := a[2;3;4 ] hoặc là a := a[2;3;4] chứ ạ. Anh Hung giải đáp dùm em với.
Nha Nguyen,1,11/5/2011,Re:Hỏi về phần leftHandSide trong đặc tả,Dung ma ban trong dac ta co noi ben phai asignment la expr thi expr co the la constant ma !
Forever Alone,1,11/5/2011,Re:Hỏi về phần leftHandSide trong đặc tả,À mình đã hiểu. Đọc đề ko kĩ :d. Thanks bạn nha. Như vậy thì a := [2;3;4+1]; thì ko đc đúng ko?
Long Nguyễn,1,11/6/2011,Re:Hỏi về phần leftHandSide trong đặc tả,Em yêu Scala ♥♥♥ wrote: À mình đã hiểu. Đọc đề ko kĩ :d. Thanks bạn nha. Như vậy thì a := [2;3;4+1]; thì ko đc đúng ko? Parse không được :D
Thanh Pham Minh,1,11/3/2011,Re: giúp đỡ phần khai báo array,@Scala ^^: bạn thử xóa dòng màu đỏ đi xem sao! Edit: xóa thêm dấu { và } nữa :D Edit: xóa thêm dấu ^^ luôn :p
Thanh Pham Minh,1,11/3/2011,Re: giúp đỡ phần khai báo array,Mình không có code phần def arrayLiteral của bạn nên cũng không chắc. Có thể input bạn ghi thiếu "const b =...
n0b0dy,1,11/3/2011, giúp đỡ phần khai báo array,"Mình cũng đang bí ở phần này , các bạn giúp mình với :)"
Thanh Pham Minh,1,11/3/2011,Re: giúp đỡ phần khai báo array,Chắc do phần constDec bạn chưa bổ sung thêm trường hợp arrayLiteral. Hoặc phần oneDec bạn chưa bổ sung constDec. Hoặc bạn chưa hiện thực BooleanLiteral thành công. ... Test: const b = [1];
n0b0dy,1,11/3/2011, giúp đỡ phần khai báo array,Bạn Scala có nick YH ko cho mình add nick trao đổi với :)
Thanh Pham Minh,1,11/3/2011,Re: giúp đỡ phần khai báo array,Không có chi ^^
Tran Quoc Anh,1,11/4/2011,Re: giúp đỡ phần khai báo array,Bạn thử thêm một dấu + xem (_++_)
Tran Quoc Anh,1,11/4/2011,Re: giúp đỡ phần khai báo array,"def lstliteral: Parser[List[LiteralPT]] = repsep(literal, "";"") ^^ { case a => if (!a.isEmpty) (a.head /: a.tail)(_+_) else List() } ---->>> def lstliteral: Parser[List[LiteralPT]] = repsep(literal, "";"") ^^ { case a => if (!a.isEmpty) (a.head /: a.tail)(_++_) else List() }"
n0b0dy,1,11/4/2011, giúp đỡ phần khai báo array,Các bạn gợi ý cho mình về phần ArrayType với :) . Mình làm thế này mà sao nó ko nhận nhỉ :) ("array" ~> "[" ~> dimen  eleType) :) . Phần dimen của mình là intLiteral :)
Thanh Pham Minh,1,11/4/2011,Re: giúp đỡ phần khai báo array,"chỗ varDec, minh có thể khai báo là var a,b,c: real; nhưng trong code thì def varDec: Parser[List[VarDecPT]] = (""var"" ~> ident <~ "":"") ~ (varType <~ "";"") tức là chỉ cho 1 variable mình sửa lai ident thành identlst như thế này def varDec: Parser[List[VarDecPT]] = (""var"" ~> identlst <~ "":"") ~ (varType <~ "";"") ^^ { case a ~ b => { List(new VarDecPT(new IdPT(a), b)) } } def identlst: Parser[IdPT] = repsep(ident,"","") thì bị lỗi dòng màu đỏ."
Vu Dang,1,11/2/2011,Hỏi về 12 hàm built-in ở cuối đặc tả,Anh Hưng ơi cho em hỏi 12 cái hàm built-in ở cuối đặc tả là hàm hỗ trợ cho mình hay mình phải tự viết những hàm đó vậy ạ? Em cám ơn.
xuan vinh,1,11/4/2011,Re:Hỏi về 12 hàm built-in ở cuối đặc tả,"uhm, cái này mình cũng đang thắc mắc, bạn nào biết vào chỉ coi"
Long Nguyễn,1,11/6/2011,Hỏi về 12 hàm built-in ở cuối đặc tả,Giờ chưa cần đụng tới mà.
Thanh Pham Minh,1,11/4/2011,Re: giúp đỡ phần khai báo array,"def varDec: Parser[List[VarDecPT]] = (""var"" ~> identlst <~ "":"") ~ (varType <~ "";"") ^^ { case a ~ b => { List(new VarDecPT(new IdPT(a), b)) } } def identlst: Parser[List[IdPT]] = repsep(ident,"","") //loi: type mismatch; found : CrazyParser.this.Parser[String] required: CrazyParser.this.Parser[IdPT] mình sửa lại thế thì nó báo lỗi 2 dòng kia lun hix"
Thanh Pham Minh,1,11/4/2011,Re: giúp đỡ phần khai báo array,"def identlst: Parser[List[IdPT]] = repsep(ident,"","")"
n0b0dy,1,11/4/2011, giúp đỡ phần khai báo array,"minh sửa lại def identlst: Parser[List[String]] = repsep(ident,"","") thì oke rồi. còn cái hàm varDec cái chỗ (""var"" ~> identlst <~ "":"") thì identlst phải có kiểu String, mình k biết làm sao đưa nó nhận list ident nữa"
Vo Quoc Hieu,1,11/4/2011,Re: giúp đỡ phần khai báo array,identlst có kiểu List[String] nên các phần tử của nó sẽ có kiểu String.
nguyen dung,1,11/4/2011,Re: giúp đỡ phần khai báo array,"def varDec: Parser[List[VarDecPT]] = (""var"" ~> identlst <~ "":"") ~ (varType <~ "";"") ^^ { case a ~ b => { List(new VarDecPT(new IdPT(a), b)) } theo mình hiểu là phải lấy từng phần tử của identlst để new VarDecPT, mà code như sau thì bị lỗi case a ~ b => a.map( x => List(new VarDecPT(new IdPT(x), b)) ) :((( vẫn bị lỗi ở dòng map"
huongcuibap,0,11/6/2011,Re: giúp đỡ phần khai báo array,Ko bạn nào giúp mình đc ở cái arrayType sao :(
huongcuibap,0,11/6/2011,Re: giúp đỡ phần khai báo array,"Scala ^^  wrote: def varDec: Parser[List[VarDecPT]] = (""var"" ~> identlst <~ "":"") ~ (varType <~ "";"") ^^ { case a ~ b => { List(new VarDecPT(new IdPT(a), b)) } theo mình hiểu là phải lấy từng phần tử của identlst để new VarDecPT, mà code như sau thì bị lỗi case a ~ b => a.map( x => List(new VarDecPT(new IdPT(x), b)) ) :((( vẫn bị lỗi ở dòng map Dòng map bỏ List trước new VarDecPT đi vì trong hàm map nó tự động tạo 1 List cho các phần tử sau => nên bạn thêm List vào đó bị dư nó báo lỗi List[List[.....]]"
xuan vinh,1,10/27/2011,wholeNumber,cho mình hỏi: khi mìnhimport scala.util.parsing.combinator._ thì thư viện này sẽ có định nghĩa wholeNumber rồi đúng ko? vì mình định nghĩa cái constDec dùng cái wholeNumber mà ko đc? ai biết chỉ t với
Long Nguyễn,1,10/28/2011,Re:wholeNumber,Hình như không có wholeNumber đâu em. Dùng intLiteral đi.
cong thanh,1,10/26/2011,hỏi ý nghĩa về các hàm cho sẵn,cho em hỏi khi định nghĩa biểu thức ý nghĩa các hàm này là gì trong file PT.scala AddExprPT // cộng SubExprPT // trừ TimesExprPT RdivExprPT IdivExprPT ImodExprPT NeExprPT EqlExprPT GeExprPT GreaterExprPT LeExprPT LessExprPT BorExprPT BandExprPT BnotExprPT ExponentExprPT FuncCallExprPT ConsPT LefHandSidePT VarExprPT EleExprPT
abc,1,10/13/2011,ý nghĩa tên cái Class trong File PT.scala,"em chào thầy và các ban, lúc làm assigment em biết class AddExprPT thì dùng cho phép cộng ""+"" nhưng còn : class TimesExprPT(val left: ExprPT, val right: ExprPT) extends ExprPT em ko biết nó dùng cho phép toán nào, em nghĩ nó dùng cho phép nhân ""*"" (vì em đọc hết file mà ko thấy class cho phép nhân ở đâu) class NeExprPT thì dùng cho phép ""<>"" class GeExprPT thì dùng cho phép "">="" class LeExprPT thì dùng cho phép ""<="" không biết em hiểu như vậy có đúng ko."
xuan vinh,1,10/26/2011,Re:hỏi ý nghĩa về các hàm cho sẵn,mình cũng đang thắc mắc mấy hàm nè
Long Nguyễn,1,10/28/2011,Re:hỏi ý nghĩa về các hàm cho sẵn,AddExprPT // cộng SubExprPT // trừ TimesExprPT // nhân RdivExprPT // chia thực "/" IdivExprPT // chia nguyên "div" ImodExprPT // mod NeExprPT // <> EqlExprPT // = GeExprPT // >= GreaterExprPT // > LeExprPT // <= LessExprPT // < BorExprPT // or BandExprPT // and BnotExprPT // not hoặc - ExponentExprPT // ^ FuncCallExprPT // gọi hàm ConsPT // trị hằng số LefHandSidePT // left hand side VarExprPT //biến EleExprPT //truy cập mảng
Nhan Nguyen Van,1,11/2/2011,Token?,'' có phải là một token không vậy mọi người ?
Đỗ Sỹ Hưng,1,10/27/2011,Thắc mắc về các toán tử,"Có 2 chỗ trong ngôn ngữ Crazy mà mình không rõ, mong thầy với mấy bạn giải thích giùm: :( 1. Nếubiểu thức là: 1 < 2 >= 3 thì có được chấp nhận bởi ngôn ngữ Crazy không? 2. toán tử trừ ( - ) được dùng trong kiểu nguyên với kiểu thực thì khi nào toán tử - là unary -, khi nào là binary - ??"
Long Nguyễn,1,10/28/2011,Re:Thắc mắc về các toán tử,"Theo mình thì: 1. Trong Parser này thì chấp nhận bình thường. 2. Khi nào có đủ 2 toán hạng thì - là 2 ngôi, còn không thì là 1 ngôi. VD: 1 - 2 //2 ngôi 1 - - 2 //- trước là 2 ngôi, - sau là 1 ngôi"
MFC.Maximus,1,11/1/2011,type checking của Scala,"def oneDec: Parser[List[SubtinePT]] = varDec | procDec ^^ { case a => List(a) } def procDec: Parser[ProcDecPT] code mẫu của thầy không bi lỗi def oneDec: Parser[List[SubtinePT]] = varDec | procDec | funDec ^^ { case a => List(a) } def procDec: Parser[ProcDecPT] ... def funDec:Parser[FuncDecPT] ... thì lại bị lỗi type mismatch; found : CrazyParser.this.Parser[ScalaObject] required: CrazyParser.this.Parser[List[SubtinePT]] mình đã kiểm tra lại class FuncDecPT(val name: IdPT, val param: List[ParamDecPT], val returnType: TypePT, val blockStmt: BlockStmtPT) extends SubtinePT class ProcDecPT(val name: IdPT, param: List[ParamDecPT], val blockStmt: BlockStmtPT) extends SubtinePT ai có thể giải thích hộ mình không :), bị lỗi dòng oneDec thôi nhé :D"
cong thanh,1,10/31/2011,trường hợp này có đc nhận hay k,theo độ ưu tiên toán tử thì không biết liệu TH này có đc nhận hay k procedure main(); begin x = a[1+2]; end; a[1+2] hay phải là a[(1+2)] mới đúng
Long Nguyễn,1,11/1/2011,trường hợp này có đc nhận hay k,"Không nhận đâu! . . . . . Vì x := mới nhận :)) Theo đặc tả<id>[<expr>,…,<expr>], mà 1+2 là expr nên nhận thoải mái!"
Long Nguyễn,1,11/2/2011,Token?,Có đó cưng. Xem dòng cuối cùng trong đặc tả ass1: line 5:4: unexpected token: "
FirstName LastName,1,10/29/2011,token EOF hay <eof>,trong mô tả fileassignment1.pdf có 3 ví dụ trả vềđối với parser có 1 ví dụ trả về là <eof> Xin thầy xác nhận lại là cóđúng câuđó trả về "<eof>" hay koạ? Sao mình làm nó ra "EOF" .
Long Nguyễn,1,11/1/2011,token EOF hay <eof>,Thì bạn làm sao cho nó trả về <eof> là được.
walk alone,1,11/2/2011,Re:token EOF hay <eof>,"mình thấy làm thì mặc định ra eof mà, ra EOF thì chỉnh sửa mới ra thôi @@"
nguyen dung,1,11/2/2011,Re:token EOF hay <eof>,Mặc định của mình là EOF. muốn xuất ra <eof> thì bạn chỉnh trong hàm show là được mà
Phúc Trí,1,11/2/2011,Các toán tử and or not mod div?,"Thầy cho em hỏi các toán tử này (and or not mod div) có được phép ghi liền với toán hạng hay ko? VD: 6mod4 hay là 6 mod 4. Vì trường họp 6mod4 nó cứ hiểu mod4 là 1 identifier chứ ko tách ra dược là thành 6, mod ,4 Và có trường hợp not liên tiếp ko? VD: not not x"
vanhoa,1,11/1/2011,type checking của Scala,Cái toán tử | có độ ưu tiên thấp hơn hàm pack ^^
MFC.Maximus,1,11/1/2011,Re:type checking của Scala,sr mình mới edit lại bài thiếu dấu ^^ bạn có thể giải thích lại nếu thấy thay đổi :)
librastar,1,11/1/2011,type checking của Scala,Code: def oneDec: Parser[List[SubtinePT]] = varDec | procDec | funDec^^{ case a => List(a) } It should be Code: def oneDec: Parser[List[SubtinePT]] = varDec | (procDec |funDec)^^{ case a => List(a) }
walk alone,1,11/2/2011,Re:Các toán tử and or not mod div?,"trường hợp 6mod4 thì mình nghĩ nó đã loại khi kiểm tra token rồi, còn not not 5 thì có."
walk alone,1,11/2/2011,Có bạn nào test với cygwin ko??,"Bạn nào test cho mình hỏi, có bạn nào output ra có kí tự kết thúc là CRLF không?? Cảm ơn nhiều."
Đỗ Sỹ Hưng,1,11/3/2011,function call???,"Thầy có thể cho em biết định dạng lời gọi hàm (function call) là sao không? + độ ưu tiên, em thấy có khai báo định nghĩa hàm mà không thấy có chỗ nào nói về lời gọi hàm hết."
meo_lac,1,11/4/2011,Re:function call???,"Đề có nà bạn 'A function call starts with an identifier, i.e. the function name, followed by an open parenthesis, an optional comma-separated list of expressions, and ends with a close parenthesis.'"
Tong Ngoc Hoa,1,11/4/2011,Re:function call???,funcall được xem là 1 operand luôn đó bạn trong đề có đặc tả rõ lắm mà :D
Đỗ Sỹ Hưng,1,11/4/2011,Re:function call???,mình thấy rùi ^^. Thanks mấy bạn nha
Nguyen Bui Ly Tien,1,10/24/2011,Re:Hỏi về kết quả Asignment 1,"Chào thầy em là Bùi Lý Tiến Nguyên MSSV 50801394 em đã test chạy đúng các test case trong bài nhưng kết quả 0/10 mong thầy xem xét lại bài của em, cảm ơn thầy."
FirstName LastName,1,10/24/2011,Re:Hỏi về kết quả Asignment 1,"Thưa thầy cho em hỏi kết quả state 1 cóảnh hưởng tới state 2đúng koạ. Như vậy nếu state 1 kođủ 10/10, qua state 2 có thể chỉnh/sửa lại phần regexđểđiểm cao hơn koạ. Em cámơn Sr.đã có trong phần notice Câu hỏi: Trong assignment 1 môn PPL phần stage 1 em có làm sai 1 vài trường hợp, như vậy trong stage 2 phần hiện thực parser của em có được sửa lại những nội dung mà em đã submit lên trong phần stage 1 ko ạ? Trả lời: Được phép sửa"
vo danh,1,10/25/2011,Re:Hỏi về kết quả Asignment 1,ket quả thấp đến bất ngờ có 5/10. chắc phải cố gắng làm stage 2 thôi
Tuan Vu Quang,0,10/25/2011,Hỏi về kết quả Asignment 1,"Thôi xong rồi, vừa mới kiểm tra lại ass mới thấy cái bài nộp là bài cũ, vẫn để string trước int với float. Thảo nào sai hết rồi. Chán thế, test đi test lại, mất bao công lúc nộp bài lại nộp file linh tinh"
Quan Nguyen,1,10/25/2011,Re:Hỏi về kết quả Asignment 1,"Anh Hùng ơi, em vừa xem lại, hóa ra bài em nộp là bài mẫu của anh, không phải bài làm của em :( Hic, sơ suất quá, em nộp nhầm bài rồi. Giờ có thể nào xin chấm lại được không anh?"
Vu Dang,1,11/4/2011,HELP!!!! chuột wireless bị thất lạc.,xin lỗi các bạn vì đã spam topic này! hôm nay (thứ 6) trong tiết bài tập CNPM mình có để quên 1 con chuột wireless mau xanh trên bàn tại phòng máy A5. bạn nào đang giữ nó thì cho mình xin lại. SDT: 01695305025 mình xin cảm ơn!
Phạm Nguyên Trình,1,10/31/2011,Re:Hỏi về kết quả Asignment 1,"Hi a Hùng, anh có thể cho em biết bài của em (50802353) bị sai testcase nào được ko ạ? Cần sửa gấp để zô parser hok bị lại nữa mà em hok bít phải sửa chỗ nào cả. Thank anh nhiều ^^"
khong_thoigian,0,11/2/2011,Hỏi về kết quả Asignment 1,"Anh Hung ơi! Em nộp nhầm tên file là ""Crazy2011.scala"" nên được 0 điểm, anh có thể xem lại giúp em với... MSSV:50902028 Vũ Đặng Hoàng Phụng Em cám ơn anh nhiều! Phụng"
Nha Nguyen,1,11/4/2011,Truy xuất array nhiều chiều !,"Các bạn cho mình cho mình hỏi : Vd : mang hai chieu a[[1,2] , [1,1]] Truy xuất array nhiều chiều thi a[1,1] hay la a[1][1] ....?"
Ngan Tuyet,1,11/5/2011,Re:Truy xuất array nhiều chiều !,"hình như là a[1,1] .... (coi array access trong bảng expression)"
Phúc Trí,1,11/5/2011,Truy xuất array nhiều chiều !,"Nguyen Nha wrote: Các bạn cho mình cho mình hỏi : Vd : mang hai chieu a[[1,2] , [1,1]] Truy xuất array nhiều chiều thi a[1,1] hay la a[1][1] ....? a[1,1]. trong này a Hùng có trả lời rồi nè bạn. chịu khó đọc kiếm trước khi hỏi chứ https://elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3643.page"
Nha Nguyen,1,11/5/2011,Re:Truy xuất array nhiều chiều !,thanks các ban!
thanhnghi_py,1,11/4/2011,varDec ???,"Cho mình hỏi là nếu trong input có khai báo: var a,b:integer; thì kết quả parser là [var(a,b,int)] hay là [var(a,int),var(b,int)]"
Nhat Nguyen,1,11/4/2011,varDec ???,"[var(a,int),var(b,int)]"
Jakul KID,1,11/4/2011,varDec ???,"theo mình thì là [var([a,b],int] không biết thầy trả lời chưa, cũng đang thắc mắc"
FirstName LastName,1,11/4/2011,Re:varDec ???,"Câu này trả lời rồi, a, b tách biệt , ko có chung như bạnở trên"
thanhnghi_py,1,11/5/2011,Re:varDec ???,"Nói vậy là [var(a,int),var(b,int)] đúng phải không. Ủa mà thầy trả lời cái này chỗ nào vậy."
M.U.,1,10/11/2011,Const Array này nhận được ko vậy mọi người,[[1;2];[true;false]] parse dc ko vậy mọi người Cám ơn mọi người ^^
Phạm Nguyên Trình,1,11/5/2011,Đề nghị thầy upload testcase mẫu và kết quả mẫu cho Stage 2,"Chào thầy, Hiện tại, các testcase mẫu hầu như chỉ có những test dành cho Lexer (toàn mấy test var declare không à), chúng em không rõ mấy testcase hơi đặc biệt (có function, procedure, array,...) sẽ xuất kết quả ra như thế nào? Tự vọc code, có thể chạy được, nhưng chưa chắc ra được kết quả giống với ý của thầy => sai test tội SV chúng em. Trân trọng!"
FirstName LastName,1,11/5/2011,Re:Đề nghị thầy upload testcase mẫu và kết quả mẫu cho Stage 2,Trong sakai có nhiều rồi bạn
Nguyen Bui Ly Tien,1,11/6/2011,Có bạn nào mắc lỗi như thế này không ? ,"MÌnh chạy thử 1 test đúng thì bị báo lỗi này, có ai bị rồi giúp mình với. Exception in thread ""main"" scala.MatchError: [1.14] parsed: [const(g,45)] (of class scala.util.parsing.combinator.Parsers$Success) at CrazyParser.show(Crazy2011.scala:84) at TestParser$.main(TestParser.scala:16) at TestParser.main(TestParser.scala)"
vua doi bom,1,10/11/2011,Re:Const Array này nhận được ko vậy mọi người,array kieu gi cung duoc ma
Quái,1,10/11/2011,Const Array này nhận được ko vậy mọi người,Minh Quân Nguyễn wrote: [[1;2];[true;false]] parse dc ko vậy mọi người Cám ơn mọi người ^^ parse thành công...
Why So Serious,1,10/25/2011,Const Array này nhận được ko vậy mọi người,Vậy [1;false;3.5] với [[2; 4];3;true] parse thành công không mọi người?
Nguyen Thanh Tam,1,11/6/2011,Bắt 1 lỗi hay bắt tất cả.,Mọi người cho hỏi là bài này mình bắt tất cả các lỗi hay chỉ bắt 1 lỗi thôi. nếu bắt hết thì hướng dẫn mình phần đó nằm ở đâu đc ko :)
Vu Dang,1,11/6/2011,Re:Bắt 1 lỗi hay bắt tất cả.,mình nghĩ stage2 giống như thông dịch vậy. gặp lỗi đầu tiên nó sẽ báo rồi dừng lại tại lỗi đó . nên nó chỉ bắt 1 lỗi
Nhan Nguyen Van,1,11/1/2011,Re:Const Array này nhận được ko vậy mọi người,"nguyen duc thien wrote: array kieu gi cung duoc ma Note that the elements of an array must be in the same type. For example [1;3;2] [3.2;.2E-2] [[1;2];[3;4]] [] [[1;2];3;4] [1;2;true] Các phần tử trong mảng phải cùng kiểu chứ... Vậy [[1;2]; [1]],  [[true;false]; [1;2]] được không vây?"
Long Nguyễn,1,11/1/2011,Const Array này nhận được ko vậy mọi người,"kiểm tra kiểu là kiểm tra ngữ nghĩa rồi, thuộc về ass2."
Nhan Nguyen Van,1,11/2/2011,Const Array này nhận được ko vậy mọi người,"Just A Tee wrote: Vậy [1;false;3.5] với [[2; 4];3;true] parse thành công không mọi người? mình nghỉ [1;false;3.5] không được, cái này mình có thể kiểm tra token được mà: a[ ListInteger token | Listboolean token ... ] => cac phan tu tron array phai cung kieu thi co the kiem tra duoc. chi co truong hop a [ [2;3] ; [ true ;false]] la khong kiem tra duoc thoi... vi 2 phan tu trong mang a deu la mang ca => chap nhan, con kiem tra kieu tiep nua thi ko duoc. (ass2)"
Long Nguyễn,1,11/3/2011,Const Array này nhận được ko vậy mọi người,"nhan nguyen van wrote: Just A Tee wrote: Vậy [1;false;3.5] với [[2; 4];3;true] parse thành công không mọi người? mình nghỉ [1;false;3.5] không được, cái này mình có thể kiểm tra token được mà: a[ ListInteger token | Listboolean token ... ] => cac phan tu tron array phai cung kieu thi co the kiem tra duoc. chi co truong hop a [ [2;3] ; [ true ;false]] la khong kiem tra duoc thoi... vi 2 phan tu trong mang a deu la mang ca => chap nhan, con kiem tra kieu tiep nua thi ko duoc. (ass2) Em có thể check kiểu đó, tuy nhiên parse vẫn thành công đơn giản vì nó đúng cú pháp."
Bruce Wayne,1,11/4/2011,Const Array này nhận được ko vậy mọi người,"Just A Tee wrote: Vậy [1;false;3.5] với [[2; 4];3;true] parse thành công không mọi người? Vậy cái này parse thành công ko mọi người, ai khẳng đinh giúp mình với!"
huongcuibap,0,11/6/2011,Khai báo const,"def constDec: Parser[ConstDecPT] = ( ""const""~> ident <~ ""="" ) ~ (intLiteral <~"";"" ) ^^ { case a ~ b => new ConstDecPT(new IdPT(a), b) } mình khai báo const cho int như trên, nhưng sao nó báo lỗi chỗ: def oneDec: Parser[List[SubtinePT]] = varDec | constDec | procDec ^^ { case a => List(a) } các bạn giúp mình với."
Why So Serious,1,11/6/2011,Khai báo const,def oneDec: Parser[List[SubtinePT]] = varDec | constDec ^^ { case a => List(a) } | procDec ^^ { case a => List(a) } p/s: bạn sửa thêm chỗ constDec (mới chỉ có mỗi integer)
huongcuibap,0,11/6/2011,Re:Khai báo const,"^^, tks bạn. lúc đầu mĩnh nghĩ là cả cụm ( varDec | constDec | procDec) sẽ dùng chung với { case a => List(a) }"
Nhất Tiếu nại Hà,1,11/6/2011,Re:Khai báo const,"coffee cafe wrote: ^^, tks bạn. lúc đầu mĩnh nghĩ là cả cụm (varDec | constDec | procDec) sẽ dùng chung với { case a => List(a) } dungf chung vẫn đc đó bạn...;)) chủ yếu cái hiện thực dưới của mình thôi...:D:D"
M.U.,1,11/6/2011,Mấy bạn cho mình hỏi lỗi này,"Minh làm như vậy: def oneDec: Parser[List[SubtinePT]] = varDec | funcDec | constDec | procDec ^^ { case a => List(a) } nhưng lại báo lỗi, Multiple markers at this line - type mismatch; found : CrazyParser.this.Parser[ScalaObject] required: CrazyParser.this.Parser[List[SubtinePT]] - type mismatch; found : CrazyParser.this.Parser[ScalaObject] required: CrazyParser.this.Parser[List[SubtinePT]] nên mình ko thể nào tạo dẫn xuất ra dc khai báo hàm và khai báo constant để kiểm tra hàm mình viết. Ko biết mình nên làm thế nào đây, mong mấy bạn có thể giúp đỡ mình. Mình cám ơn. ///////////////// Một vấn đề nữa: code hàm mũ của mình cần kết hợp phải, nhưng mình code như vậy def expr_pow: Parser[ExprPT] = expr ~ rep((""^"") ~ expr) ^^ { case a ~ lst => (a :\ lst) { case (x, ""^"" ~ y) => new ExponentExprPT(x, y) } } báo lỗivalue :\ is not a member of ExprPT mình ko thể hiện dc tính kết hợp phải, mong mấy bạn chỉ giúp. //////////////// còn về - hoặc not, mình viết như vậy def expr_not: Parser[ExprPT] = (rep(""-""|""not"") ~ expr1) ^^ { case (""-"" ~ a) => new BnotExprPT(a) case (""not"" ~ a) => new BnotExprPT(a) } cái này nói thiệt là mình viết đại :( ai biết chỉ giúp mình với, :( Mình cám ơn rất nhìu ^^"
Minh Nguyen,1,11/6/2011,Mấy bạn cho mình hỏi lỗi này,trong sakai có bạn hỏi cái này rồi mà bạn def oneDec: Parser[List[SubtinePT]] = varDec |( funcDec | constDec | procDec ) ^^ { case a => List(a) } Sửa lại giống trên
Quái,1,11/6/2011,Mấy bạn cho mình hỏi lỗi này,M.U.  wrote: Bạn nên làm như vậy: def oneDec: Parser[List[SubtinePT]] = varDec | constDec | (procDec|funcDec)^^ { case a => List(a) }
M.U.,1,11/6/2011,Mấy bạn cho mình hỏi lỗi này,"Minh Nguyen wrote: trong sakai có bạn hỏi cái này rồi mà bạn def oneDec: Parser[List[SubtinePT]] = varDec |( funcDec | constDec | procDec ) ^^ { case a => List(a) } Sửa lại giống trên cám ơn bạn rất nhìu, mình sữa lại được rồi. Còn vấn đề 2 và 3, mong mấy bạn chỉ giúp ^^"
huongcuibap,0,11/6/2011,Re:Mấy bạn cho mình hỏi lỗi này,vấn đề 2 bạn sửa lại dấu (a :\ lst) =>>>>> (a /: lst)
M.U.,1,11/6/2011,Re:Mấy bạn cho mình hỏi lỗi này,"coffee cafe wrote: vấn đề 2 bạn sửa lại dấu(a :\ lst) =>>>>> (a /: lst) ủa, mình nghĩ /: là tính kết hợp trái mà, mà hàm ^ thì kêu mình kết hợp phải mà bạn. Có gì sai monh mọi người chỉ thêm :("
Sieutoc,1,11/6/2011,Re:Mấy bạn cho mình hỏi lỗi này,"Vấn đề 2 của bạn có một số mâu thuẫn: 1. Hàm mũ là kết hợp phải, mà bạn để kết hợp trái do phép lặp ở bên phải => đem lặp qua bên trái expr 2. case a ~ lst => (a :\ lst) => case lst ~ a => (lst :\ a) 3. case (x, ""^"" ~ y) => new ExponentExprPT(x, y) => case (x ~ ""^"", y) => new ExponentExprPT(x, y) Bạn thử xem sao."
huongcuibap,0,11/6/2011,Re:Mấy bạn cho mình hỏi lỗi này,"@M.U, đúng là mình lầm lẫn chỗ đó. mình nghĩ đây là 1 cách : rep( expr ~ (""^"")) ~ expr"
M.U.,1,11/6/2011,Re:Mấy bạn cho mình hỏi lỗi này,"Mai Hoa Đạo  wrote: Vấn đề 2 của bạn có một số mâu thuẫn: 1. Hàm mũ là kết hợp phải, mà bạn để kết hợp trái do phép lặp ở bên phải => đem lặp qua bên trái expr 2. case a ~ lst => (a :\ lst) => case lst ~ a => (lst :\ a) 3. case (x, ""^"" ~ y) => new ExponentExprPT(x, y) => case (x ~ ""^"", y) => new ExponentExprPT(x, y) Bạn thử xem sao. cám ơn bạn và coffee cafe nhìu nha, mình đã sửa dc vấn đề 2 ùi, còn vấn đề thứ 3, nữa, cố lên cố lên <3 <3 <3"
Sieutoc,1,11/6/2011,Re:Mấy bạn cho mình hỏi lỗi này,case a ~ lst => (a :\ lst) => case lst ~ a => (lst :\ a) 3.
Forever Alone,1,11/5/2011,Hỏi về break và continue,"Mấy bạn cho mình hỏi là trong phần statement lệnh break đặc tả bảo là phải nằm trong loop hoặc while. Phần đó mình sẽ parse ở bước Parser này luôn hay qua bước sau vậy? Nếu ở bước này thì bạn nào cho kquả giùm mình 2 vd này với : 1. procedure child2(a:array[1] of integer); begin //a[0] := 2; loop(5) do break; var a,b: integer; end; 2. procedure child2(a:array[1] of integer); begin //a[0] := 2; loop(5) do begin a:=5; break; end var a,b: integer; end; Thanks all ^^"
Nguyễn Đức Huy,1,11/5/2011,Hỏi về Array Type và Array Element,"Mình đọc trong forum nhưng chưa thấy ai gặp tình cảnh giống mình cả. Mình khai báo hàm arrayType để parse kiểu array nhưng mãi ko chạy đúng, toàn ra lỗi. Code mình đây: def primitiveType = integerType | realType | boolType | stringType def arrayType: Parser[ArrayTypePT] = (""array"" ~> ""["" ~> rep1sep(intLiteral, "","") <~ ""]"") ~ (""of"" ~> primitiveType) ^^ { case lst ~ c => new ArrayTypePT(lst, c) }"
Phúc Trí,1,11/5/2011,Re:Hỏi về break và continue,ass1 chua can kiem tra cai nay dau ban
Forever Alone,1,11/5/2011,Re:Hỏi về break và continue,Mình mới vừa làm được phần này. Cái này parse cũng được mà chứ nhỉ :-?. Dù sao cũng cám ơn bạn :D
thinh van,1,11/5/2011,Re:Hỏi về break và continue,"tóm lại quyết một tiếng là có kiểm tra cái này hok zậy mấy bạn, mờ mờ ảo ảo sao í, mệt thiệt"
Vu Dang,1,11/5/2011,Re:Hỏi về break và continue,cai nay Parser dc. dac ta noi vay thi minh cu lam vay di
Forever Alone,1,11/5/2011,Re:Hỏi về break và continue,"Ko. Cả 2 đều parse thành công hết bạn :D 1. [proc(child2,[par(a,arr([1],int))],[loop(5,break(null)),var(a,int),var(b,int)])] 2. [proc(child2,[par(a,arr([1],int))],[loop(5,[assign(a,5),break(null)]),var(a,int),var(b,int)])]"
Forever Alone,1,11/5/2011,Re:Hỏi về break và continue,À mình nhầm. Cho mình đính chính lại phần này ko kiểm tra phạm vi của break và continue nên cả 2 test case trên đều đúng. Luôn cả trường hợp break và continue nằm ngoài loop và while cũng đúng. :D @Tan Phat: thầy Tân nói là không kt phạm vi break và continue
Sieutoc,1,11/6/2011,Re:Hỏi về break và continue,@Tan Phat: thầy Tân nói là không kt phạm vi break và continue
thinh van,1,11/5/2011,Re:Hỏi về Array Type và Array Element,"code của bạn ngồ ngộ sao í, hình như cái định dạng của bạn hok chính xác cho lắm"
Why So Serious,1,11/5/2011,Hỏi về Array Type và Array Element,"""array"" ~> ""["" ~> rep1sep..... phải là (""array"" ~ ""["") ~> rep1sep...."
Long Nguyễn,1,10/28/2011,Một số câu hỏi về array,"Các thầy cho em hỏi 1 chút về array: 1. Truy cập mảng nhiều chiều như thế nào? VD: a[1][1] := 1; hay: a[1,1] := 1; 2. Mảng rỗng có báo lỗi ở phần Parser này không? Báo như thế nào? VD:var z: array [] of integer; thì ra: [var(z,arr([],int))] hay:line 1:15: unexpected token: `]'"
Huỳnh Trọng Khiêm,1,11/6/2011,Re:Hỏi về Array Type và Array Element,"Mình khai báo thế này bị lỗi, mong các bạn chỉ giúp mình với def arrayType : Parser[ArrayTypePT] = ((""array"" ~> rep1(""["" ~> intLiteral <~ ""]"") <~ ""of"") ~ (""real""|""interger"")) ^^ { case lst ~ t => ""arr(["" + (lst.head /:lst.tail)(_+"",""+_) + ""],"" + t + "") "" }"
Nguyễn Đức Huy,1,11/6/2011,Hỏi về Array Type và Array Element,"Đã sửa lại code như Just a Tee gợi ý, mà vẫn là parse lỗi  :-ss"
Tri,1,11/6/2011,Hỏi về Array Type và Array Element,"Theo van Nasregas wrote: Đã sửa lại code như Just a Tee gợi ý, mà vẫn là parse lỗi  :-ss (""array"" ~> ""["" ~> rep1sep(intLiteral,"","") <~ ""]"" <~ ""of"") ~ (primitiveType)^^ {...}"
huongcuibap,0,11/6/2011,Re:Hỏi về Array Type và Array Element,@Tri: cách của Trí đúng rồi đó @ Theo van Nasregas
huongcuibap,0,11/6/2011,Re:Hỏi về Array Type và Array Element,BUT khi parser:var z: array [1] of integer; thì báo lỗi ở OF: var z: array [1] of integer;
huongcuibap,0,11/6/2011,Re:Hỏi về Array Type và Array Element,":D, fixed được rồi. do dư khoảng trắng sau of ""of """
Nguyễn Đức Huy,1,11/6/2011,Hỏi về Array Type và Array Element,"Vẫn Lỗi @Trí, @coffee cafe Test : var a:array[9] of real; Lỗi này nè : ``]'' expected but 9 found Là sao vậy ta?"
Linh Nguyen Thanh,1,10/28/2011,Re:Một số câu hỏi về array,"Với input Code: var z: array [] of integer; của mình ra là : Code: line 1:15: unexpected token: ] Chứ không có dấu `' bao quan token ] Theo đặc tả mình cũng thấy vậy : var a:integer; b var c:integer; ouput thầy cho là Code: line 2:1: unexpected token: b đâu có `b' đâu. Các bạn nghĩ sao, Mong thầy giài đáp. Chứ cái này nguy hiểm nha."
Linh Nguyen Thanh,1,10/28/2011,Re:Một số câu hỏi về array,"Cho em hỏi thêm nha (hơi lạc chủ đề chút ,khỏi lập topic mới) với input thế này var x, y, z: integer; và input thế này : var x: integer; var y: intger; var z: integer; thì chúng cùng ra là ouput là : [var(x,int),var(y,int),var(z,int)] đúng không. Hay với input đầu , nó ra thế này : [var(x,y,z,int)] (cái này là mình dự đoán thêm thôi chứ không chắc :)) hay là thế nào khác. Mong thầy và các bạn góp ý. Vấn đề này khi khai báo tham số cho 1 function hay 1 procedure cùng gặp tương tự."
Long Nguyễn,1,10/28/2011,Re:Một số câu hỏi về array,"[var(x,int),var(y,int),var(z,int)] Trong đặc tả có nói rồi đấy."
LAV,1,10/28/2011,Một số câu hỏi về array,"Theo mình nghĩ nó ra cái trên đó. Khi ông khai báo gộp hay riêng rẽ thì khi phân tích lúc nào cũng phải phân tích riêng từng biến ra, bao gồm tên biến, loại j trong dấu ngoặc. Vì vậy var x, y, z: integer sẽ ra là [var(x,int),var(y,int),var(z,int)]"
Linh Nguyen Thanh,1,10/28/2011,Re:Một số câu hỏi về array,mình cũng nghĩ ra như các bác đã đề cập. Nhưng minh còn nghi vấn ở chỗ : nếu chúng cùng ra 1 output như thế thì làm sao khi mà chúng ta đọc ouput ta có thể phân biệt là input đc khai báo theo cách 1 hay cách 2 (ứng với 2 input trên). ( Giả sử chúng ta muốn phân biệt input là gì nha và chúng ta quan tâm đến input đc khai báo thế nào dựa và KQ xuất). cả 2 output đều có khả năng đc hiện thực với khung mẫu đã cho .
Long Nguyễn,1,10/28/2011,Một số câu hỏi về array,Đâu có cần phân biệt input làm gì đâu bạn.
50902440,1,11/6/2011,1.1 mod 1.2,các bạn cho mình hỏi câu này có đúng ko : 1.1 mod 1.2
Long Nguyễn,1,11/6/2011,1.1 mod 1.2,Ý bạn hỏi là gì? Nếu hỏi nó có phải là expression không thì đúng. Còn là chương trình parse được thì không.
50902440,1,11/6/2011,1.1 mod 1.2,"vậy bạn cho mình hỏi thêm, thí dụ a:= 1 mod fun(1); mình có cần phải kiểm tra kiểu của fun(1) ko?"
Long Nguyễn,1,11/6/2011,1.1 mod 1.2,"be be wrote: vậy bạn cho mình hỏi thêm, thí dụ a:= 1 mod fun(1); mình có cần phải kiểm tra kiểu của fun(1) ko? Có, nhưng trong ass 2 :D"
50902440,1,11/6/2011,1.1 mod 1.2,tại sao 1.1 mod 1.2 ko parse dc vậy bạn ?
_Trung_Than_Thong,1,11/6/2011,Re:một trường hợp về hằng chuỗi,Uh câu hỏi rất hay. Mà giờ ai giải đáp dùm đây ah mà mình nghĩ thế này. Từ state1 cũng đã nói rõ là string nhập vào nếu là 1 dấu ' thì phải double nó lên thành ''. Do đó chuỗi đầu tiên của bạn gồm 3 dấu ' là chuỗi nhập vào không hợp lệ rồi (đây là yêu cầu input từ người dùng chứ không phải yêu cầu mình xử lý)
Đỗ Sỹ Hưng,1,11/6/2011,Re:một trường hợp về hằng chuỗi,/* delete */
Long Nguyễn,1,11/6/2011,một trường hợp về hằng chuỗi,"Guest User wrote: const x='''; line 1:11: unexpected token: ' Guest User wrote: const x=''''''''; [const(x,''')]"
Why So Serious,1,11/6/2011,một trường hợp về hằng chuỗi,//Deleted: đã có trong topic khác :D
Long Nguyễn,1,11/6/2011,một trường hợp về hằng chuỗi,"Just A Tee wrote: const a = ''; // 2 dấu nháy đơn thì ra cái gì mọi người [const(c,)]"
Forever Alone,1,11/6/2011,một trường hợp về hằng chuỗi,Guest User wrote: cho em hỏi test const x='''; kết quả là gì const x=''''''''; ra kết quả là gì vậy Ủa sao cái trường hợp đầu tiên mình xuất ra lỗi một đống vậy ta : Exception in thread "main" java.util.NoSuchElementException: next on empty iterator at scala.collection.Iterator$$anon$3.next(Iterator.scala:28) at scala.collection.Iterator$$anon$3.next(Iterator.scala:26) at scala.collection.IndexedSeqLike$Elements.next(IndexedSeqLike.scala:63) at scala.collection.IterableLike$class.head(IterableLike.scala:90) at scala.collection.immutable.StringOps.scala$collection$IndexedSeqOptimized$$super$head(StringOps.scala:31) at scala.collection.IndexedSeqOptimized$class.head(IndexedSeqOptimized.scala:121) at scala.collection.immutable.StringOps.head(StringOps.scala:31) at CrazyParser$$anonfun$const$4$$anonfun$apply$84.apply(Crazy2011.scala:294) at CrazyParser$$anonfun$const$4$$anonfun$apply$84.apply(Crazy2011.scala:291) at scala.util.parsing.combinator.Parsers$Success.map(Parsers.scala:108) at scala.util.parsing.combinator.Parsers$Success.map(Parsers.scala:107) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Failure.append(Parsers.scala:163) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Success.flatMapWithNext(Parsers.scala:114) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Failure.append(Parsers.scala:163) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anonfun$rep1$1.apply(Parsers.scala:602) at scala.util.parsing.combinator.Parsers$$anonfun$rep1$1.apply(Parsers.scala:588) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Success.flatMapWithNext(Parsers.scala:114) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Success.flatMapWithNext(Parsers.scala:114) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Failure.append(Parsers.scala:163) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anonfun$rep1$1.apply(Parsers.scala:602) at scala.util.parsing.combinator.Parsers$$anonfun$rep1$1.apply(Parsers.scala:588) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anon$2.apply(Parsers.scala:754) at CrazyParser.parse(Crazy2011.scala:113) at TestParser$.main(TestParser.scala:17) at TestParser.main(TestParser.scala) Bạn nào biết chỉ mình với ~~~
huongcuibap,0,11/6/2011,Re:Hỏi về Array Type và Array Element,bạn check lại primitiveType xem hoặc test trước với integerType xem
FirstName LastName,1,11/6/2011,Re:Hỏi về Array Type và Array Element,"Ủa, cái code ngayđầu tôi cũng làm vậy, ko có sai :D Kiểm tra lại kiểu Float của regexđi"
Linh Nguyen Thanh,1,10/29/2011,Re:Một số câu hỏi về array,"Cảm ơn anh đã giải đáp nghi vấn. Vo Thanh Hung wrote: 2) Trong định dạng cây sinh ra có thể làm được điều đó hay không? VarDecPT(val variable: IdPT, val varType: TypePT) Với output thứ 2 , muốn làm thì cũng được thôi, một trong những cách là : Ta gộp các IDENT lại với nhau ngăn cách bởi dấu phẩy( hay theo định dạng nào nếu ta muốn) thành1 string rồi new IdPT cho chuỗi này , sau roi new class trên là được. Đây là hiên thực thêm nếu có yêu cầu . Mà bây giờ không có thì thôi. Dù sao cũng cảm ơn anh đã giải đáp thắc mắc."
walk alone,1,10/29/2011,Re:Một số câu hỏi về array,"cho em hỏi: khi khai báo constan  là array, thì các phần tử trong array mình có phải kiểm tra nó có tương đồng nhau không hả anh??"
Long Nguyễn,1,11/1/2011,Re:Một số câu hỏi về array,"walk alone wrote: cho em hỏi: khi khai báo constan  là array, thì các phần tử trong array mình có phải kiểm tra nó có tương đồng nhau không hả anh?? Kiểm tra kiểu trong ass2 lận."
Doan Tuan Sang,1,11/2/2011,Re:Một số câu hỏi về array,huhu ai chỉ mình với sao mình làm nó ra thế này [1.15] failure: int expected var z: array[] of integer; ^ khi sử sụng println(result) còn bình thường không báo gì hết...
nguyen dung,1,11/3/2011,Re:Một số câu hỏi về array,"Doan Tuan Sang wrote: huhu ai chỉ mình với sao mình làm nó ra thế này [1.15] failure: int expected var z: array[] of integer; ^ khi sử sụng println(result) còn bình thường không báo gì hết... Bạn xem hàm intLiteral, cái elem có chữ int dùng để xuất khi có lỗi đấy. Bạn sửa cái hàm show cho nó báo lỗi theo ý mình là được thôi"
Thanh Pham Minh,1,11/3/2011,Một số câu hỏi về array,
Long Nguyễn,1,11/6/2011,1.1 mod 1.2,"vì nó không phải là chương trình, có chương trình nào chỉ cụt ngủn vậy đâu!"
50902440,1,11/6/2011,1.1 mod 1.2,uh` mình hiểu rồi. Thaks
Cong Cuong Pham,1,11/6/2011,một trường hợp về hằng chuỗi,trường hợp đầu mình giống bạn trên =(( một đống lỗi
Jakul KID,1,11/5/2011,Một số câu hỏi về array,trong array const có trường hợp này [[1;2];[3;4]] vậy trong khai báo có trường hợp này không ta ? var a:array[2] of array[2] of integer;
BT Lớn,1,11/6/2011,Một số câu hỏi về array,"Jakul  wrote: trong array const có trường hợp này [[1;2];[3;4]] vậy trong khai báo có trường hợp này không ta ? var a:array[2] of array[2] of integer; ""An array type declaration starts with the keyword array, a list of dimensions, keyword of, and ends with a primitive type."" kết thúc nó phải là primitive Type...như trên là báo lỗi"
Long Nguyễn,1,11/6/2011,Re:Một số câu hỏi về array,"Scala ^^  wrote: cho mình hỏi const a=[]; thì output là: [const(a,[])] phải k mấy bạn? hay la báo lỗi line 1:10: unexpected token: ] [const(a,[])]"
Bruce Wayne,1,11/6/2011,Re:Một số câu hỏi về array,"Long Potter wrote: Scala ^^  wrote: cho mình hỏi const a=[]; thì output là: [const(a,[])] phải k mấy bạn? hay la báo lỗi line 1:10: unexpected token: ] [const(a,[])] Array constant đâu có dc rỗng"
Long Nguyễn,1,11/6/2011,Re:Một số câu hỏi về array,"T.D.N  wrote: Long Potter wrote: Scala ^^  wrote: cho mình hỏi const a=[]; thì output là: [const(a,[])] phải k mấy bạn? hay la báo lỗi line 1:10: unexpected token: ] [const(a,[])] Array constant đâu có dc rỗng Cái này cũng không chắc lắm nhưng code xử lí được thì cho xử lí luôn."
Why So Serious,1,11/6/2011,Một số câu hỏi về array,"Cho mình hỏi luôn: a := b[2, 3, [3]]; c := d[3, [4;5], 2]; e := f[5, [], 2]; ra kết quả ntn vậy mọi người?"
Long Nguyễn,1,11/6/2011,Một số câu hỏi về array,"Just A Tee wrote: Cho mình hỏi luôn: a := b[2, 3, [3]]; c := d[3, [4;5], 2]; e := f[5, [], 2]; ra kết quả ntn vậy mọi người? [proc(a,[],[assign(a,ele(b,[2,3,[3]])),assign(c,ele(d,[3,[4;5],2])),assign(e,ele(f,[5,[],2]))])] Test với procedure a()"
Why So Serious,1,11/6/2011,Một số câu hỏi về array,Vậy array constant chấp nhận empty array à?
Bruce Wayne,1,11/6/2011,Một số câu hỏi về array,"Just A Tee wrote: Vậy array constant chấp nhận empty array à? Người thì dựa vào file PT.scala, người thì dựa vào đặc tả. Hên xui thôi :D"
Forever Alone,1,11/6/2011,một trường hợp về hằng chuỗi,Guest User wrote: trường hợp đầu mình giống bạn trên =(( một đống lỗi Mình đã tìm được lỗi. Đó là do phần xử lí string mặc định ở trong hàm const của thầy. Vô trong đó sửa xíu thì hết bị :D. KQ 2 test ra giống mấy bạn trên :D
Huỳnh Trọng Khiêm,1,11/6/2011,Giúp mình khai báo BooleanLiteral với !!!!!,"Mình khai báo boolean thế này def booleanLiteral : Parser[BooleanLiteralPT] =elem(""boolean"", _.isInstanceOf[lexical.BooleanLit]) ^^ { a => new BooleanLiteralPT(a.chars)} và chỗ regex mình thêm vào regex(""""""true|false"""""".r) ^^ { BooleanLit(_) } nó không báo lỗi nhưng vẫn không hỉu hàm def booleanLiteral mấy bạn giúp mình với ^^"
BT Lớn,1,11/6/2011,Giúp mình khai báo BooleanLiteral với !!!!!,"Lions wrote: Mình khai báo boolean thế này def booleanLiteral : Parser[BooleanLiteralPT] =elem(""boolean"", _.isInstanceOf[lexical.BooleanLit]) ^^ { a => new BooleanLiteralPT(a.chars)} và chỗ regex mình thêm vào regex(""""""true|false"""""".r) ^^ { BooleanLit(_) } nó không báo lỗi nhưng vẫn không hỉu hàm def booleanLiteral mấy bạn giúp mình với ^^ mình làm thế này def booleanLiteral : Parser[BooleanLiteralPT] = (""true""|""false"")^^{a => new BooleanLiteralPT(a)}"
Đỗ Sỹ Hưng,1,11/6/2011,Giúp mình khai báo BooleanLiteral với !!!!!,"Lions wrote: Mình khai báo boolean thế này def booleanLiteral : Parser[BooleanLiteralPT] =elem(""boolean"", _.isInstanceOf[lexical.BooleanLit]) ^^ { a => new BooleanLiteralPT(a.chars)} và chỗ regex mình thêm vào regex(""""""true|false"""""".r) ^^ { BooleanLit(_) } nó không báo lỗi nhưng vẫn không hỉu hàm def booleanLiteral mấy bạn giúp mình với ^^ Cách 2: cho regex(""""""true|false"""""".r) ^^ { BooleanLit(_) } lên trướcregex(""[a-z][a-zA-Z]*"".r) ^^ { processIdent(_) } => hết lỗi :)"
Huỳnh Trọng Khiêm,1,11/6/2011,Re:Giúp mình khai báo BooleanLiteral với !!!!!,cảm ơn 2 bạn nhìu ^^
sat long,1,11/6/2011,IF ESLE ,có bạn nào cho cho mình biết rỏ hơn về mô tả ì và else cái; cái if else bản thân nó kết thúc có cần dấu "; " ko? hay là của stament? mập mờ quá? vd: if a+b then a:=b; hay if a+b then a:=b;; tương tự với if else ??
Forever Alone,1,11/6/2011,Re:IF ESLE ,Bản thân if ... then.... else.... đã chứa cái statement trong đó : if <expression> then <statement> else <statement> or if <expression> then <statement> nên bạn cứ thêm 1 statement vô đó còn chuyện nó có ; hay ko là do statement đó quyết định.
BT Lớn,1,11/6/2011,Re:IF ESLE ,lúc mình định dạng if- else có thể có trường hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc đơn k...cái này đặc tả k rõ gì cả
Phúc Trí,1,11/6/2011,Re:IF ESLE ,Cao Đại wrote: lúc mình định dạng if- else có thể có trường hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc đơn k...cái này đặc tả k rõ gì cả ghi vậy là 1 chứ mấy nữa hả bạn. bạn muốn rõ như thế nào nữa
Forever Alone,1,11/6/2011,Re:IF ESLE ,Cao Đại wrote: lúc mình định dạng if- else có thể có trường hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc đơn k...cái này đặc tả k rõ gì cả Thực chất 1 hay nhiều expression thì cũng như nhau vì trong expression này có thể chứa expression kia.
Đặng Toàn Trí,1,11/6/2011,Re:IF ESLE ,Em yêu Scala ♥♥♥ wrote: Cao Đại wrote: lúc mình định dạng if- else có thể có trường hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc đơn k...cái này đặc tả k rõ gì cả Thực chất 1 hay nhiều expression thì cũng như nhau vì trong expression này có thể chứa expression kia. Cách nói chuyện nghe rất quen :X
BT Lớn,1,11/6/2011,Re:IF ESLE ,Em yêu Scala ♥♥♥ wrote: Cao Đại wrote: lúc mình định dạng if- else có thể có trường hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc đơn k...cái này đặc tả k rõ gì cả Thực chất 1 hay nhiều expression thì cũng như nhau vì trong expression này có thể chứa expression kia. ý mình muốn hỏi là nó có dạng thế này k đấy : if <expr> ; <expr> then <stmt>
Đỗ Sỹ Hưng,1,11/6/2011,Re:IF ESLE ,Ban đọc kĩ đặc tả một chút: if <expr> then <statement> nếu theo bạn thì "<expr> ;<expr> " sẽ là <expr> => ";" là 1 toán tử ? nên không có trường hợp if <expr> ;<expr> then <statement>
Nhat Nguyen,1,11/6/2011,Vấn đề submit state2,"Mình thấy file gốc của thầy là Crazy2011.scala, trong khi trên sakai lại yêu cầu nộp file crazy2011.scala. Zậy nộp cái nào đây ?"
Nhat Nguyen,1,11/6/2011,Vấn đề submit state2,à trong notice đã có rùi ^^
Tin Bui,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"Mình chỉ còn đêm nay để hoàn tất ass1 thôi, sáng mai phải về quê sớm rồi, có vài câu hỏi thôi, mong ai biết giúp mình nhé: 1.  Trong hàm def show, mình hiểu hướng để làm nhưng ko hiểu cách thức trình bày cái unexpected token sao ko đc chấp nhận: ""line ""+<<line>>+"":""+<<column>>"":""+"" unexpected token: "" + if(.....) {.....} else { .....} Có bạn nào biết sai ở đâu nhắc mình tí với, dấu + dùng ở đây có phù hợp ko? 2. Trong file đặc tả, mình vẫn ko hiểu mục 3.Types là dùng thế nào, ai cho mình vài ví dụ với"
Vinh Thọt,1,11/6/2011,hàm Constant của thầy,các bạncho mình hỏi: const a = ''''''; (6 nháy đơn) khi mình xử lý kết quả đúng sẽ là hai nháy đơn hay 1 nháy đơn trả về.?
Lê Quốc Nam,1,11/6/2011,Re:hàm Constant của thầy,"Vấn đề này đang chờ thầy giải quyết... Nếu theo đặc tả thì xâu thực sự sẽ có hai nháy đơn, nhưng theo code của thầy thì còn lại một dấu nháy..."
Nhất Tiếu nại Hà,1,11/7/2011,Re:hàm Constant của thầy,"theo mình nó ra vầy: [const(a,')]"
Đỗ Sỹ Hưng,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"DoomAce  wrote: Mình chỉ còn đêm nay để hoàn tất ass1 thôi, sáng mai phải về quê sớm rồi, có vài câu hỏi thôi, mong ai biết giúp mình nhé: 1.  Trong hàm def show, mình hiểu hướng để làm nhưng ko hiểu cách thức trình bày cái unexpected token sao ko đc chấp nhận: ""line ""+< >+"":""+< >"":""+"" unexpected token: "" + if(.....) {.....} else { .....} Có bạn nào biết sai ở đâu nhắc mình tí với, dấu + dùng ở đây có phù hợp ko? Bạn thử dùng () đối với biểu thức if, như thế này nè: ""line ""+< >+"":""+< >"":""+"" unexpected token: "" +(if(.....) {.....} else { .....})"
Tin Bui,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"Đỗ Sỹ Hưng  wrote: DoomAce  wrote: Mình chỉ còn đêm nay để hoàn tất ass1 thôi, sáng mai phải về quê sớm rồi, có vài câu hỏi thôi, mong ai biết giúp mình nhé: 1.  Trong hàm def show, mình hiểu hướng để làm nhưng ko hiểu cách thức trình bày cái unexpected token sao ko đc chấp nhận: ""line ""+< >+"":""+< >"":""+"" unexpected token: "" + if(.....) {.....} else { .....} Có bạn nào biết sai ở đâu nhắc mình tí với, dấu + dùng ở đây có phù hợp ko? Bạn thử dùng () đối với biểu thức if, như thế này nè: ""line ""+< >+"":""+< >"":""+"" unexpected token: "" +(if(.....) {.....} else { .....}) Cảm ơn bạn! mình sơ suất quá, vậy còn câu số 2. Có ai biết cho mình vài ví dụ với Minh cũng muốn hỏi thêm về trường hợp break và continue, đặc tả nói break, conti chỉ đc dùng trong statement của while_do_ và loop_do_ vậy trong trường hợp như : while_ do if _ then begin break; end; có chấp nhận ko? vì break đúng là xảy ra trong stmt của While nhưng nó lại break trong stmt của If nằm trong While?"
Bernkastel 奇跡の魔女,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"DoomAce  wrote: Cảm ơn bạn! mình sơ suất quá, vậy còn câu số 2. Có ai biết cho mình vài ví dụ với Minh cũng muốn hỏi thêm về trường hợp break và continue, đặc tả nói break, conti chỉ đc dùng trong statement của while_do_ và loop_do_ vậy trong trường hợp như : while_ do if _ then begin break; end; có chấp nhận ko? vì break đúng là xảy ra trong stmt của While nhưng nó lại break trong stmt của If nằm trong While? Type bạn thêm vào đoạn thầy note // TYPE trong crazyscala thầy chỉ định nghĩa sẵn integer, bạn phải viết lại, real, bool, string, array"
Forever Alone,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"DoomAce  wrote: Cảm ơn bạn! mình sơ suất quá, vậy còn câu số 2. Có ai biết cho mình vài ví dụ với Minh cũng muốn hỏi thêm về trường hợp break và continue, đặc tả nói break, conti chỉ đc dùng trong statement của while_do_ và loop_do_ vậy trong trường hợp như : while_ do if _ then begin break; end; có chấp nhận ko? vì break đúng là xảy ra trong stmt của While nhưng nó lại break trong stmt của If nằm trong While? Trong bước này chưa kiểm tra phạm vi của break với continue nên nằm đâu cũng đúng"
Tin Bui,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"フランドール 最終鬼畜妹 wrote: DoomAce  wrote: Cảm ơn bạn! mình sơ suất quá, vậy còn câu số 2. Có ai biết cho mình vài ví dụ với Minh cũng muốn hỏi thêm về trường hợp break và continue, đặc tả nói break, conti chỉ đc dùng trong statement của while_do_ và loop_do_ vậy trong trường hợp như : while_ do if _ then begin break; end; có chấp nhận ko? vì break đúng là xảy ra trong stmt của While nhưng nó lại break trong stmt của If nằm trong While? Type bạn thêm vào đoạn thầy note // TYPE trong crazyscala thầy chỉ định nghĩa sẵn integer, bạn phải viết lại, real, bool, string, array Cái type về integer thì mình đã biết, nhưng ý mình muốn hỏi là trong đặc tả phần 3 còn ghi thêm: The keyword integer is used to represent an integer type. Integer values can be operands of the following operators: div mod + - * / < <= > >= = <> ^ thì những cái đó dùng trong trường hợp nào, bạn cho vài ví dụ về nó với. tương tự với real, bool, string, array"
Tin Bui,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"フランドール 最終鬼畜妹 wrote: DoomAce  wrote: Cảm ơn bạn! mình sơ suất quá, vậy còn câu số 2. Có ai biết cho mình vài ví dụ với Minh cũng muốn hỏi thêm về trường hợp break và continue, đặc tả nói break, conti chỉ đc dùng trong statement của while_do_ và loop_do_ vậy trong trường hợp như : while_ do if _ then begin break; end; có chấp nhận ko? vì break đúng là xảy ra trong stmt của While nhưng nó lại break trong stmt của If nằm trong While? Type bạn thêm vào đoạn thầy note // TYPE trong crazyscala thầy chỉ định nghĩa sẵn integer, bạn phải viết lại, real, bool, string, array ^ ^ ^ Cảm ơn bạn nhé! Cái type về integer thì mình đã biết, nhưng ý mình muốn hỏi là trong đặc tả phần 3 còn ghi thêm: The keyword integer is used to represent an integer type. Integer values can be operands of the following operators: div mod + - * / < <= > >= = <> ^ thì những cái đó dùng trong trường hợp nào, bạn cho vài ví dụ về nó với. tương tự với real, bool, string, array"
M.U.,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"DoomAce  wrote: Mình chỉ còn đêm nay để hoàn tất ass1 thôi, sáng mai phải về quê sớm rồi, có vài câu hỏi thôi, mong ai biết giúp mình nhé: 1.  Trong hàm def show, mình hiểu hướng để làm nhưng ko hiểu cách thức trình bày cái unexpected token sao ko đc chấp nhận: ""line ""+< >+"":""+< >"":""+"" unexpected token: "" + if(.....) {.....} else { .....} Có bạn nào biết sai ở đâu nhắc mình tí với, dấu + dùng ở đây có phù hợp ko? bạn DoomAce có thể chỉ rõ giúp mình phần show dc ko, mình mò hum qua đến giờ, đọc bài mấy bạn chỉ làm cũng ko dc nữa, hixx :(( nick yahoo của mình là kai_ducati hy vọng dc bạn giúp :("
LAV,1,11/6/2011,Test dùm nha! ,"Các bạn thử test xem: a := asdf[a + b, a * b]; đúng hay trường hợpa := asdf[(a + b), (a * b)]; Hay cả 2 đều đúng và ra cùng 1 kết quả ???"
Nhất Tiếu nại Hà,1,11/6/2011,Test dùm nha! ,"LAV  wrote: Các bạn thử test xem: a := asdf[a + b, a * b]; đúng hay trường hợpa := asdf[(a + b), (a * b)]; Hay cả 2 đều đúng và ra cùng 1 kết quả ??? lỗi ngay kí tự đầu tiên đó bạn : line 1:1: unexpected token: a"
baran,1,11/6/2011,giúp mình sửa đoạn gán giá trị a[0] = 4;,"def arrayVariable: Parser[EleExprPT] = ident ~ (""[""~> intLiteral <~ ""]"") ^^ {case a ~ b => new EleExprPT(new IdPT(a),b )} // Phần này mình gán giá trị cho chỉ số của mảng, vd: a[o] := 4; mà sao cứ báo lỗi chỗ  ""(new IdPT(a) ,b )} "" này vậy, các bạn giúp giủm mình với def assignStmt: Parser[AssignStmtPT] = leftHandSide ~ ("":="" ~> expr <~ "";"") ^^ { case a ~ b => new AssignStmtPT(a, b) } def leftHandSide: Parser[LefHandSidePT] = variable | arrayVariable"
BT Lớn,1,11/6/2011,giúp mình sửa đoạn gán giá trị a[0] = 4;,"baran  wrote: def arrayVariable: Parser[EleExprPT] = ident ~ (""[""~> intLiteral <~ ""]"") ^^ {case a ~ b => new EleExprPT(new IdPT(a),b )} // Phần này mình gán giá trị cho chỉ số của mảng, vd: a[o] := 4; mà sao cứ báo lỗi chỗ  ""(new IdPT(a) ,b )} "" này vậy, các bạn giúp giủm mình với def assignStmt: Parser[AssignStmtPT] = leftHandSide ~ ("":="" ~> expr <~ "";"") ^^ { case a ~ b => new AssignStmtPT(a, b) } def leftHandSide: Parser[LefHandSidePT] = variable | arrayVariable class EleExprPT(val id: IdPT, val exprs: List[ExprPT]).... b không phải là 1 List nên nó báo lỗi... bạn sửa lại là rep1sep(intLiteral,"","") thử đi"
baran,1,11/7/2011,Re:giúp mình sửa đoạn gán giá trị a[0] = 4;,"cám ơn ban nhiu nha, mình chạy dc rồi."
Đặng Toàn Trí,1,11/5/2011,1 số thắc mắc ,"Scala ^^  wrote: Trong quá trình làm bài, em thấy có 1 số điểm mâu thuẫn như sau: 1. const array có chấp nhận a[ ] không, theo như SPEC đặc tả thì không, nhưng trong PT.scala thì cho phép nó rỗng và xuất "" "" 2. EleExprPT khi exprs=null thì nó trả về id, nên a[ ]:= thì parser trả về giống như a:=; hay là báo lỗi chỗ a[ ] 3. var a:array [0 ] of integer; Cái này thầy nói là parse đc trong 1 topic, nhưng trong đặc tả nói cái dimen đó phải là số nguyên dương. 4. Trong phần statement lệnh break đặc tả bảo là phải nằm trong loop hoặc while. ass1 này có hiện thực không? Cuối cùng, cho em hỏi giai đoạn này không cần check kiểu trong array mà parse được hết phải không thầy? Những cái này rất nhìu bạn hỏi, mà theo như em đọc thì chưa có câu trả lời chính thức từ thầy. em tổng hợp lại để dễ theo dõi.mong nhận được câu trả lời sớm của thầy. Bạn phải tự phân biệt được việc gì sẽ phải làm ở Parser. Thân!"
Forever Alone,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"DoomAce  wrote: ^ ^ ^ Cảm ơn bạn nhé! Cái type về integer thì mình đã biết, nhưng ý mình muốn hỏi là trong đặc tả phần 3 còn ghi thêm: The keyword integer is used to represent an integer type. Integer values can be operands of the following operators: div mod + - * / < <= > >= = <> ^ thì những cái đó dùng trong trường hợp nào, bạn cho vài ví dụ về nó với. tương tự với real, bool, string, array Mấy cái này ở bước này hình như chưa cần làm đâu bạn ơi."
Bernkastel 奇跡の魔女,1,11/6/2011,Vài Question mong mọi người giúp đỡ( rất gấp),"Em yêu Scala ♥♥♥ wrote: Mấy cái này ở bước này hình như chưa cần làm đâu bạn ơi. Chính xác là qua Assignment 2 sẽ ""được"" làm :D khỏi chờ lâu À với chưa cần kiểm tra phạm vi break với continue đâu bạn, phần đó qua Assignment 2 làm luôn."
Sieutoc,1,11/6/2011,Re:Vài Question mong mọi người giúp đỡ( rất gấp),"Guest User wrote: Moi nguoi giup minh voi, khi minh khai bao : const a = [ ;  (noi chung la rerserved word hay delimiters) thi deu parse thanh cong. Minh khong hieu sao nua !!! Đây là phần khai báo const. Mình thấy đến chỗ dấu [ mà bạn vẫn parse dc, thì mình nghi là do cách parse arrayLiteral của bạn. Bạn kiểm tra lại cách bạn nhận dạng arrayLiteral . Đây là cách nhận dạng của mình: (""["" ~> lstliteral <~ ""]"") Trong đó lstliteral là một danh sách List[LiteralPT] . Các LiteralPT trong danh sách đó gồm có: intLiteral | realLiteral | stringLiteral | boolLiteral | arrayLiteral Good luck !"
LAV,1,11/6/2011,Test dùm nha! ,bạn có bỏ vào blockStmt ko? chứ bạn copy y nguyên mà bỏ vào nó báo lỗi đó. Mình thấy cái này là assignment Statement ok mà!
BT Lớn,1,11/6/2011,Test dùm nha! ,"LAV  wrote: Các bạn thử test xem: a := asdf[a + b, a * b]; đúng hay trường hợpa := asdf[(a + b), (a * b)]; Hay cả 2 đều đúng và ra cùng 1 kết quả ??? theo mình nghĩ làa := asdf[(a + b), (a * b)]; đúng a := asdf[a + b, a * b]; thì test k ra :D"
Nhất Tiếu nại Hà,1,11/6/2011,Test dùm nha! ,"LAV  wrote: bạn có bỏ vào blockStmt ko? chứ bạn copy y nguyên mà bỏ vào nó báo lỗi đó. Mình thấy cái này là assignment Statement ok mà! nếu có cái đó thì kết quả nà test: procedure main(); begin a := asdf[a + b, a * b]; end; result: [proc(main,[],[assign(a,ele(asdf,[add(a,b),times(a,b)]))])]"
LAV,1,11/6/2011,Test dùm nha! ,"Cao Đại wrote: LAV  wrote: Các bạn thử test xem: a := asdf[a + b, a * b]; đúng hay trường hợpa := asdf[(a + b), (a * b)]; Hay cả 2 đều đúng và ra cùng 1 kết quả ??? theo mình nghĩ làa := asdf[(a + b), (a * b)]; đúng a := asdf[a + b, a * b]; thì test k ra :D Mình ra giống bạn này nè ! =]"
BT Lớn,1,11/6/2011,Re:Test dùm nha! ,mình vừa sửa lại cũng ra cả 2 test :D
MFC.Maximus,1,11/6/2011,Re:Test dùm nha! ,test procedure main(a:real); begin end; procedure main(a:real); s begin end; procedure main(a:real); begin end; line 4.26: unexpected token: dentifier ai so sanh voi minh voi
Nhat Nguyen,1,11/6/2011,Re:Test dùm nha! ,MFC.Maximus wrote: test procedure main(a:real); begin end; procedure main(a:real); s begin end; procedure main(a:real); begin end; line 4.26: unexpected token: dentifier ai so sanh voi minh voi line 4:26: unexpected token: s
Linh Nguyen Thanh,1,11/7/2011,Test dùm nha! ,"LAV  wrote: Các bạn thử test xem: a := asdf[a + b, a * b]; đúng hay trường hợpa := asdf[(a + b), (a * b)]; Hay cả 2 đều đúng và ra cùng 1 kết quả ??? Tui ra cùng kết quả đấy . phần tử của mảng miễn sao nó đúng định dạng expression là đc rồi mà."
Forever Alone,1,11/5/2011,1 số thắc mắc ,"Tay Doc Au Duong Phong wrote: Scala ^^  wrote: Trong quá trình làm bài, em thấy có 1 số điểm mâu thuẫn như sau: 1. const array có chấp nhận a[ ] không, theo như SPEC đặc tả thì không, nhưng trong PT.scala thì cho phép nó rỗng và xuất "" "" 2. EleExprPT khi exprs=null thì nó trả về id, nên a[ ]:= thì parser trả về giống như a:=; hay là báo lỗi chỗ a[ ] 3. var a:array [0 ] of integer; Cái này thầy nói là parse đc trong 1 topic, nhưng trong đặc tả nói cái dimen đó phải là số nguyên dương. 4. Trong phần statement lệnh break đặc tả bảo là phải nằm trong loop hoặc while. ass1 này có hiện thực không? Cuối cùng, cho em hỏi giai đoạn này không cần check kiểu trong array mà parse được hết phải không thầy? Những cái này rất nhìu bạn hỏi, mà theo như em đọc thì chưa có câu trả lời chính thức từ thầy. em tổng hợp lại để dễ theo dõi.mong nhận được câu trả lời sớm của thầy. Bạn phải tự phân biệt được việc gì sẽ phải làm ở Parser. Thân! Nếu nói tự phân biệt thì ai cũng phân biệt được nhưng ko phải ai cũng giống nhau :)"
Why So Serious,1,11/5/2011,1 số thắc mắc ,Em yêu Scala ♥♥♥ wrote: Nếu nói tự phân biệt thì ai cũng phân biệt được nhưng ko phải ai cũng giống nhau :) +1 :)
Forever Alone,1,11/5/2011,Re:1 số thắc mắc ,Xin trả lời câu số 3. Nguyên văn của thầy : Vo Thanh Hung wrote: librastar  wrote: 1) trường hợp var x : array[ 0 ] of integer cũng sẽ parse thành công phải ko ạ? Parse thành công Thầy đã nói vậy thì cứ vậy mà làm. Bám sát đề và thầy ;)) Bổ sung câu 4 : Ở trong topic test case của bạn vanhoa thì mình tháy có 1 bạn nói là thầy Tân nói ko cần phải kiểm tra phạm vi của break và continue ở bước này.Trích : nguyen dung wrote: @Tan Phat: thầy Tân nói là không kt phạm vi break và continue
Bruce Wayne,1,11/6/2011,1 số thắc mắc ,Vậy là xuất ra lỗi thì xuất EOF hay <eof> vậy mọi người
Long Nguyễn,1,11/6/2011,1 số thắc mắc ,"T.D.N  wrote: Vậy là xuất ra lỗi thì xuất EOF hay vậy mọi người <eof>, theo file đặc tả ass 1."
Minh Nguyen,1,11/6/2011,1 số thắc mắc ,"2 câu đầu mỗi người 1 ý. Mình cứ theo đặc tả mà làm thôi. Theo như đặc tả là ko rỗng vì: +   An array constant is a semicolon-separated list of elements enclosed in left and right square brackets. The list may NOT be empty. +   <lefthandside> element of an array (phần này đặc tả ko rõ ràng). Nếu theo như một số bạn làm là a[]:= sẽ trả về a:= (nhưng ko thấy đề yêu cầu chỗ này, nếu yêu cầu ít ra cũng phải có 1 câu là khi rỗng ta trả về Id chứ) ... Do đó mình vẫn để là báo lỗi. Hy vọng thầy đọc được sẽ không cho testcase rơi vào những trường hợp này."
ngo hoang minh,1,11/6/2011,Re:1 số thắc mắc ,Khiếp! Câu hỏi dài vậy mà cũng có người đọc.
Lê Quốc Nam,1,11/6/2011,Re:1 số thắc mắc ,ngo hoang minh wrote: Khiếp! Câu hỏi dài vậy mà cũng có người đọc. Mình không hiểu ý bạn là gì...Vậy có khi nào bạn vào phòng thi và thốt lên như vậy không Không biết chừng nào thầy mới về. Đúng lúc cần nhiều giải đáp chính xác nhất thì thầy lại đi công tác...
ngo hoang minh,1,11/6/2011,Re:1 số thắc mắc ,Chậc post vậy mà cũng có người reply.
Sieutoc,1,11/6/2011,1 số thắc mắc ,Em yêu Scala ♥♥♥ wrote: Nếu nói tự phân biệt thì ai cũng phân biệt được nhưng ko phải ai cũng giống nhau :) Like 1+
Thanh Pham Minh,1,11/6/2011,Re:1 số thắc mắc ,"A program in Crazy consists of many declarations which are variable, constant, procedure and function declarations. Nếu không có hoặc chỉ có một declaration thì sao? :D Trường hợp chỉ có một declaration: có test mẫu và đáp án mẫu rồi => không cần lo. Trường hợp không có gì cả (file input trống trơn): theo mình nên để parse được. Output là []. Vì nếu đáp án là không parse được thì đáp án đó mâu thuẫn với test mẫu rồi."
tran danh hung,1,11/6/2011,hỏi thông số vào của call procedure,"mình code thế này def callStmt: Parser[CallStmtPT] = ident ~ (""("" ~> repsep(expr, "","") <~ "")"" <~ "";"") ^^{ case a ~ Nil => new CallStmtPT(new IdPT(a), Nil) case a ~ lst => new CallStmtPT(new IdPT(a), lst) } không có lỗi gì nhưng khi chạy test thì lỗi đỏ chói khi không có tham số vào chẳng hạn: procedure main(); begin fun(); end; còn nếu có thì ok, có ai thấy có code trên có vấn đề gì ko chỉ giùm mình với :|"
Nhan Nguyen Van,1,11/6/2011,Test case la:,"const a = ''''''; // 6 dau ' const a = '""'  // dau ' , dau '' , dau ' May ban chay thu ra ket qua j? hinh nhu ham thay viet co van de."
Nhat Nguyen,1,11/6/2011,Test case la:,line 2:44: unexpected token: <eof>
Nhan Nguyen Van,1,11/7/2011,Test case la:,Nhat Nguyen wrote: line 2:44: unexpected token: const a = ''''''; chi co cai do thoi... sau dau // la minh viet chu thich cho ba thoi
Linh Nguyen Thanh,1,11/7/2011,Re:Test case la:,"với input của @Nhan , ra như trên . Còn với input là const a = ''''''; // 6 dau ' const a = '""' ; // dau ' , dau '' , dau ' của tui đây : [const(a,'),const(a,"")]"
Nhất Tiếu nại Hà,1,11/7/2011,Re:Test case la:,"Nguyễn Thanh Linh wrote: với input của @Nhan , ra như trên . Còn với input là const a = ''''''; // 6 dau ' const a = '""' ; // dau ' , dau '' , dau ' của tui đây : [const(a,'),const(a,"")] the same:[const(a,'),const(a,"")]"
Nhan Nguyen Van,1,11/7/2011,Re:Test case la:,"Nguyễn Thanh Linh wrote: với input của @Nhan , ra như trên . Còn với input là const a = ''''''; // 6 dau ' const a = '""' ; // dau ' , dau '' , dau ' của tui đây : [const(a,'),const(a,"")] vay la sai roi do ban. ham cua thay la: neu co hai dau ' thi bo di mot dau, co dau '' thi nhan doi thanh ''''; ban thu chay 2 cai nay lai coi const a = '''a'''; const a = 'a""';"
Huỳnh Trọng Khiêm,1,11/7/2011,Giúp mình hàm oneStmt ^^,Mình để hàm oneStmt như thế này bị báo lỗi def oneStmt: Parser[List[StmtPT]] = varDec|constDec| expr|stmt ^^ { case a => List(a) };
.duc hoang,1,11/7/2011,Giúp mình hàm oneStmt ^^,Lions wrote: Mình để hàm oneStmt như thế này bị báo lỗi def oneStmt: Parser[List[StmtPT]] = varDec|constDec| expr |stmt ^^ { case a => List(a) }; làm gì có expr ở đây hả bạn??? expr có kiểu ExprtPT mà. bỏ nó ra đi.
Sieutoc,1,11/6/2011,Re:1 số thắc mắc ,"Thanh Pham Minh wrote: A program in Crazy consists of many declarations which are variable, constant, procedure and function declarations. Nếu không có hoặc chỉ có một declaration thì sao? :D Trường hợp chỉ có một declaration: có test mẫu và đáp án mẫu rồi => không cần lo. Trường hợp không có gì cả (file input trống trơn): theo mình nên để parse được. Output là []. Vì nếu đáp án là không parse được thì đáp án đó mâu thuẫn với test mẫu rồi. Đồng ý với bạn. Với input trống trơn thì mình ra output là: []"
Đỗ Sỹ Hưng,1,11/6/2011,Re:hỏi thông số vào của call procedure,"CallStmtPT không chấp nhận list = null đâu, lớp CallStmtPT chỉ nhận kiểu list và list này có thể rỗng (list.isEmpty == true). Do đó, bạn chỉ cần xử lí trường hợp case a ~ lst là đủ rồi"
tran danh hung,1,11/6/2011,Re:hỏi thông số vào của call procedure,"Đỗ Sỹ Hưng  wrote: CallStmtPT không chấp nhận list = null đâu, lớp CallStmtPT chỉ nhận kiểu list và list này có thể rỗng (list.isEmpty == true). Do đó, bạn chỉ cần xử lí trường hợp case a ~ lst là đủ rồi trong PT.scala có xử lý đấy bạn ak, def callStmt: Parser[CallStmtPT] = ident ~ (""("" ~> repsep(expr, "","") <~ "")"" <~ "";"") ^^{ //case a ~ Nil => new CallStmtPT(new IdPT(a), Nil) case a ~ lst => new CallStmtPT(new IdPT(a), Nil) } bạn sẽ thấy"
Đỗ Sỹ Hưng,1,11/6/2011,Re:hỏi thông số vào của call procedure,"Phần class CallStmtPT trong file PT nè bạn: class CallStmtPT(val ident: IdPT, val exprs: List[ExprPT]) extends StmtPT { override def toString = ""call("" + ident + "","" + ""["" + (if (! exprs.isEmpty ) (exprs.head.toString /: exprs.tail)(_ + "","" + _.toString) else """") + ""])"" } exprs luôn có, nhưng exprs có thể rỗng. P/s: Nil có khác null không ??"
Huỳnh Trọng Khiêm,1,11/7/2011,Re:hỏi thông số vào của call procedure,kết quả báo lỗi line 3:14: unexpected token: )
Đặng Toàn Trí,1,11/7/2011,Re:Test case la:,"nhan nguyen van wrote: Nguyễn Thanh Linh wrote: với input của @Nhan , ra như trên . Còn với input là const a = ''''''; // 6 dau ' const a = '""' ; // dau ' , dau '' , dau ' của tui đây : [const(a,'),const(a,"")] vay la sai roi do ban. ham cua thay la: neu co hai dau ' thi bo di mot dau, co dau '' thi nhan doi thanh ''''; ban thu chay 2 cai nay lai coi const a = '''a'''; const a ='a""'; Đặc tả ghi sao thì làm vậy, hơi đâu nghe theo code ổng"
Thanh Pham Minh,1,11/4/2011,String Literal,"Nếu giữ nguyên chỗ def const thì sẽ có một số trường hợp đáng chú ý sau: Trường hợp 1: Input: const f = '""'; // dấu nháy đơn ' rồi đến dấu nháy kép "" rồi đến dấu nháy đơn '. const g = 'a""'; //dấu nháy đơn ' rồi đến a rồi đến dấu nháy kép "" rồi đến dấu nháy đơn. Output: [const(f,""),const(g,a"""")] hằng string ở biến g đã bị nhân đôi dấu nháy kép trong khi hằng string ở biến f thì không. Các dấu nháy kép đều bị nhân đôi trừ dấu đứng ở đầu string. => không thống nhất. Ví dụ tương tự: const h = '""a""'; => [const(h,""a"""")] Đồng ý là có những chỗ trong source mẫu cần phải sửa, nhưng đặc tả không nói về trường hợp trên. Mong thầy nói rõ: Dấu nháy kép "" trong hằng String có phải nhân đôi không, nhân đôi ở những vị trí nào? Em cảm ơn."
Thanh Pham Minh,1,11/4/2011,Re:String Literal,"Trường hợp 2: Input: const c = '''''a'''''; //mỗi bên a có 5 dấu nháy đơn ' Output: [const(c,'a')] Lẽ ra nên là [const(c,''a'')] Những vấn đề trên không nằm ở thiết kết ngôn ngữ (không phụ thuộc mức độ Crazy) mà nằm ở phần hiện thực ngôn ngữ (parseTree). Nếu giữ nguyên như bây giờ thì sau khi parse xong: const c = '''''a'''''; const d = '''a'''; const x = '""a'; const y = 'a""'; dựa vào parseTree để xử lý tiếp các phần sau ta sẽ có: assert(c == d) => ok assert(length(x) == length(y)) => NOT ok Trường hợp 3: Input: const c = ''; Output: ???"
nguyen dung,1,11/4/2011,Re:String Literal,"Em cũng có câu hỏi giống như bạn trên, cái output const của String trong code mẫu đã đúng hay chưa bởi trong đề không nói rõ phần này."
Nguyen Vo,1,11/4/2011,Re:String Literal,em cũng đang phân vân cái này. Không biết giải thích thế nào.
Nguyen Vo,1,11/4/2011,Re:String Literal,Mong thầy nói rõ về cái string literal này. truong hop const a='' sẽ báo lỗi tùm lum. hic.
Huỳnh Tiến Tài,1,11/4/2011,Re:String Literal,"A Hùng đi Thái Lan rồi, hix, giờ chẳng biết làm như thế nào???"
Thanh Cao,1,11/4/2011,Re:String Literal,theo mình nghĩ nơi nào trên thế giới cũng đều có internet
Sieutoc,1,11/4/2011,Re:String Literal,Em cung co thac mac ve stringLiteral nhu tren
Nguyen Vo,1,11/4/2011,Re:String Literal,"còn 2 ngày nữa thôi. các thầy cho em biết để em làm, cho em một tối ngủ ngon cái."
Phúc Trí,1,11/5/2011,Re:String Literal,"mình nghĩ chắc do thầy chỉ mới xử lí 2 dấu ', còn 2 dấu ' trở lên thì chưa.từ 2 dấu ' trở lên đều bị duplicate hết là do dùng /: đó.còn nhân đôi dấu "" thì nó chỉ là 1 kí tự bình thường, đặc tả ko nói j hết thì thôi.chắc cái code đó a Hùng copy qua mà quên xóa đi. nhưng quan trọng hơn là a Hùng xử lí ntn thì ko biết, xử lí ko theo cách của a thì lại bị chấm sai.bây h chẳng biết làm thế nào"
Long Nguyễn,1,11/6/2011,String Literal,Mình nghĩ là mọi người không nên dựa vào code của thầy quá. Đoạn này tự xử lí được mà.
Long Nguyễn,1,11/6/2011,Re:String Literal,"Thanh Pham Minh wrote: Trường hợp 3: Input: const c = ''; Output: ??? [const(c,)]"
Lê Quốc Nam,1,11/6/2011,Re:String Literal,Up vấn đề này lên để anh Hùng có về thì ...
Huỳnh Trọng Khiêm,1,11/7/2011,Các bạn ơi! Giúp mình phần StringLit với,"Code của thầy sao mình test ko parse vậy mấy bạn :(( def stringLiteral: Parser[String] = elem(""string"", _.isInstanceOf[lexical.StringLit]) ^^ { _.chars}"
Phúc Trí,1,11/6/2011,Re:String Literal,vẫn chưa thấy có dấu hiệu trả lời. thôi thì cứ làm theo đúng đặc tả. Có j còn ý kiến được. :D
Forever Alone,1,11/6/2011,Re:String Literal,H.T.P (^_^)  wrote: vẫn chưa thấy có dấu hiệu trả lời. thôi thì cứ làm theo đúng đặc tả. Có j còn ý kiến được. :D Làm theo đặc tả là làm sao bạn ? Là dấu " thì dup lên 2 dấu " "còn 2 dấu ' ' thì giảm xuống còn 1 ' hả ?
Lê Quốc Nam,1,11/6/2011,Re:String Literal,"Tóm lại thì StringLiteral có hai hướng như sau: 1. Để nguyên code của thầy => Một số trường hợp không chạy được, và code đó tự động double kí hiệu nháy kép lên (cái này không có trong đặc tả). Mình cũng không hiểu sao thầy lại code như thế. 2. Làm theo đặc tả, tức là hai dấu nháy đơn liên tiếp sẽ trở thành một dấu nháy đơn (vì trong đặc tả có đoạn ""if a singled - quoted belong to the string constant, it must be duplicated"" => xâu thực tế muốn nhập sẽ có số single-quoted giảm đi phân nửa. Ví dụ như bạn muốn nhập would't (một nháy đơn), thì trong phần code, phải ghi xâu là 'would''t' (hai nháy đơn) mới parse thành công, và kết quả parse sẽ là would't Không biết chừng nào thầy mới xác nhận phần này."
Linh Nguyen Thanh,1,11/6/2011,Re:String Literal,"Code mẫu cho thấy : khi 1 token là StringLit rồi thì xử lí là : - các dấu nháy đơn liên tiếp nhau được cắt giảm thành 1 dấu nháy đơn. - các dấu nháy kép đều được nhân đôi, trừ dấu nháy kép ở vị trí đầu string (nếu có ) thì giữ nguyên không nhân đôi. Theo mình đây là cách xử lí có chủ ý của anh ấy. các output đều ra theo quy luật này."
Lê Quốc Nam,1,11/6/2011,Re:String Literal,Đúng là có chủ ý thật. Nhưng mà trong đặc tả không cụ thể chủ ý này. Giờ vẫn chưa biết có sửa lại không hay để nguyên. Mà mai hết hạn rồi.
Minh Nguyen,1,11/7/2011,String Literal,"Mình cứ làm theo đặc tả là sửa code thầy lại. Dẫu sao thì code của thầy khi nhập const a = ''; cũng lỗi nên mình hok tin tưởng cái code thầy viết sẵn. Thầy nói code mẫu chưa chắc đúng mà. Cứ theo đặc tả, sau này có gì thì cứ lôi đặc tả ra hỏi thầy vậy ^^"
Nhan Nguyen Van,1,11/7/2011,Re:String Literal,"Nguyễn Thanh Linh wrote: Code mẫu cho thấy : khi 1 token là StringLit rồi thì xử lí là : - các dấu nháy đơn liên tiếp nhau được cắt giảm thành 1 dấu nháy đơn. - các dấu nháy kép đều được nhân đôi, trừ dấu nháy kép ở vị trí đầu string (nếu có ) thì giữ nguyên không nhân đôi. Theo mình đây là cách xử lí có chủ ý của anh ấy. các output đều ra theo quy luật này. sao lai ''trừ dấu nháy kép ở vị trí đầu string (nếu có ) thì giữ nguyên không nhân đôi.'' vay? co the la do thay viet sai cho nay."
BT Lớn,1,11/7/2011,Các bạn ơi! Giúp mình phần StringLit với,"Lions wrote: Code của thầy sao mình test ko parse vậy mấy bạn :(( def stringLiteral: Parser[String] = elem(""string"", _.isInstanceOf[lexical.StringLit]) ^^ { _.chars} thầy từng nói code mẫu có thể sai nên theo mình bạn nên viết lại code cho giống đặc tả trong spec..."
Trần Văn Định,1,11/7/2011,Các bạn ơi! Giúp mình phần StringLit với,"viet them mot ham khac :(( def stringLit: Parser[StringLiteralPT] = elem(""string"", _.isInstanceOf[lexical.StringLit]) ^^ { a => new StringLiteralPT(a.chars)}"
Linh Nguyen Thanh,1,11/7/2011,Re:String Literal,đây là mình thấy code thầy có ý nghĩa là vậy. còn nguyên nhân sao vậy thì mình ko dám suy đoán. Bạn có thể thử 1 vài test sẽ thấy thôi. Hơn nữa mình thấy code mẫu của thầy còn ko xử lí trường hợp hằng chuỗi trống đc.
librastar,1,11/7/2011,Re:String Literal,"Long Potter wrote: Thanh Pham Minh wrote: Trường hợp 3: Input: const c = ''; Output: ??? [const(c,)] not same. Mine: [const(c,'')] :D"
Thanh Pham Minh,1,11/7/2011,Re:String Literal,"Vo Thanh Hung wrote: 2. Rất nhiều câu hỏi do các em không đọc kỹ đặc tả 3. Các em phụ thuộc vào code mẫu quá nhiều 4. Lab là lab còn asignment là assignment, tôi không nhớ có lần nào nói rằng phải thay ' ' thành ' và "" thành """", đặc tả không có cái đó Thưa thầy, Em còn thắc mắc về phần sau: nếu đọc kỹ đặc tả ta sẽ thấy "" A program in Crazy consists of many declarations which are variable, constant, procedure and function declarations."" Em không biết phần gạch chân nên hiểu theo nghĩa nào? Nếu hiểu thông thường sẽ không parse thành công trường hợp input rỗng. Vì input rỗng sẽ không có declaration nào cả, như vậy là sai ngay từ chữ consists . Mong thầy tránh testcase như vậy ạ! Và dĩ nhiên chúng em sẽ không có thắc mắc, cứ theo đặc tả mà làm, nếu như từ trước giờ đặc tả chưa từng có ý nào phải chỉnh sửa lại!"
baran,1,11/7/2011,"các bạn giúp mình với, mình bị lỗi chỗ nào vậy?","def expr6: Parser[ExprPT] = (opt(""not""|""-"") ~ expr7) ^^ { case None ~ a => a case Some(""not"") ~ a => new BnotExprPT(a) case Some(""-"") ~ a => new SubExprPT(a) } def expr7: Parser[ExprPT] = (integerType | booleanType | realType | variable | const) ^^ { case a => new VarExprPT(new IdPT(a)) } | ""("" ~> expr <~ "")"" // phần code này mình làm phần cuối khai báo các toán tử (not,-), nhưng không hiểu sao scala lại báo lỗi phầncase a => new VarExprPT(new IdPT (a) )"
Thanh Cao,1,11/7/2011,"oneDec,oneStmt có gì ??",mọi người liệt kê dùm mình oneDec và oneStmt có những gì? Có phải những thứ có trong oneDec đều có trong oneStmt
Đặng Toàn Trí,1,11/7/2011,"oneDec,oneStmt có gì ??",O_$  wrote: mọi người liệt kê dùm mình oneDec và oneStmt có những gì? Có phải những thứ có trong oneDec đều có trong oneStmt Đặc tả đã nói kĩ vấn đề này
ngocquang45 ngocquang45,1,11/7/2011,"oneDec,oneStmt có gì ??","Mình làm: oneDec:varDec,constDec,procDec,funcDec. oneStmt:constDec,stmt không biết có đúng ý bạn không?"
Trần Văn Định,1,11/7/2011,"oneDec,oneStmt có gì ??","minh thi oneDec:varDec, constDec, procDec, funcDec onStmt: constDec, stmt, varDec"
V For,1,11/7/2011,"Re:oneDec,oneStmt có gì ??",me too !
.duc hoang,1,11/6/2011,access Array Element????,"Có vấn đề thề này-tớ đang thắc mắc: xTrong định nghĩa Expression thì toán tử [ ] truy cập array và định nghĩa: id [<expr> ,...,<expr> ] . Như vậy lúc viết testcase thì test-case sau ok không??? example[1,2,true,3.4] (vì <expr> có thể là const) nếu không chấp nhận thì các trong toán tử [ ] là gì??? chỉ integer ???."
Forever Alone,1,11/6/2011,Re:access Array Element????,Theo mình là được vì expression có chứa const mà const thì chứa tất ;))
Đỗ Sỹ Hưng,1,11/6/2011,Re:access Array Element????,Cho mình hỏi trường hợp này xuất ra cái gì: procedure main(); begin a := true[2]; end;
Sieutoc,1,11/6/2011,Re:access Array Element????,line 3:15: unexpected token: [
Đỗ Sỹ Hưng,1,11/6/2011,Re:access Array Element????,"Đỗ Sỹ Hưng  wrote: Cho mình hỏi trường hợp này xuất ra cái gì: procedure main(); begin a := true[2]; end; Theo tình hình mình hỏi mấy bạn thì có 2 kết quả cho trường hợp này: 1. Xuất ra error: ""["" 2. Xuất ra error: ""true"" Mấy bạn cho ý kiến nha, mình đã chỉnh code và cũng đã parse ra 2 trường hợp trên"
Nhất Tiếu nại Hà,1,11/7/2011,Re:access Array Element????,line 3:15: unexpected token: [
Phúc Trí,1,11/7/2011,Re:access Array Element????,Đỗ Sỹ Hưng  wrote: Cho mình hỏi trường hợp này xuất ra cái gì: procedure main(); begin a := true[2]; end; error cho dau [ do ban. true la keyword nen ko duoc coi la 1 bien
Phúc Trí,1,11/7/2011,Re:access Array Element????,procedure a(); begin a[]:=3; end; có parse ko nhỉ. đặc tả ko nói rõ trường hợp này.
.duc hoang,1,11/7/2011,Re:access Array Element????,"Scala ^^  wrote: bạn nào trả lời giúp mình với. trong cái a[i]:=x[i]; thì cái a[i] có phải là element of array không, và định dạng nó là ident [ expr, expr, ...] nếu cứ làm theo như đặc tả thì a[i] là element of array và x[i] cũng vậy, với định dạng như bạn đưa ra như trên. Nhưng tớ thấy ngồ ngộ là với định dạng như đặc tả thì expr có thể là const, mà const thì int, real, bool có tất vậy dẫn tới trường hợp a[1, 3.4, true] vẫn phải chấp nhận. mà chỉ số array làm gì có real, bool??? Nên tớ đang phân vân không biết mấy cái này phải ràng buộc từ stage2 này chưa???"
.duc hoang,1,11/7/2011,Re:access Array Element????,"Scala ^^  wrote: theo mình, ass1 này chỉ làm parse thôi k cần quan tâm tới cùng kiểu. như vậy cái element of array là ident [ list expr ], mình nghĩ cái này cả buổi, thấy rối quá, chắc sửa code lại tí đề không mô tả rõ ràng, nhưng lúc khai báo array thì size of array là toàn bộ các intLiteral, nên theo tớ ta làm [ list intLiteral ]. để từ h đên mai xem sao, nếu thấy hợp lý thì làm vậy, chứ nhiều cái không rõ ràng."
.duc hoang,1,11/7/2011,Re:access Array Element????,"Scala ^^  wrote: cậu khai báo kiểu thế, sao parse dc cái a[i]:=x[i] ( ví dụ trong đặc tả ) . càng đọc càng loạn, mà thầy thì k trả lời. uh ha, giờ sao ta???"
Phúc Trí,1,11/7/2011,Re:access Array Element????,".duc hoang wrote: Scala ^^  wrote: bạn nào trả lời giúp mình với. trong cái a[i]:=x[i]; thì cái a[i] có phải là element of array không, và định dạng nó là ident [ expr, expr, ...] nếu cứ làm theo như đặc tả thì a[i] là element of array và x[i] cũng vậy, với định dạng như bạn đưa ra như trên. Nhưng tớ thấy ngồ ngộ là với định dạng như đặc tả thì expr có thể là const, mà const thì int, real, bool có tất vậy dẫn tới trường hợp a[1, 3.4, true] vẫn phải chấp nhận. mà chỉ số array làm gì có real, bool??? Nên tớ đang phân vân không biết mấy cái này phải ràng buộc từ stage2 này chưa??? cái đó nằm ở bước kiểm tra kiểu, sẽ làm ở Ass2."
Hieu Bui,0,10/7/2011,Tạo ra file out put.txt.,Mình thấy Scala Console cũng có giới hạn độ dài xuất ra của kq (873 thì phải) nên chưa test đc nhiều testcase dài.Thầy và các bạn cho mình hỏi: có đoạn code nào có thể dùng để khi chạy thì Crazy xuất luôn ra 1 file output đc ko?
Phúc Trí,1,10/8/2011,Re:Tạo ra file out put.txt.,"bạn dùng thử đoạn code này đi,hàm main của file TestToken. /////////////////////////////////////////// def main(args: Array[String]): Unit = { val inputFile = ""input.txt"" val lines = Source.fromFile(inputFile).getLines val input = if (!lines.isEmpty) lines.reduceLeft[String](_ + '\n' + _) else """" val lexical = new CrazyLexical val scanner = new lexical.Scanner(input) var out_file = new java.io.FileOutputStream(""D:\\Ass1\\output.txt"")//nhap ten file, nho fai la 2 dau \\ nhe var out_stream = new java.io.PrintStream(out_file) //val output=""""; runAll(scanner) out_stream.println(""EOF"") def clean(token: lexical.Token): String = { val t = token.chars if (t.indexOf(""expected but"") != -1) { val from = t.indexOf(""but"") val to = t.indexOf(""found"") ""ErrorToken "" + t.subSequence(from + 4, to - 1).toString } else token.toString } def runAll(scan: lexical.Scanner): Any = if (scan.atEnd) println(scan.first) else { var output=clean(scan.first) println(output) out_stream.println(output) runAll(scan.rest) } } /////////////////////////////////////////////////////"
Forever Alone,1,9/27/2011,"Hỏi về các hàm NumericLit, Boolean, FloatLit, processIdent,..","Anh Hùng cho em hỏi là trong file Crazy2011.scala em có thấy các hàm NumericLit và processIdent được nối với các regex(""[a-z][a-zA-Z]*"".r) và regex(""0|[1-9][0-9]*"".r) thì em tạm hiểu là xử lí chuỗi và xử lí số nguyên. Vậy còn các hàm BooleanLit và FloatLit được định nghĩa phía trên thì sao ạ? Lúc em xử lí chuỗi ""true"",""false"" như sau regex(""true|false"".r) ^^ {Boolean(_)} thì khi chạy thì lại xuất ra màn hình ""identifier true"" và ""identifier false"". Cho em hỏi như vậy có đúng không ạ? Và mình có cần chỉnh sửa gì các hàm BooleanLit hay FloatLit ko? Em cám ơn."
hien pham ngoc,1,10/8/2011,Thắc mắc về delimiter,Theo như anh Hùng nói thì mình phải tự xác định đâu là token trong mấy cái delimiter. Vậy xác định bằng cách nào? Mình đã lục nát trên mạng mà cũng chẳng thấy nói về vấn này. Ai có biết thì chỉ giáo với :(
Bernkastel 奇跡の魔女,1,10/8/2011,Re:Thắc mắc về delimiter,"Delimiters là mấy dấu ; =  >= <> , : vâng vâng trong crazyspec có hết đó, ông vào coi thử, rồi thay cái đó vào trong list regex delimiters của scala là xong rồi (nhớ là dấu nháy đơn ' ko phải delimiter, thầy có ghi trong notice của box)"
hien pham ngoc,1,10/9/2011,Re:Thắc mắc về delimiter,"Câu hỏi: Dấu ' là 1 token hay không phải ( ErrorToken), vì sao trong đặc tả không thấy mà trong code mẫu lại có? Trả lời: 1. Việc xác định đâu là token các bạn phải tự làm lấy (trừ một số trường hợp nói rõ). 2. Code mẫu tất nhiên không hoàn toàn đúng (còn thiếu nhiều mới hoàn chình được và tất nhiên đôi lúc cũng có thừa một số dòng lệnh hay ký hiệu ""lạ"" nào đó). Bonus cho các em câu hỏi này: ' không phải là 1 token Thầy chỉ nói ' không phải là token chứ đâu có nói ' ko là delimiter :|"
Forever Alone,1,10/9/2011,Re:Thắc mắc về delimiter,Nếu mà ' là delimiters (được để trong list delimiters) thì khi chạy sẽ xuất ra `'' Mà anh Hùng đã nói là Vo Thanh Hung wrote: Dấu ' là 1 token hay không phải ( ErrorToken) Có nghĩa là nếu để trong delimiters tức là nó sẽ là token (không xuất ra ErrorToken) còn ngược lại thì xuất ra ErrorToken. Mình nghĩ vậy. Không biết các bạn khác nghĩ sao.
hien pham ngoc,1,10/9/2011,Re:Thắc mắc về delimiter,Dấu '
_Trung_Than_Thong,1,9/30/2011,Hỏi về số 0,Anh Hùng cho e hỏi về phần token 1. số 0 mà hiểu theo số thực thì có phải là 0.0 (tại đặc tả: followed by a non-empty sequence of digits that never ends with 0 unless it is 0 .) Nghĩa là nếu input là : var a = 0.0 thì kết quả thế nào? 2. Không hiểu sao khi em dùng scala interpreter thì trường hợp sau là đúng còn chạy vào file Crazy2011 thì lại sai: giả sử phần số thực đơn giản là: regex("[1-9]*\\.[1-9]*".r) ^^ { FloatLit(_) } thì khi thử với input: var x = 1.2 thì chỗ số thực nó lại báo: 1 .2 (không hiểu sao nó lại tự thêm thành kí hiệu xuống dòng)
Nguyễn Đức Huy,1,9/27/2011,"Re:Hỏi về các hàm NumericLit, Boolean, FloatLit, processIdent,..","Anh Hùng ơi, ko làm gì hàm BooleanLit nhưng vẫn phải viết regex để xử lý số thực chứ, phải không ạ?"
Tri,1,10/9/2011,"Re:Hỏi về các hàm NumericLit, Boolean, FloatLit, processIdent,..","Vo Thanh Hung wrote: Các em không cần làm gì đối với 2 hàm đó cả. Tuy nhiên, chú ý là true, false là 2 từ khóa vì vậy không được nhận dạng và xử lý riêng. (hàm BooleanLit sẽ không sử dụng) Vậy khi chạy nếu gặp true hoặc false thì mình xuất ra identifier true hay chỉ đơn thuần là true"
Quái,1,10/9/2011,"Re:Hỏi về các hàm NumericLit, Boolean, FloatLit, processIdent,..",BooleanLit sẽ không sử dụng)
Huỳnh Trọng Khiêm,1,10/9/2011,"Re:Hỏi về các hàm NumericLit, Boolean, FloatLit, processIdent,..","Administrator  wrote: Vo Thanh Hung wrote: Các em không cần làm gì đối với 2 hàm đó cả. Tuy nhiên, chú ý là true, false là 2 từ khóa vì vậy không được nhận dạng và xử lý riêng. (hàm BooleanLit sẽ không sử dụng) Vậy khi chạy nếu gặp true hoặc false thì mình xuất ra identifier true hay chỉ đơn thuần là true `true'"
Nhất Tiếu nại Hà,1,10/9/2011,"Re:Hỏi về các hàm NumericLit, Boolean, FloatLit, processIdent,..",cho mình hỏi có cần để delim liền dưới processIdent(_) không vậy? Vì test a=10; viết liền nhau thì không nhận dạng được :D
o0ozinkyo0o,1,10/4/2011,xin hỏi sol với số 0,cho mình hỏi kết quả của mấy cái này 0.0 = ??? .00e2 = ??? .0 = ??? 1.0 = ??? 1.00 = ???
Why So Serious,1,9/30/2011,Hỏi về số 0,_Trung_Than_Thong  wrote: Anh Hùng cho e hỏi về phần token 1. số 0 mà hiểu theo số thực thì có phải là 0.0 (tại đặc tả: followed by a non-empty sequence of digits that never ends with 0 unless it is 0 .) Nghĩa là nếu input là : var a = 0.0 thì kết quả thế nào? 2. Không hiểu sao khi em dùng scala interpreter thì trường hợp sau là đúng còn chạy vào file Crazy2011 thì lại sai: giả sử phần số thực đơn giản là: regex("[1-9]*\\.[1-9]*".r) ^^ { FloatLit(_) } thì khi thử với input: var x = 1.2 thì chỗ số thực nó lại báo: 1 .2 (không hiểu sao nó lại tự thêm thành kí hiệu xuống dòng) Chắc là do trong file Crazy2011 bạn để cái regex của NumericLit trước nên nó nhận số 1 là Numeric rồi mới đến .2 là Float
_Trung_Than_Thong,1,10/1/2011,Hỏi về số 0,Chắc là do trong file Crazy2011 bạn để cái regex của NumericLit trước nên nó nhận số 1 là Numeric rồi mới đến .2 là Float à lại lỗi này. Cảm ơn bạn
thanhnghi_py,1,10/6/2011,Re:Hỏi về số 0,"Nhân tiện đây cho mình hỏi, nếu viết 0.2, 0.2e-4, 0e3, 0.0e3 thì có phải là những số thực hợp lệ không? Về số nguyên (hay phần nguyên của số thực), viết -3, -3.4 có được không? Mong thầy và các bạn giải đáp giúp."
Phạm Nguyên Trình,1,10/6/2011,Re:Hỏi về số 0,"Trần Gia Lạc wrote: Nhân tiện đây cho mình hỏi, nếu viết 0.2, 0.2e-4, 0e3, 0.0e3 thì có phải là những số thực hợp lệ không? Theo mình thì hợp lệ Trần Gia Lạc wrote: Về số nguyên (hay phần nguyên của số thực), viết -3, -3.4 có được không? Mong thầy và các bạn giải đáp giúp. Đặc tả của đề ko có số âm => Crazy language không hiểu số âm là gì =))"
_Trung_Than_Thong,1,10/7/2011,Re:Hỏi về số 0,"Trần Gia Lạc wrote: Nhân tiện đây cho mình hỏi, nếu viết 0.2, 0.2e-4, 0e3, 0.0e3 thì có phải là những số thực hợp lệ không? Mong thầy và các bạn giải đáp giúp. ủa số 0e3 làm sao hợp lệ vì một số bắt đầu bằng 0 thì sao được? Mà không biết giá trị của nó bằng bao nhiêu vậy?"
_Trung_Than_Thong,1,10/7/2011,Re:Hỏi về số 0,"c. ronaldo wrote: An integer is a sequence of digits that always starts with a nonzero digit unless it is 0. Số 0 đó của phần nguyên đó Thì như vậy làm sao hợp lệ được? (ngĩa là chỉ chấp nhận số 0 (nếu số nguyên) hoặc 0.0 nếu số thực, còn ở đây là 0e3!"
Vu Dang,1,10/8/2011,Re:Hỏi về số 0,"c. ronaldo wrote: Except a fraction portion may appear alone, at least 2 parts must appear together at the same time Số này gồm 2 phần: integer và exponent. Số 0 thỏa điều kiện phần integer rồi. theo minh hieu thi integer khong co phan exponent => 0e3 sai"
Tin Bui,1,10/1/2011,hỏi về sol của vài case,"Cho em hỏi là sol của mấy case này cái nào mới đúng: 1/   015.34 ErrorToken 015 | .34 hay ErrorToken0 | 15.34 2/ 000.15 000.15 hay 0 | ErrorToken 00 | .15 3/ 0015.2 0| ErrorToken 015 |.2 hay ErrorToken 00 |15 .2 hay ErrorToken 0015 | .2 4/ 1.100e6 1.1 | ErrorToken 00 | e6 hay 1| ErrorToken .100 | e6 5/  1.2e001 1.2 | ErrorToken e001 hay 1.2e | ErrorToken 001 6/  0e2 ??? 7/ 00.000e4 ??? mấy dấu ""|"" nghĩa là xuống hàng mong moi góp ý cho cái solution này, nếu ko thống nhất là rất dễ sai"
Tuan Vu Quang,0,10/9/2011,Chả biết lỗi gì. có ai biết tại sao ko,Khi khai báo cái boolean regex ( "(true|false)".r ) ^^ { Boolean(_) } Thấy nó báo lỗi là: object Boolean does not take parameters Cho mình biết lỗi này là lỗi gì và cách sửa với
Tuan Vu Quang,0,10/9/2011,Chả biết lỗi gì. có ai biết tại sao ko,
vua doi bom,1,10/10/2011,Re:Chả biết lỗi gì. có ai biết tại sao ko,regex("true|false".r) ^^ {booleanLit(_)} nhưng 2 từ này là key word ma bạn. Nên không cần xài booleanLit dau.
Quái,1,10/4/2011,Re:xin hỏi sol với số 0,Theo mình là thế... 0.0 -> 0.0 .00e2 -> ErrorToken . 0 0e2 .0 -> ErrorToken . 0 1.0 ->1.0 1.00 -> 1.0 0
walk alone,1,10/4/2011,Re:xin hỏi sol với số 0,0.0 .0 | 0e2 .0 1.0 1.0 |0
Bruce Wayne,1,10/4/2011,Re:xin hỏi sol với số 0,walk alone wrote: 0.0 .0 | 0e2 .0 1.0 1.0 |0 The same :D
FirstName LastName,1,10/5/2011,Re:xin hỏi sol với số 0,test wrote: 0.0 .00e2 .0 1.0 1.00 result wrote: 0.0 .0 0e2 .0 1.0 1.0 0 EOF :D
.                                . Kazumi              ..,1,10/6/2011,Re:xin hỏi sol với số 0,"c. ronaldo wrote: cho mình hỏi 2 TH 00.12 và .00e2 làm sao tách ra dc 0 | 0.12 và 0 | 0e2, mình làm còn vướng 2 TH này, nhưng giải quyết chưa được. mình làm ra 0 | 0 |.12 :(( Cái này là do độ ưu tiên. Nó dịch từ trên xuống dưới , từ trái qua phải( trừ vài ngoại lệ ko bít) Bạn cho định nghĩa số thực lên trên số nguyên là oK."
Vinh Thọt,1,10/9/2011,Re:xin hỏi sol với số 0,Theo bần đạo nghĩ thì Th: 1.0 -----------KQ: 1 ErrorToken . 0 EOF --------------- "That never ends with 0 unless it is 0" => 1.0 không được
Nhất Tiếu nại Hà,1,10/9/2011,Re:xin hỏi sol với số 0,Trương Tam Phong  wrote: Theo bần đạo nghĩ thì Th: 1.0 -----------KQ: 1 ErrorToken . 0 EOF --------------- "That never ends with 0 unless it is 0" => 1.0 không được 1.0 thì kết quả là 1.0 EOF vì sau dấu chấm là 0 mà....nếu là 1.00 thì nó sẽ là 1.0 0 EOF
Forever Alone,1,10/1/2011,hỏi về sol của vài case,axe  wrote: Cho em hỏi là sol của mấy case này đúng không: 1/   015.34 0 | ErrorToken 15 | .34 hay ErrorToken 015 | .34 2/ 000.15 000.15 hay 0 | ErrorToken 00 | .15 3/ 0015.2 0| ErrorToken 015 |.2 hay 00 | ErrorToken 15 | .2 hay ErrorToken 0015 | .2 4/ 1.100e6 1.1 | ErrorToken 00 | e6 hay 1| ErrorToken .100 | e6 5/  1.2e001 1.2 | ErrorToken e001 hay 1.2e | ErrorToken 001 6/  0e2 ??? 7/ 00.000e4 ??? Ủa 0e2 hợp lệ mà bạn
Tin Bui,1,10/1/2011,Re:hỏi về sol của vài case,"^Thì mình ko chắc lắm nên mới ghi ??? đấy, còn mấy cái trên thì ko biết cái nào mới đúng ^ ^"
walk alone,1,10/1/2011,Re:hỏi về sol của vài case,theo mình nghĩ : 1/ 0 | 15.34 2/ 0 |0| 0.15 3/0| 0| 15.2 4/1.1 |0 | 0e6 mấy cái khác thì ko chắc lắm :-?
librastar,1,10/1/2011,hỏi về sol của vài case,"axe  wrote: Cho em hỏi là sol của mấy case này cái nào mới đúng: 1/   015.34 0 | ErrorToken 15 | .34 hay ErrorToken 015 | .34 hay ErrorToken0 | 15.34 2/ 000.15 000.15 hay 0 | ErrorToken 00 | .15 3/ 0015.2 0| ErrorToken 015 |.2 hay ErrorToken 00 |15 .2 hay ErrorToken 0015 | .2 4/ 1.100e6 1.1 | ErrorToken 00 | e6 hay 1| ErrorToken .100 | e6 5/  1.2e001 1.2 | ErrorToken e001 hay 1.2e | ErrorToken 001 6/  0e2 ??? 7/ 00.000e4 ??? mấy dấu ""|"" nghĩa là xuống hàng mong moi góp ý cho cái solution này, nếu ko thống nhất là rất dễ sai Kết quả của mình: 1/ 0 |15.34 2/ 0 |0 |0.15 3/ 0 |0 |15.2 4/ 1.1 |0 |0e6 5/ 1.2 |identifier e001 | 6/ 0e2 7/ 0 |0.0 |0 |0e4"
Tin Bui,1,10/1/2011,Re:hỏi về sol của vài case,walk alone wrote: theo mình nghĩ : 1/ 0 | 15.34 2/ 0 |0| 0.15 3/0| 0| 15.2 4/1.1 |0 | 0e6 mấy cái khác thì ko chắc lắm :-? Nếu phân như thế thì khúc nào ErrorToken thế bạn?? :d
librastar,1,10/1/2011,hỏi về sol của vài case,deleted.
librastar,1,10/1/2011,Re:hỏi về sol của vài case,axe  wrote: walk alone wrote: theo mình nghĩ : 1/ 0 | 15.34 2/0 |0| 0.15 3/0| 0| 15.2 4/1.1 |0 | 0e6 mấy cái khác thì ko chắc lắm :-? Nếu phân như thế thì khúc nào ErrorToken thế bạn?? :d Không có ErrorToken ở đây. Vì các trường hợp trên ko có trường hợp nào tồn tại 1 lexical mà parser ko hiểu.
Bruce Wayne,1,10/1/2011,hỏi về sol của vài case,"librastar  wrote: axe  wrote: Cho em hỏi là sol của mấy case này cái nào mới đúng: 1/   015.34 0 | ErrorToken 15 | .34 hay ErrorToken 015 | .34 hay ErrorToken0 | 15.34 2/ 000.15 000.15 hay 0 | ErrorToken 00 | .15 3/ 0015.2 0| ErrorToken 015 |.2 hay ErrorToken 00 |15 .2 hay ErrorToken 0015 | .2 4/ 1.100e6 1.1 | ErrorToken 00 | e6 hay 1| ErrorToken .100 | e6 5/  1.2e001 1.2 | ErrorToken e001 hay 1.2e | ErrorToken 001 6/  0e2 ??? 7/ 00.000e4 ??? mấy dấu ""|"" nghĩa là xuống hàng mong moi góp ý cho cái solution này, nếu ko thống nhất là rất dễ sai Kết quả của mình: 1/ 0 |15.34 2/ 0 |0 |0.15 3/ 0 |0 |15.2 4/ 1.1 |0 |0e6 5/ 1.2 |identifier e001 | 6/ 0e2 7/ 0 |0.0 |0 |0e4 Mình giống bạn này"
Lê Quốc Nam,1,10/1/2011,Diff trên ubuntu,"Cũng gần đến lúc nộp bài giai đoạn 1 rồi nên mình test thử bài trên ubuntu, dịch và chạy như hướng dẫn của anh Hùng, và cho xuất kết quả ra file output.txt. Khổ cái, mình check rất nhiều lần bằng lệnh diff output.txt test1.tokens thì bao giờ nó cũng trả về kết quả 2 file khác nhau từ đầu đến cuối, mặc dù check bằng mắt thường thì giống nhau hoàn toàn. Có bạn nào bị giống mình không ..."
Quy Vuong,1,10/11/2011,Re:Diff trên ubuntu,"Mình cũng chạy bằng Eclipse trên Ubuntu, khác nhau ở chỗ: xuống dòng trên sol của thầy là \r\n, còn mình không có. Không biết có sao không. Ah, anh cho em hỏi lệnh biên dịch trên Terminal là gì thế, em chạy bằng lệnhscalac -g TestToken.scala thì nó báo lỗi: TestToken.scala:35: error: block must end in result expression, not in definition } ^ one error found Trong khi chạy trên eclipse bình thường."
Tri,1,10/11/2011,Nhờ anh HÙng chỉ giúp,"Mình đã làm bài trên eclipse và build/chạy bình thườngnhưng khi copy thư mục assignment sang Ubuntu để deploy bằng lệnh scalac *.scala thì bị báo lỗi sau: Crazy2011.scala:148: error: empty character literal if ((x.last == y) && (y.equals('''))) x else if (y.equals('""')) x + ""\""\"""" else x + y ^ Crazy2011.scala:148: error: missing terminating quote if ((x.last == y) && (y.equals('''))) x else if (y.equals('""')) x + ""\""\"""" else x + y ^ Crazy2011.scala:149: error: ')' expected but '}' found. } ^ TestToken.scala:34: error: block must end in result expression, not in definition } ^ four errors found Mặc dù đã test với thư mục hoàn toàn mới download từ modules vẫn bị tình trạng trên. Mong anh Hùng hoặc bạn nào đã có kinh nghiệm với chuyện này chỉ giúp mình với."
aa a,0,10/6/2011,bị lỗi khi chạy,khi mình chạy file TestToken thì nó báo có lỗi <console>:8: error: not found: value runAll runAll(scanner) ^ không biết đó là lỗi gì? ai biết trả lời giúp
aa a,0,10/8/2011,Re:bị lỗi khi chạy,cho hỏi khi mình nhập 2.1 thì xuất hiện là 2 ErrorToken . 1 EOF thế nó có bị lỗi không cáiErrorToken . là cái gì
aa a,0,10/8/2011,Re:bị lỗi khi chạy,"vậy khi mình nhập 2.1 thì nó xuất ra là 2 .1 EOF đúng không ,nhưng sao khi mình nhập 2.10 thì nó xuất là 2 .1 0 EOF"
Tin Bui,1,10/1/2011,Re:hỏi về sol của vài case,"librastar  wrote: axe  wrote: walk alone wrote: theo mình nghĩ : 1/ 0 | 15.34 2/0 |0| 0.15 3/0| 0| 15.2 4/1.1 |0 | 0e6 mấy cái khác thì ko chắc lắm :-? Nếu phân như thế thì khúc nào ErrorToken thế bạn?? :d Không có ErrorToken ở đây. Vì các trường hợp trên ko có trường hợp nào tồn tại 1 lexical mà parser ko hiểu. Có vẻ mình hiểu sai đề ngay từ đầu rồi, hix, vậy bạn nào có thể cho mình vài ví dụ về số mà có thể ra trường hợp ErrorToken với :p"
walk alone,1,10/1/2011,Re:hỏi về sol của vài case,"error token xảy ra khi nó ko so trùng với bất kfi định nghĩa nào thôi. Ví dụ như bạn cho chữ in hoa ở đầu vào, nó sẽ báo eror token."
walk alone,1,10/1/2011,hỏi về sol của vài case,"librastar  wrote: axe  wrote: Cho em hỏi là sol của mấy case này cái nào mới đúng: 1/   015.34 0 | ErrorToken 15 | .34 hay ErrorToken 015 | .34 hay ErrorToken0 | 15.34 2/ 000.15 000.15 hay 0 | ErrorToken 00 | .15 3/ 0015.2 0| ErrorToken 015 |.2 hay ErrorToken 00 |15 .2 hay ErrorToken 0015 | .2 4/ 1.100e6 1.1 | ErrorToken 00 | e6 hay 1| ErrorToken .100 | e6 5/  1.2e001 1.2 | ErrorToken e001 hay 1.2e | ErrorToken 001 6/  0e2 ??? 7/ 00.000e4 ??? mấy dấu ""|"" nghĩa là xuống hàng mong moi góp ý cho cái solution này, nếu ko thống nhất là rất dễ sai Kết quả của mình: 1/ 0 |15.34 2/ 0 |0 |0.15 3/ 0 |0 |15.2 4/ 1.1 |0 |0e6 5/ 1.2 |identifier e001 | 6/ 0e2 7/ 0 |0.0 |0 |0e4 trùng kết quả với bạn này :-?"
Bruce Wayne,1,10/3/2011,Re:hỏi về sol của vài case,"Cho mình hỏi nếu input là: //comment thì output là: '/' '/' identifier comment Còn nữa, input: /*comment*/ ouput là: '/' '*' identifier comment '*' '/' Như vậy có đúng ko"
nguyen dung,1,10/3/2011,Re:hỏi về sol của vài case,"Comment thì nó bỏ qua không có báo, thầy có code sẵn trong đó rồi, có bạn nào biết trường hợp nào xảy ra failure(""unclosed comment"")) không (trong def whitespace )."
Vinh Thọt,1,10/9/2011,Re:hỏi về sol của vài case,Mấy bạn theo đặc tả thì hình như: 0.15 ------KQ: 0 .15 EOF ---------- Ko chấp nhận 0.15 phải không ? nếu chỉ có số 0 ở trước dấu chấm thì bỏ số 0 đó đi chỉ có dấu chấm thôi?
Nhất Tiếu nại Hà,1,10/9/2011,Re:hỏi về sol của vài case,Trương Tam Phong  wrote: Mấy bạn theo đặc tả thì hình như: 0.15 ------KQ: 0 .15 EOF ---------- Ko chấp nhận 0.15 phải không ? nếu chỉ có số 0 ở trước dấu chấm thì bỏ số 0 đó đi chỉ có dấu chấm thôi? cứ theo đặt tả mà làm bạn: The integer portion is similar to an integer constant. KQ: 0.15 EOF
Quái,1,10/11/2011,Re:Nhờ anh HÙng chỉ giúp,deleted
Ngan Tuyet,1,10/11/2011,Re:Nhờ anh HÙng chỉ giúp,"Mình đã gặp lỗi này, do ubuntu cài phiên bản cũ scala. Bạn update scala lên 2.9.1 mới nhất là ok."
Tri,1,10/11/2011,Re:Nhờ anh HÙng chỉ giúp,"Ngan Tuyet wrote: Mình đã gặp lỗi này, do ubuntu cài phiên bản cũ scala. Bạn update scala lên 2.9.1 mới nhất là ok. Thank bạn nhé :)"
aa a,0,10/8/2011,Re:bị lỗi khi chạy,vậy khi mình nhập 2.0000 thì nó cũng xuất ra 2.0000 EOF phải không
Tuan Vu Quang,0,10/11/2011,bị lỗi khi chạy,Sao nhập 2.1 lại ra 2..1 vậy _HNA_ Mình tưởng ra 2.1 thôi chứ nhỉ
vanhoa,1,10/4/2011,Testcase,Các bạn thử test này nhé :) http://www.vhn.vn/u/tes.zip
Forever Alone,1,10/4/2011,Re:Testcase,"Trong result của bạn có dòng ErrorToken ' Trong cái list delimiters có dấu ' mà bạn, sao lại báo cái đó là ErrorToken nhỉ ?"
vanhoa,1,10/4/2011,Re:Testcase,"Cai do dau co trong file dac ta, sao ' lai la delimiter dc"
Forever Alone,1,10/4/2011,Re:Testcase,Nhưng trong code mẫu down về thì có. Không biết thực hư ra sao nữa. Thôi thì đành chờ anh Hùng vô giải quyết vậy :D
Quái,1,10/4/2011,Re:Testcase,Trong đặc tả ko có dấu ' nhưng trong file khởi tạo của thầy lại có dấu '   ....
Forever Alone,1,10/4/2011,Testcase,"vanhoa  wrote: Các bạn thử test này nhé :) http://www.vhn.vn/u/tes.zip Sau khi test xong test9.my.txt thì có 1 số chỗ mình khác với Văn Hòa sau đây : 1/ true và false là 1 keyword nên sẽ xuất ra là`true' hay`false' (cái này có ở tbên trang 1 dòng thứ 3 từ dưới lên) 2/0.01 vẫn là một kiểu real hợp lệ nên sẽ ra là Code: 0.01 chứ ko fải là 0.0 1 tương tự với 1.01,v..v.v 3/Chắc Hòa chưa đọc Notice nên chưa biết là ví dụ .3e-30 trong ví dụ là ví dụ đúng. Vì vậy .0e-10 , .0e10 đều là hợp lệ (kiểu real). Mình ra là .0e-10 .0e10 còn Hòa ra là .0 identifier e10 Mà hình như test của Hòa chỉ ra tới varConst1974 thôi thì phải :-?Không biết có bạn nào ra giống mình không ?"
vanhoa,1,10/4/2011,Re:Testcase,"Uh mình quên xét độ ưu tiên, bạn tải lại kiểm tra nhé."
tuong vo,1,10/4/2011,Re:Testcase,cho minh hoi 1.2e-0 sẽ ra như thế này 1.2 identifier e `-' 0 EOF
Forever Alone,1,10/4/2011,Re:Testcase,"vanhoa  wrote: Uh mình quên xét độ ưu tiên, bạn tải lại kiểm tra nhé. OK đã test. Same :). Chỉ còn thắc mắc mỗi cái dấu ' . Anh Hùng ơi vô trả lời tụi em với."
Phúc Trí,1,10/4/2011,Re:Testcase,cứ làm như fileđặc tả. chắc lúc code a Hùng kođểý thôi.
vanhoa,1,10/4/2011,Re:Testcase," là delimiter, đã edit lại testcase, các bạn kiểm tra nhé."
Bruce Wayne,1,10/4/2011,Re:Testcase,"vanhoa  wrote: ' là delimiter, đã edit lại testcase, các bạn kiểm tra nhé. Trong phần notice anh Hùng đã nói ' không phải là 1 token , sao nó lại là delimiter dc bạn"
Tin Bui,1,10/4/2011,Re:Testcase,
vanhoa,1,10/4/2011,Re:Testcase,"@axe: Bạn tải bản cũ rồi, tải lại bản mới đi. @Lost: http://en.wikipedia.org/wiki/Delimiter"
Bruce Wayne,1,10/4/2011,Re:Testcase,Vậy theo bạn delimiter có phải là token ko
vanhoa,1,10/4/2011,Re:Testcase,Theo như mình đọc thì delimiters có 2 loại: token và non-token
thanh tam,1,10/5/2011,Re:Testcase,Vậy cuối cùng là mình làm theo thầy hay sao bạn? Có nên bỏ ' vô delimiters không vậy bạn?
Nhat Nguyen,1,10/5/2011,Re:Testcase,"Theo mình thì ' sẽ không đưa vô delimiter, vì theo Crazy language thì không có"
Forever Alone,1,10/5/2011,Re:Testcase,Nếu mà ' là delimiters (được để trong list delimiters) thì khi chạy sẽ xuất ra `'' Mà anh Hùng đã nói là Vo Thanh Hung wrote: Dấu ' là 1 token hay không phải ( ErrorToken) Có nghĩa là nếu để trong delimiters tức là nó sẽ là token (không xuất ra ErrorToken) còn ngược lại thì xuất ra ErrorToken. Mình nghĩ vậy. Không biết các bạn khác nghĩ sao.
LAV,1,10/5/2011,Re:Testcase,testsol của bạn Hòa thiếu ký hiệu EOF!
LAV,1,10/5/2011,Re:Testcase,mình nghĩ single quote ' là non-token delimiter!
Tin Bui,1,10/6/2011,Re:Testcase,Thầy khẳng định ' ko phải Token => nếu ra ' ' ' (3 dấu nháy đơn liền nhau ) thì sol ra " ' ' " ErrorToken ' phải ko ? trong cái sol của bạn vanhoa ra: " ' ' " ' ' ' ??? :p
Huỳnh Tiến Tài,1,10/8/2011,Re:Testcase,"Mình thử test của Hòa rồi, hình như là trùng nhau. Nhưng không hiểu sao test nào Hòa đưa cũng không EOF :| Chẳng hiểu sao nữa!"
Tuan Vu Quang,0,10/12/2011,Vài câu hỏi nhỏ,"Mình có vài câu hỏi nhỏ muốn hỏi mọi người 1, Trong override def token mình chỉ cần hiện thực FloatLit,NumericLit,processIdent,StringLit thôi, còn mảng thì ko cần đúng ko. 2, Thế còn The separators are comma (,), colon (:) and semicolon (;). The operators are ( ) [ ] + - * / > < <= >= <> = := ^ hiện thực ở đâu vậy 3, Cáidelimiters ko có kí tự ' 4, Ở đầu file ghi // Project name Crazy // Create by: Tên SV // MSSV Có vài câu hỏi tổng hợp lại từ mấy cái thread kia, Mong được mọi người giải đáp"
Quái,1,10/12/2011,Vài câu hỏi nhỏ,"Tuan Vu Quang wrote: Mình có vài câu hỏi nhỏ muốn hỏi mọi người 1, Trong override def token mình chỉ cần hiện thực FloatLit,NumericLit,processIdent,StringLit thôi, còn mảng thì ko cần đúng ko. mình làm như vậy. 2, Thế còn The separators are comma (,), colon (:) and semicolon (;). The operators are ( ) [ ] + - * / > < <= >= <> = := ^ hiện thực ở đâu vậy delimiters. 3, Cáidelimiters ko có kí tự ' Thầy đã trả lời... 4, Ở đầu file ghi // Project name Crazy // Create by: Tên SV // MSSV Thứ hai thầy có dặn như thế..."
Tuan Vu Quang,0,10/12/2011,Vài câu hỏi nhỏ,Cái câu hỏi 2: nếu in: const a = b ^ c; thì out: `const' identifier a `=' identifier b `^' identifier c `;' EOF
Tuan Vu Quang,0,10/12/2011,Vài câu hỏi nhỏ,Mấy trường hợp ko hợp lệ của số thực ví dụ 1.e-2 thì bạn ra như nào Như của mình nó  hiện mỗi số 1 rồi cứ chạy hoài ko dừng
Phạm Nguyên Trình,1,10/12/2011,Re:Vài câu hỏi nhỏ,_HNA_  wrote: 1 ErrorToken . identifier e `-' 2 EOF mình ra vậy Me too
Tuan Vu Quang,0,10/12/2011,Vài câu hỏi nhỏ,Mình cũng nghĩ ra như 2 bạn. Mà chả hiểu sao nó cứ chạy hoài ko dừng
Long Nguyễn,1,10/10/2011,Re:Testcase,' không phải là token nên phải ra ErrorToken ' chứ nhỉ.

