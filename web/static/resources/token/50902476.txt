Mong anh Hùng phổ_biến rõ hơn về vấn_đề Function_Not_Return_Ngôn ngữ Crazy có tính kiểu short - circuit không thầy ? Với x là biến thì biểu_thức ( true or x ) được xem là true luôn hay vẫn phải xét tiếp x ? Re : File PT vẫn chưa tương_thích Các bạn thử lấy file PT mới test cái này ( của " nhan " bên topic kia ) : function main ( ) : string ; begin return ' a ' ; end ; sẽ được cây sinh_ra : Program ( List ( Func ( main , List ( ) , PrimitiveType ( string ) , Block ( List ( Return ( UnaryOp ( string , StringLit ( " ' a ' " ) ) ) ) ) ) ) ) = ) ) Scope của biến global ? ? ? H . T . P ( ^ _ ^ ) wrote : các bạn cho mình hỏi biến global có tầm vực như_thế_nào ? Tương_tự , 1 hàm cóđược sử_dụng dụng phía trướcđịnh nghĩa hàmđó không ? - The scope of a global variable : the entire program = > Biến global có tầm vực toàn chương_trình : ) - The scope of a function / procedure : the entire program . Một hàm dùng được trong tầm vực ( scope ) của nó = > ... - Có xét thêm : the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block . Scope của biến global ? ? ? @ H . T . P ( ^ _ ^ ) : hai ví_dụ của bạn mình chưa chạy thử được nhưng xét về scope của biến và hàm thôi_thì đều không có lỗi . Giải_thích thì như bạn chicken _ đã nói : " 1 hàm được dùng trong scope của nó . Chứ không có nói là phải khai_báo trươc hay ko . " Rõ hơn là không cần phải khai_báo trước theo thứ_tự từ trên xuống trong file source . @ tran ngoc duc : bạn có_thể giữ nguyên code mẫu , hoặc chỉnh_sửa code mẫu miễn_là thỏa được đặc_tả . Re : Scope của biến global ? ? ? chicken _ wrote : Tóm_lại là báo lỗi hay không . Mỗi người một ý vây . * Báo lỗi : Đã làm được . * Không báo lỗi : Sẽ phải sửa lại nhiều . Cái này còn liên_quan tới nhiều vấn_đề khác nữa = > Sửa lại hàm tìm_kiếm . Không báo lỗi ; ) ) Re : GradeBook Mid_Term_Tân_Trần_Vĩnh wrote : Và như thông_báo mới , chúng_tôi sẽ chấm chặt tay , trước mặt các em , với những bài được thắc_mắc . Mong thầy công_bố chi_tiết cách tính điểm . Ví_dụ : trong một câu sai ý này , đúng ý kia thì được bao_nhiêu ; đúng nhưng chưa đủ thì được bao_nhiêu ; chữ xấu có trừ điểm không ; một câu đúng ý nhưng trình_bày khó hiểu thì thế_nào ; ... Như_vậy sinh_viên dễ_dàng hơn để xác_định bài của mình có bị nhầm_lẫn gì khi chấm không . Đây là bài thi tự luận nên ít_nhiều sẽ có yếu_tố chủ_quan của người chấm ( có năm người chấm ) và khả_năng diễn_đạt của người_làm . Theo em , nếu quyết_định chấm gắt hơn ở những bài xin chấm lại thì cũng_nên có bonus cho những bài xin chấm lại mà chính_xác . Re : Các bạn cho mình hỏi về cái def Show tý nhé ! Với trong đề yêu_cầu xuất line <blank> <line> : <column> : <blank> unexpected token : <blank> <token> nhưng trong ví_dụ lại có trường_hợp xuất <eof> mà <eof> đâu phải token . Trong_Stage 1 đã làm , EOF mới là token ! Danh_sách cấm thi và quy_định 5 con 0 . Em nhớ có lần thầy cho làm bài trong giờ lý_thuyết và có nói thêm là để thầy xem các em tiếp_thu được đến đâu để điều_chỉnh việc giảng_dạy cho phù_hợp . Lần đó em lên bảng làm_nên lúc xuống không nộp lại giấy ( không kịp làm vô giấy ) . Thầy cho em hỏi em có bị tính là vắng buổi đó không ạ ? Mã_số sinh_viên của em là 50902476 . Em cảm_ơn ạ . Điểm_Course _ Grade_Mình tưởng điểm trong course _ grade là đã làm_tròn 0.5 rồi . Thầy kiểm_tra giúp em với . Em tự tính được 9.1 ( 9.125 ) nhưng trong course _ grade chỉ ghi 9 . Nếu đó là điểm đã làm_tròn 0.5 thì_sao điểm của bạn Việt lại là 7.2 mà không phải là 7.0 hoặc 7.5 ạ ? Tên : Phạm_Minh_Thành MSSV : 50902476File kết_quả Assignment 2 Thưa thầy , Trong_Gradebook đã có điểm Assignment 2 nhưng trong mục Assignment vẫn chưa có file chấm bài . Mong thầy upload file chấm bài Assignment 2 trước khi nộp điểm tới phòng đào_tạo . Em cảm_ơn . File kết_quả Assignment 2 Thầy cho em hỏi bài của em được bao_nhiêu test bắt_buộc và bao_nhiêu test bonus ạ ? Em cảm_ơn ! Tên : Phạm_Minh_Thành MSSV : 50902476Re : tut1 Tương_tự cho mình hỏi , câu 5 . a : ( ab ) * ( ba ) * | aa * thì nghĩa_là ( ( ab ) * ( ba ) * ) | aa * hay ( ab ) * ( ( ba ) * | aa * ) Re : tut1 Nhat_Nguyen wrote : Thanh_Pham_Minh wrote : Tương_tự cho mình hỏi , câu 5 . a : ( ab ) * ( ba ) * | aa * thì nghĩa_là ( ( ab ) * ( ba ) * ) | aa * hay ( ab ) * ( ( ba ) * | aa * ) theo mình nghĩ nó là ( ab ) * ( ( ba ) * | a ) a * Oh , cảm_ơn bạn nhiều nhé . Mấy khoảng trắng dễ gây nhầm_lẫn quá ! tut1 Bài giảng không nói_gì về thứ_tự ưu_tiên cả . Giả_sử thứ_tự ưu_tiên là Kleene_Star > Union > Concatenation thì rõ_ràng cách hiểu của bạn Nhat_Nguyen ( ab ) * ( ( ba ) * | a ) a * là chính_xác . Còn nếu Kleene_Star > Concatenation > Union thì kết_quả là ( ( ab ) * ( ba ) * ) | ( aa * ) . Nhưng thứ_tự ưu_tiên này có_vẻ không hợp_lý như thứ_tự ở trên . Re : Lab 2 Ngan_Tuyet wrote : Đúng rùi đó . Hình_như cái solution câu 1a của thầy có j nhầm_lẫn . Mong thầy giải_đáp Mình thì làm thế_này : " ( / \ \ * ( [ ^ \ \ * ] | ( \ \ * ) + [ ^ / ] ) * \ \ * * \ \ * / ) " Cách của bạn có xót một trường_hợp : val comment 1 = new Regex ( " ( / \ \ * ( [ ^ \ \ * ] | ( \ \ * ) + [ ^ / ] ) * \ \ * * \ \ * / ) " ) comment1.findAllIn ( " / * * * * * 1st comment . * * * * / code1 ( ) ; / * * 2nd comment * / code2 ( ) ; " ) . toList Kết_quả : List [ String ] = List ( / * * * * * 1st comment . * * * * / code1 ( ) ; / * * 2nd comment * / ) Lẽ_ra kết_quả phải là : List [ String ] = List ( / * * * * * 1st comment . * * * * / , / * * 2nd comment * / ) Mình nghĩ đáp_án này chính_xác hơn : ) val comment = new Regex ( " " " / \ * ( [ ^ * ] | ( \ * + [ ^ * / ] ) ) * \ * + / " " " ) Ý_kiến về câu 2 kì thi giữa kì ... Rec4rx wrote : Thưa thầy , em có chút ý_kiến về câu số 2 đề thì giữa kì như sau . Theo em được biết thì , một văn_phạm được coi là nhập_nhằng khi tồn_tại một phát_biểu mà theo phát_biểu đó tồn_tại hai hoặc nhiều hơn hai cây cú_pháp . Vậy điều_kiện đầu_tiên để một văn_phạm có_thể coi là nhập_nhằng phải là " tồn_tại một phát_biểu " ... Nhưng theo như văn_phạm trong câu 2 đề thi , thì rõ_ràng chẳng tồn_tại một phát_biểu nào cho văn_phạm đó hết , vậy nên việc chứng_minh văn_phạm đó nhập_nhằng là không_thể . . Ý_kiến của em là vậy , mong thầy góp_ý nếu em hiểu sai gì đó . Cám_ơn thầy . Đồng_ý với ý_kiến của bạn : D_Đề thi nên rõ_ràng , chặt_chẽ chứ không nên có những chỗ " tự hiểu là phải bỏ_qua " . Tut 3 Thưa thầy , Question 4 , Tut 3 yêu_cầu chuyển_đổi giữa số_thập_phân và chuỗi nhị_phân theo chuẩn IEEE 754 . Tuy_nhiên em không tìm thấy tài_liệu nào về biểu_diễn số với 9 bits theo chuẩn trên cả . Mong thầy nói rõ hơn : Với một_số 1.abc * 2 ^ d Phần exponent 3 bit lưu d hay d + bias . Nếu là d + bias thì bias là 3 phải không ạ ? Phần value 5 bit cuối lưu value hay fraction : 1.abc hay_là abc ? Em cảm_ơn . Re : Tut 3 Cảm_ơn bạn Long_Hoang_Ngoc . Ý mình là tài_liệu nói về chuẩn IEEE 754 với 9 bits . Có hai khả_năng : Một là IEEE 754 chỉ quy_định các dạng : binary16 , binary32 , binary64 , binary128 , decimal32 , decimal64 , decimal128 . Nếu_vậy không có chuẩn 9bits ở đây . Hai là IEEE 754 quy_định luật chung và từ đó chỉ rõ phương_pháp tính ra cách biểu_diễn được cho mọi số_lượng bit cần_thiết . Nếu_vậy tại_sao những tài_liệu ( mình tìm được và cả của bạn ) không nói về cách tính đó ? Tại_sao bias bằng 3 : ) Mình không thấy có tài_liệu nào nói bias = 2 ^ ExponentBitsCount - 1 - 1 . Mình thì đoán mò dựa trên hai dạng chuẩn binary 32 , binary64 . Thậm_chí chuẩn còn quy_định số bit dành cho phần exponent là [ 4 * log2 ( k ) ] - 13 . Nếu thay k = 9 thì exponent bằng 3 ? Chính vì không tìm thấy tài_liệu nên mình nghi_ngờ về bias và chữ " value " ( chiếm 5 bits cuối ) . Nếu đã theo chuẩn thì_phải triệt_để , nếu_không , phải đặc_tả rõ ! Re : Testcase cho stage 2 / / hỏi nhầm , đã xóa Re : Testcase cho stage 2 Nếu đọc kỹ đặc_tả sẽ thấy array Literal chỉ yêu_cầu là có các phần_tử của chính nó cùng kiểu ( integer , real , boolean hoặc array ) chứ không yêu_cầu xét một_cách đệ quy . Nghĩa_là : const b = [ true ; false ] ; [ 1 ; 2 ; 3 ] ; [ 1 ; 2 ; 3 ; 4 ] ; [ [ 1 ] ; [ 2 ; 3 ] ] ] ; sẽ parse thành_công vì đối_với array mẹ ( array ngoài cùng ) các phần_tử của chính nó có cùng kiểu array ( array luôn là array không cần phân_biệt số chiều , kiểu , mức_độ lồng nhau ) . Tương_tự , array con_thứ nhất , thứ_hai , thứ_ba lần_lượt có các phần_tử cùng kiểu boolean , integer , integer . array con thứ_tư có các phần_tử là các array . Nhưng : const c = [ 1 ; 2 ; [ 3 ; 4 ] ] ; sẽ không parse thành_công vì có phần_tử thứ nhất và thứ_hai kiểu integer nhưng phần_tử thứ_ba có kiểu array . Tương_tự : const d = [ true ; 1 ] ; cũng không parse thành_công . Có gì sai thầy và các bạn sửa giúp Re : Testcase cho stage 2 Ờ , thank ông đã nhắc . Nhưng nếu muốn kiểm_tra ở mức_độ tui đã nói thì cũng làm được mà : ) Chưa có thống_nhất ! Phần array Literal thì nói phần_tử của mảng có_thể là array , không_thể là string . Nhưng phần array Type thì ngược_lại : không_thể declare một array có phần_tử là array vì sau " of " chỉ có_thể là primitive type . Primitive type có bao_gồm string nên trong phần này array có_thể có kiểu phần_tử là string . Dù_sao đây cũng là Crazy_Language nên . . thôi : ) ) Re : Testcase cho stage 2 @ Scala ^ ^ : rep1sepRe : Testcase @ chicken _ : Test này bạn ra_gì : const b = [ [ [ 1.0 ; 2.0 ] ] ; [ [ 1 ; 2 ] ] ] ; Re : Testcase_Thêm một test về Not_Defined_Before_Used : ) var u : integer ; var v : integer ; procedure main ( ) ; begin var x , y : integer ; while ( u > 0 ) do begin var u : integer ; while ( 1 > 0 ) do begin u : = 1 ; y : = 2 ; if ( 0 > 1 ) then continue ; x : = 1 ; y : = x ; v : = 2 ; end / / x : = y ; y : = x ; end u : = u ; v : = v ; end ; Output : / / noneRe : Testcase @ vanhoa : mình post test này lên cũng là muốn thắc_mắc chỗ đó . Luật 4 phần i không nhắc đến expr trước do phải chắc_chắn đúng ( hoặc > 0 ) , thậm_chí không loại_trừ cả trường_hợp expr đó chắc_chắn sai . Nếu xét expr thì lại không thống_nhất với luật 3 . Luật 3 lại luôn yêu_cầu biến phải được gán trong " ... both branches ... " . Thấy kiểu nào thỏa đặc_tả cũng không được hợp_lý , mà kiểu hợp_lý thì không còn đúng với đặc_tả ! Edit : trong notice thầy có bổ_sung ý rồi . Kết_hợp đặc_tả với Notice thì không còn bất_hợp_lý nữa = ) ) Sửa lại test phía trên luôn cho hợp : DRe : Testcase_Test này các bạn ra None hay Type_Mismatch_In_Expression : array ( [ array ( [ array ( [ 1.0,2.0 ] ) ] ) , array ( [ array ( [ 1,2 ] ) ] ) ] ) function foo ( param : array [ 2,1,2 ] of real ) : integer ; begin return 0 ; end ; procedure main ( ) ; begin var a : real ; a : = foo ( [ [ [ 1.0 ; 2.0 ] ] ; [ [ 1 ; 2 ] ] ] ) ; end ; Test này ra None hay Type_Mismatch_In_Expression : ele ( a , [ 1000 ] ) procedure main ( ) ; begin var a : array [ 2 ] of integer ; a [ 1000 ] : = 1000 ; end ; Re : Tổng_hợp các câu_hỏi ? Câu 3 : lệnh gán sau return có tính không . ( case h ) Câu này nếu xét kỹ sẽ thấy nó không phải vấn_đề . Lệnh return đặc_biệt hơn lệnh break ở chỗ : sau break sẽ tiếp_tục các lệnh ngoài loop , còn sau return sẽ thoat ra hẳn function . : ) Re : Tổng_hợp các câu_hỏi ? _ Tieu _ Doan _ Du wrote : Đó là tư_duy thông_thường , nếu thế_thì chả cần phải nói khái_niệm biến phải được gán trước break làm_gì , vì theo lẽ thường thì sau break có thực_thi đâu . OK , mình sẽ nói kỹ hơn một xíu . Tạm_thời chúng_ta có 3 lệnh cần quan_tâm : lệnh return , lệnh gán , lệnh sử_dụng ( biến ) . Giờ xem như chưa có lệnh return : trong function chỉ có lệnh gán và lệnh sử_dụng . Chúng_ta sẽ đưa lệnh return vào sau để thấy được sự logic thông_thường . Trường_hợp 1 : không_thể chắc_chắn lệnh gán xảy_ra , lúc này ở lệnh sử_dụng sẽ bị lỗi Not_Defined_Before_Use . Giờ dù ta có đưa return vào chỗ nào đi_nữa cũng không thay_đổi được vấn_đề ( lệnh gán vẫn không_thể chắc_chắn xảy_ra hay không = > ở lệnh sử_dụng vẫn lỗi ) . Trường_hợp 2 : lệnh gán chắc_chắn xảy_ra , lúc này ở lệnh sử_dụng không có lỗi . 2a ) Giờ nếu ta đưa return vào sau cả hai lệnh trên thì vẫn không có lỗi . 2b ) Nếu ta đưa return vào giữa 2 lệnh trên . Chia ra : i ) Nếu return xảy_ra = > lệnh sử_dụng ( nằm sau lệnh return ) không_thể xảy_ra = > không_thể có lỗi ( vẫn giống lúc không có return ) . ii ) ) Nếu return không xảy_ra : trước lệnh sử_dụng vẫn chắc_chắn có lệnh gán ( nếu_không chắc_chắn có lệnh gán thì rơi vào trường_hợp 1 rồi nhé ) = > vẫn không_thể có lỗi . iii ) Return không chắc có xảy_ra không : dù thế_nào cũng là 1 trong 2 cái ( i , ii ) đã nói ở trên . 2c ) Nếu ta đưa lệnh return vào trước 2 lệnh trên . Chia ra : i ) Nếu return xảy_ra = > lệnh sử_dụng ( nằm sau lệnh return ) không_thể xảy_ra = > không_thể có lỗi ( vẫn giống lúc không có return ) . ii ) ) Nếu return không xảy_ra : trước lệnh sử_dụng vẫn chắc_chắn có lệnh gán ( nếu_không chắc_chắn có lệnh gán thì rơi vào trường_hợp 1 rồi nhé ) = > vẫn không_thể có lỗi . iii ) Return không chắc có xảy_ra không : dù thế_nào cũng là 1 trong 2 cái ( i , ii ) đã nói ở trên . Ok , rất là dài_dòng , nhưng nếu bạn suy_nghĩ được một_cách thông_thường thì không khó hiểu lắm đâu . Giờ đơn_giản nhất_là bạn hãy lấy một ví_dụ để thấy rằng khi có và không có return thì kết_quả ( lỗi hay không lỗi Not_Define ... ) thay_đổi ( theo ý mà bạn đầu topic đã nói ) . Nếu tìm được , tức_là mình sai ( & vice versa ) . Edit : à , mình hiểu rồi , thực_ra bạn nhầm ở chỗ này . Sau break các lệnh nằm ngoài loop ( vẫn trong function ) CÓ thực_thi bạn nhé = > biến local của function vẫn còn . Còn sau return thì thoát khỏi function mất rồi , biến global thì mặc_định được coi là đã define ( theo đặc_tả ) . Re : Tổng_hợp các câu_hỏi ? Vo_Thanh_Hung wrote : Câu_hỏi : Case h : assign sau break và continue ko tính . Thế sau return có tính ko ? Trả_lời : assign sau break và continue sẽ không tính , tương_tự sau return . Tuy_nhiên , các dòng lệnh sau các phần này vẫn sẽ kiểm_tra như bình_thường ( dù assign thì không tính ) Em không đồng_ý ở điểm này . Nếu assign sau return không tính thì nó đã mâu_thuẫn với luật tổng_quát hơn và hiển_nhiên đúng là : khi dùng một biến , nếu chắc_chắn biến đó đã được gán thì không báo Not_Defined_Before_Used nữa . Lấy ví_dụ sau : if ( true ) then begin if ( x ) then return 0 ; / / ( 1 ) a : = 5 ; / / ( 2 ) end a : = a ; / / ( 3 ) Áp_dụng luật : " An local variable must be initialized ( by an assignment ) before used " . Để cho a được use thì execution path phải đi qua ( 3 ) , mà đã tới được ( 3 ) thì khi đó nó chắc_chắn execution path đã đi qua ( 2 ) . Nếu execution path không đi qua ( 2 ) thì chắc_chắn nó đã đi qua ( 1 ) . Và như_vậy ( 3 ) không xảy_ra , nghĩa_là a đã không được use , mà không use thì không_thể nói Not_Defined_Before_Used . Đây có_vẻ ( chỉ là có_vẻ ) là kiểm_tra ở mức run - time nhưng thực_sự thì ở mức static check hoàn_toàn có_thể ( một_cách logic ) kiểm_tra được_việc này rồi . / / Eclipse : Tổng_hợp các câu_hỏi ? đừng phức_tạp hóa vấnđề nữa Thànhơi . Thầyđã nói cái phầnđó thuộc checkunreachable code . Mình không cần làm rồi mà . : ) Testcase cuối_cùng . Input : procedure the LastTest ( henxui : boolean ) ; begin ' full _ string expected but but _ only _ part _ found / / / * found * / ' ; end ; Output : line 3 : 1 : unexpected token : ' full _ string expected but but _ only _ part _ found / / / * found * / ' Testcase cuối_cùng . Test này không thuộc trọng_tâm của bài_tập nên cũng có_thể thầy sẽ không test . : DRe : Testcase cuối_cùng . Phan_Nguyen wrote : Trong thời_điểm hiện_tại , đừng ai chơi dại bấm nút resubmit thêm cái nữa , nếu_không thì ... ( tự biết hậu_quả đê ) , mà nếu lõ tay kiểu đó thì bị trự bi nhiêu vậy các bác ? Đúng 4 : 00 : 00pm mình kiểm_tra thì đã khóa submit rồi mà bạn . Hay bạn load trang đó trước rồi đến sau deadline mới bấm submit ? Re : Thứ_tự kiểm_tra Cannot_Assign_To_Constant : Assign ( Id ( a ) , Id ( b ) ) đâu nhé , cẩn_thận đó bạn : DRe : Thứ_tự kiểm_tra mình check 1 cách tuần_tự trên xuống dưới à . nếu 1 dòng có 2 lỗi thì báo lỗi nào . như VD này : var x : boolean ; procedure proc ( y : integer ; j : integer ) ; begin var a : integer ; x : = a-true ; end ; Type_Mismatch_In_Expression : sub ( a , true ) hay Not_Defined_Before_Used : aRe : Thứ_tự kiểm_tra H . T . P ( ^ _ ^ ) wrote : Vậy câu " One program have maximum 1 semantic error , your program will be stopped after found first error . " có nghĩa_là 1 chương_trình có_thể có nhiều dòng có lỗi , nhưng tất cảđều cùng 1 loại ( về ngữ_nghĩa ) . Nên gặp dòngđầu tiên là báo lỗi ngay dòngđó vàexit . Mình hiểu vậy cóđúng chưa nhỉ ? Tùy theo cách đếm " semantic error " . Mình không chắc lắm nhưng mình nghĩ là có hơi thừa chữ " first " . Nhưng nếu_không thừa thì cách hiểu có bạn khá hợp_lý : DRe : Thứ_tự kiểm_tra @ H . T . P ( ^ _ ^ ) : One program have maximum 1 semantic error , your program will be stopped after found first error . Mình vẫn nghĩ rằng chỉ có một lỗi , chứ không phải nhiều lỗi mà cùng một loại . Hơn_nữa " stopped after found first error " phụ_thuộc vào cách mỗi người xử_lý mà cái nào found trước found sau , khác với " stopped after the first error " chỉ phụ_thuộc vào source code . Nên cũng theo mình nghĩ , sẽ không có hai ví_dụ bạn đưa ra ở trên ( trong bộ testcase của thầy ) . Function_Not_Return @ nhan : Theo bạn ví_dụ này thì_sao : ) function foo ( a : integer ) : integer ; begin if ( a > 0 ) then return 0 ; else return 1 ; writeLn ( ' this line never runs ' ) ; end và ví_dụ này : D function bar ( ) : integer ; begin if true then return 0 ; else write Ln ( ' this line never runs ' ) ; endRe : Function_Not_Return nguyen dung wrote : Theo như đặc_tả thì chỉ cần return xuất_hiện trong func là đủ , ngay cả khi nó không_bao_giờ chạy = > test trên bt Có_lẽ bạn hiểu sai đặc_tả . Trong mỗi đường thực_thi của một function , cần có ít_nhất một lệnh return . Hai ví_dụ mình đưa ra là để làm rõ thế_nào là " đường thực_thi " ( execution path ) . Theo mình thì đường thực_thi sẽ được xác_định ở mức_độ cấu_trúc chương_trình , chứ không phải ở mức_độ chạy chương_trình . Nghĩa_là cho_dù có một đường thực_thi về mặt ngữ_nghĩa / logic không_bao_giờ được thực_hiện , nó vẫn phải có ít_nhất một lệnh return . Nên ví_dụ thứ 2 cần có thêm một lệnh return cho đường thực_thi đi qua nhánh else ( return trong else ; hoặc sau else và trước end ) Ở ví_dụ thứ nhất , cho_dù xét ở mức cấu_trúc chương_trình , trên mỗi đường thực_thi đều đã có một lệnh return , nên mình nghĩ sẽ không báo lỗi ở đây . Tuy_nhiên mình chưa bắt_đầu làm_nên không chắc lắm vấn_đề này . Re : Function_Not_Return H . T . P ( ^ _ ^ ) wrote : Cho hỏi ngoài_lề 1 tí . nếu trong Proceduce có lệnh return thì sử lý làm_sao ? * For a return statement , the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . * The right - hand side ( RHS ) is either in the same type as that of the LHS or in the type that can coerce to the LHS type . Procedure có return type là gì nhỉ : p Nên mình nghĩ sẽ xuất lỗi Type_Mismatch_In_Statement : . Re : Function_Not_Return nhan nguyen van wrote : Thanh_Pham_Minh wrote : H . T . P ( ^ _ ^ ) wrote : Cho hỏi ngoài_lề 1 tí . nếu trong Proceduce có lệnh return thì sử lý làm_sao ? * For a return statement , the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . * The right - hand side ( RHS ) is either in the same type as that of the LHS or in the type that can coerce to the LHS type . Procedure có return type là gì nhỉ : p Nên mình nghĩ sẽ xuất lỗi Type_Mismatch_In_Statement : . Type_Mismatch_In_Statement : Có_nghĩa là câu_lệnh này bị sai kiểu , còn return trong procedure là sai câu_lệnh , nếu có kiểm_tra thì parser phải kiểm_tra chứ , theo mình nghỉ là StaticChecker không kiểm_tra cái này . Bạn đã đọc kỹ đặc_tả và hai dòng có dấu * mình trích_dẫn chưa : ) Re : Function_Not_Return / / lăn chuột hơi mỏi tay Re : Function_Not_Return ass2 wrote : quá dài_dòng ! nhìn là không muốn đọc rồi Oh , xin_lỗi bạn nhé , mình cũng không cố_ý để bạn nhìn thấy ; ) ) Re : Function_Not_Return H . T . P ( ^ _ ^ ) wrote : Còn trường_hợp returnở trong vòngwhile mà nằm sau break ; thì_sao . đường thực thiđi quawhile cóđược tính là có return rồi hay ko ? ? 01 . Nhưng bạn vẫn phải có return cho execution path không đi qua while . 02 . Execution path đi qua while chứa execution path không đi qua while . = > có hay không có return trong while không thay_đổi được gì cả : ) Function_Not_Return vanhoa wrote : Có 2 loại while : 1 . while chắc_chắn được thực_hiện ( while có mệnh_đề điều_kiện luôn đúng ) : mình xem thân nó như một block bình_thường . 2 . while không chắc đúng hoặc while luôn sai : không cần xem_xét . Tương_tự cho loop . var a : integer ; function foo ( a : integer ) : integer ; begin if ( a > = 1 ) then a : = 0 ; while ( a < 1 ) do return 0 ; a : = 1 ; end ; procedure main ( ) ; begin var b : integer ; a : = 100 ; b : = foo ( a ) ; end ; Theo cách chia đó thì ví_dụ trên thuộc loại 1 hay 2 ? Nếu thuộc loại 1 nghĩa_là bạn đã chạy chương_trình ? Nếu thuộc loại 2 thì_có nên chia giữa " chắc_chắn " và " không chắc " . Loại 2 đã một phần chứa loại 1 ( tùy việc bạn hiện_thực tới mức nào ) . Logic thì_phải là " chắc_chắn có " và " chắc_chắn không " mới không bị overlap . Function_Not_Return vanhoa wrote : Đây là static check : ) Đó chính là cái mình muốn nói . Static check thì bạn không_thể xét expression trong while có luôn đúng hay không . Function_Not_Return vanhoa wrote : có chứ , vd while true . vậy đâu còn là s tatic check nữa : ) cứ_cho_là " true " ok vì không phải eval gì cả , " 1 > 0 " thì_sao : ) Tên file cần nộp . Mong thầy xác_nhận lại là tên file nộp có cần phân_biệt chữ hoa , chữ thường không . Trong đặc_tả và trên Sakai ghi là nộp file " crazy2011.scala " còn trong thư_mục src thì_có file " Crazy2011.scala " . Em cảm_ơn . Tên file cần nộp . Nhưng mình sai thì sẽ có bắt_bẻ đấy : pBooleanLiteral _ Trung _ Than _ Thong wrote : 1 . Giờ mới phát_hiện cái boolean Literal chưa hiện_thực và hiện_thực thì gặp lỗi . hix . Vì giá_trị boolean chỉ có true hoặc false ( cái này token mình đâu có kiểm_tra trong regex ) . def bool Literal : Parser [ BooleanLiteralPT ] = elem ( " boolean " , _ . isInstanceOf [ lexical.BooleanLit ] ) ^ ^ { a = > new BooleanLiteralPT ( a.chars ) } 2 . cái tring Literal của thầy viết trả về kiểu string = > như_vậy giả_sử mình đặt 1 kiểu LiteralPT thì nó báo lỗi vì string k thuộc kiểu này : def literal : Parser [ LiteralPT ] = intLiteral | stringLiteral ... . ( cái này dùng để nhận dữ_liệu cho array chẳng_hạn ) Không thật_sự hiểu rõ lắm định_nghĩa các kiểu dữ_liệu này có từ_khóa như real , int , string đâu có ảnh_hưởng . Mong mọi người giúp_đỡ 1 . Bạn làm một_cách đơn_giản . booleanLiteral có 2 trường_hợp là true và false . Vậy hãy parse 2 trường_hợp đó thôi . Đừng để code mẫu của những literal kia làm ảnh_hưởng . 2 . Bạn sửa sao cho string Literal thuộc kiểu StringLiteralPT hoặc một_cách nào_đó khác ! Re : giúp_đỡ phần khai_báo array @ Scala ^ ^ : bạn thử xóa dòng màu đỏ đi xem sao ! Edit : xóa thêm dấu { và } nữa : D_Edit : xóa thêm dấu ^ ^ luôn : pRe : giúp_đỡ phần khai_báo array Mình không có code phần def array Literal của bạn nên cũng không chắc . Có_thể input bạn ghi thiếu " const b = ... Re : giúp_đỡ phần khai_báo array Chắc do phần const Dec bạn chưa bổ_sung thêm trường_hợp array Literal . Hoặc phần one Dec bạn chưa bổ_sung const Dec . Hoặc bạn chưa hiện_thực BooleanLiteral thành_công . ... Test : const b = [ 1 ] ; Re : giúp_đỡ phần khai_báo array Không có chi ^ ^ Re : giúp_đỡ phần khai_báo array chỗ var Dec , minh có_thể khai_báo là var a , b , c : real ; nhưng trong code thì def var Dec : Parser [ List [ VarDecPT ] ] = ( " var " ~ > ident < ~ " : " ) ~ ( varType < ~ " ; " ) tức_là chỉ cho 1 variable mình sửa lai ident thành identlst như_thế_này def var Dec : Parser [ List [ VarDecPT ] ] = ( " var " ~ > identlst < ~ " : " ) ~ ( varType < ~ " ; " ) ^ ^ { case a ~ b = > { List ( new VarDecPT ( new IdPT ( a ) , b ) ) } } def identlst : Parser [ IdPT ] = repsep ( ident , " , " ) thì bị lỗi dòng màu đỏ . Re : giúp_đỡ phần khai_báo array def var Dec : Parser [ List [ VarDecPT ] ] = ( " var " ~ > identlst < ~ " : " ) ~ ( varType < ~ " ; " ) ^ ^ { case a ~ b = > { List ( new VarDecPT ( new IdPT ( a ) , b ) ) } } def identlst : Parser [ List [ IdPT ] ] = repsep ( ident , " , " ) / / loi : type mismatch ; found : CrazyParser.this.Parser [ String ] required : CrazyParser.this.Parser [ IdPT ] mình sửa lại thế_thì nó báo lỗi 2 dòng kia lun hix Re : giúp_đỡ phần khai_báo array def identlst : Parser [ List [ IdPT ] ] = repsep ( ident , " , " ) Một_số câu_hỏi về array Re : 1 số thắc_mắc A program in Crazy consists of many declarations which are variable , constant , procedure and function declarations . Nếu_không có hoặc chỉ có một declaration thì_sao ? : D_Trường hợp chỉ có một declaration : có test mẫu và đáp_án mẫu rồi = > không cần lo . Trường_hợp không có gì cả ( file input trống_trơn ) : theo mình nên để parse được . Output là [ ] . Vì nếu đáp_án là không parse được thì đáp_án đó mâu_thuẫn với test mẫu rồi . String_Literal_Nếu giữ nguyên chỗ def const thì sẽ có một_số trường_hợp đáng chú_ý sau : Trường_hợp 1 : Input : const f = ' " ' ; / / dấu nháy đơn ' rồi đến dấu nháy_kép " rồi đến dấu nháy đơn ' . const g = ' a " ' ; / / dấu nháy đơn ' rồi đến a rồi đến dấu nháy_kép " rồi đến dấu nháy đơn . Output : [ const ( f , " ) , const ( g , a " " ) ] hằng string ở biến g đã bị nhân đôi dấu nháy_kép trong khi hằng string ở biến f thì không . Các dấu nháy_kép đều bị nhân đôi trừ dấu đứng ở đầu string . = > không thống_nhất . Ví_dụ tương_tự : const h = ' " a " ' ; = > [ const ( h , " a " " ) ] Đồng_ý là có những chỗ trong source mẫu cần phải sửa , nhưng đặc_tả không nói về trường_hợp trên . Mong thầy nói rõ : Dấu nháy_kép " trong hằng String có phải nhân đôi không , nhân đôi ở những vị_trí nào ? Em cảm_ơn . Re : String_Literal_Trường hợp 2 : Input : const c = ' ' ' ' ' a ' ' ' ' ' ; / / mỗi bên a có 5 dấu nháy đơn ' Output : [ const ( c , ' a ' ) ] Lẽ_ra nên là [ const ( c , ' ' a ' ' ) ] Những vấn_đề trên không nằm ở thiết kết ngôn_ngữ ( không phụ_thuộc mức_độ Crazy ) mà nằm ở phần hiện_thực ngôn_ngữ ( parseTree ) . Nếu giữ nguyên như bây_giờ thì sau khi parse xong : const c = ' ' ' ' ' a ' ' ' ' ' ; const d = ' ' ' a ' ' ' ; const x = ' " a ' ; const y = ' a " ' ; dựa vào parse Tree để xử_lý tiếp các phần sau ta sẽ có : assert ( c = = d ) = > ok assert ( length ( x ) = = length ( y ) ) = > NOT ok Trường_hợp 3 : Input : const c = ' ' ; Output : ? ? ? Re : String_Literal_Vo_Thanh_Hung wrote : 2 . Rất nhiều câu_hỏi do các em không đọc kỹ đặc_tả 3 . Các em phụ_thuộc vào code mẫu quá nhiều 4 . Lab là lab còn asignment là assignment , tôi không nhớ có lần nào nói rằng phải thay ' ' thành ' và " thành " " , đặc_tả không có cái đó Thưa thầy , Em còn thắc_mắc về phần sau : nếu đọc kỹ đặc_tả ta sẽ thấy " A program in Crazy consists of many declarations which are variable , constant , procedure and function declarations . " Em không biết phần gạch chân nên hiểu theo nghĩa nào ? Nếu hiểu thông_thường sẽ không parse thành_công trường_hợp input rỗng . Vì input rỗng sẽ không có declaration nào cả , như_vậy là sai ngay từ chữ consists . Mong thầy tránh testcase như_vậy ạ ! Và dĩ_nhiên chúng_em sẽ không có thắc_mắc , cứ theo đặc_tả mà làm , nếu_như từ trước giờ đặc_tả chưa từng có ý nào phải chỉnh_sửa lại !
