Nộp bài cho_rồi Thầy đi Thái rồi , để lại nhiều thắc_mắc bỏ_ngỏ . Sinh_viên tự mò và tự đưa ra chuẩn cho mình . Thôi_thì cũng tới hạn rồi , thời_gian còn lại chắc thầy cũng không xuất_hiện đâu . Nộp bài luôn cho khoẻ . Dĩ_nhiên thêm phần cầu trời nữa . Các bạn cho mình hỏi về cái def Show tý nhé ! @ nguyen : chỗ này phải xử_lí chuỗi đó bạn . @ Thanh_Pham_Minh : đặc_tả yêu_cầu ra <eof> thì cứ ra vậy đi , chừng nào thầy bảo sửa lại thì hẵng hay . Mình có làm sai thì còn có cái để đổ_thừa mà ! : ) ) Các bạn cho mình hỏi về cái def Show tý nhé ! code thì ko quăng lên được rồi , mình chỉ có_thể gợi_ý là dùng . indexOf của string thôi . chúc may_mắn ! Re : Các bạn cho mình hỏi về cái def Show tý nhé ! Mai_Hoa_Đạo wrote : Qui_Pham_Xuan wrote : Gợi_ý tí : Cái def show bạn dựa vào hàm clean ( ) trong TestToken ấy . Để in token thì dùng next . first ... . . nhé ! ! ! Ở đây có thểdùng if ... else ... sẽ ra đúng theo mọi trường_hợp báo lỗi theo yêu_cầu đề . Good luck ! ! ! Mình cũng dùng if - else để thể_hiện nhưng_mà không hiểu bị lỗi gì . Nếu chỉ if rồi else thì không có lỗi . Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là " type missmatch ; found : Unit required : String " . Các bạn giúp mình với . Chắc là bạn xuống dòng không đúng chỗ . Không_bao_giờ được xuống dòng chữ " else " , do Scala không có ; cuối câu_lệnh nên sẽ nghĩ rằng if không có else . Re : Các bạn cho mình hỏi về cái def Show tý nhé ! DoomAce wrote : Roni_Mikado wrote : Gợi_ý tí : Cái def show bạn dựa vào hàm clean ( ) trong TestToken ấy . Để in token thì dùng next . first ... . . nhé ! ! ! Ở đây có thểdùng if ... else ... sẽ ra đúng theo mọi trường_hợp báo lỗi theo yêu_cầu đề . Good luck ! ! ! Mấy bạn cho mình hỏi là sau khi viết hàm dựa trên TestToken rồi mình dùng dấu gì để nối với " unexpected token : " vậy ? Vì có if ... else nên chắc ko dùng đc dấu + như mấy cụm trước rồi + vô_tư , đây là Scala chứ không phải Crazy.Re : RdivExprPT vs IdivExprPT ? ? ! Guest_User wrote : AddExprPT / / cộng SubExprPT / / trừ TimesExprPT / / nhân RdivExprPT / / chia thực " / " IdivExprPT / / chia nguyên " div " ImodExprPT / / mod NeExprPT / / <> EqlExprPT / / = GeExprPT / / > = GreaterExprPT / / > LeExprPT / / < = LessExprPT / / < BorExprPT / / or BandExprPT / / and BnotExprPT / / not hoặc - ExponentExprPT / / ^ FuncCallExprPT / / gọi hàm ConsPT / / trị hằng_số LefHandSidePT / / left hand side VarExprPT / / biến EleExprPT / / truy_cập mảng = > cái này bữa mình viết nè chứ đâu , hok phải của thầy ! : D có cái chỗ dấu - ấy hình_như sai rồi : theo code thầy thì SubExprPT có nhận 1 ngôi nên - 1 ngôi là sub chứ không phải bnot đâu . Re : Hỏi về nhận_dạng array ở stage 1 coffee cafe wrote : Khi test : const h = [ 23 ] ; bên TOKEN = > ` const ' identifier h ` = ' [ 23 ` ] ' ` ; ' EOF ben PARSER = > màn_hình console trống_trơn , không lỗi , không kêt quả các bạn biết vì_sao không ? ^ ^ Mình đoán là bạn làm sai cái regex của real ( vì mình đã từng bị như_vậy ) do dấu ' . ' được hiểu là " any character " = > sửa lại " \ \ . " . Hỏi về nhận_dạng array ở stage 1 Cái này thì bó_tay , lẽ_ra nó phải ra Error message chứ nhỉ ? Statements-IfStatement cái opt ( ... ) thì lúc có lúc ko nên ko để c vậy được . bạn phải chia trường_hợp : case a ~ b ~ Some ( c ) = > ... case a ~ b ~ None = > ... Statements-IfStatement if expression then statement else statement mà A return statement starts with keyword return followed by an expression and ends with a semicolon . Statements-IfStatement be_be wrote : if ( a +3 ) then return 3 else return 0 các bạn cho mình hỏi cái này có đúng ko ? Lỗi vì thiếu ; sau return , nếu đủ thì parse được . Testcase cho stage 2 Thế trường_hợp sau có parse được không nhỉ : procedure a ( ) ; begin a : = a [ a , a [ a ] ] ; end ; Hiện mình cho parse tree là : [ proc ( a , [ ] , [ assign ( a , ele ( a , [ a , ele ( a , [ a ] ) ] ) ) ] ) ] Testcase cho stage 2 @ vanhoa : cái chỗ unexpected token đó ko có cặp dấu ` ' đâu nhé , cẩn_thận ! Re : Testcase cho stage 2 Mai_Hoa_Đạo wrote : vd : = not not not not 4 ; Các bạn cho mình hỏi xài not như_vậy là not có kết_hợp phải rồi phải không . Nhưng ma trong đề thì mình thấy not không có kêt hợp nào cả . Có phải nên sửa lại là : vd : = not ( not ( not ( not 4 ) ) ) ; Như_vậy là parse được rồi . Re : Testcase cho stage 2 meo _ lac wrote : nguyen dung wrote : 1 ) trường_hợp var x : array [ 0 ] of integer cũng sẽ parse thành_công phải ko ạ ? Parse thành_công " The integer constant represents the size of the corresponding dimension and it must be a positive number , i . e . number greater than 0 " Chỗ này cũng mâu_thuẫn với đề nè cái demision đề nói phải > 0 mà này parse thành_công . Nguồn : https : / / elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3407.page Thầy trả_lời đúng rồi đó bạn , k có j mâu_thuẫn đâu . Tại vì giai_đoạn này chỉ kiểm_tra cú_pháp thôi ( tức_là mặt_chữ đó ) , còn những cái liên_quan đến ngữ_nghĩa , tầm vực , kiểu thì k quan_tâm . Còn trong file PT thầy thêm trường_hợp list null cho ArrayLiteral và EleExpr là để tránh xảy_ra exception trong quá_trình chạy test ( giả_sử quá_trình test bài của bạn bị exception thì sẽ bị exit = > k test tiếp cho bạn những test sau ) ^ ^ . Trường_hợp array const thì đề đã ghi rõ là ' ' An array constant is a semicolon - separated list of elements enclosed in left and right square brackets . The list may NOT be empty ' ' , còn trường_hợp element thì mình nghĩ cũng tương_tự . Có j sai mọi người chỉ_bảo . ^ ^ Phần trước thì mình đồng_ý với bạn , còn phần để tránh xảy_ra exception thì chắc là không có đâu . Testcase cho stage 2 @ vanhoa : test nào có lỗi đều có hết đó bạn , ví_dụ test 14 hay 15 . còn cái - 1 ngôi là bnot , 2 ngôi mới là sub . Testcase cho stage 2 line 1 : 17 : unexpected token : ; và line 1 : 22 : unexpected token : : TO_DO trong Utils.scala Đề yêu_cầu chỉ nộp file StaticChecker.scala , nhưng trong file Utils.scala lại có mấy dòng / / TO_DO ... Vậy mấy dòng này chỉ để chơi vậy thôi chứ tụi em đâu cần làm_gì phải không thầy ? chỉnh_sửa program trong code mẫu Đúng mà , đâu cần sửa gì đâu . chỉnh_sửa program trong code mẫu Code mẫu đã chạy được input mẫu mà , vậy có_khi bạn sửa đâu_đó rồi . not Lúc đầu mình cũng làm bnot cho - 1 ngôi , nhưng sau có bạn nhắc là hàm sub thầy có xử_lí cho 1 ngôi = > dùng hàm sub . Re : Hỏi về phần left HandSide trong đặc_tả Em yêu Scala ♥ ♥ ♥ wrote : À mình đã hiểu . Đọc đề ko kĩ : d . Thanks bạn nha . Như_vậy thì a : = [ 2 ; 3 ; 4 +1 ] ; thì ko đc đúng ko ? Parse không được : DHỏi về 12 hàm built - in ở cuối đặc_tả Giờ chưa cần đụng tới mà . Re : wholeNumber Hình_như không có whole Number đâu em . Dùng int Literal đi . Re : hỏi ý_nghĩa về các hàm cho sẵn AddExprPT / / cộng SubExprPT / / trừ TimesExprPT / / nhân RdivExprPT / / chia thực " / " IdivExprPT / / chia nguyên " div " ImodExprPT / / mod NeExprPT / / <> EqlExprPT / / = GeExprPT / / > = GreaterExprPT / / > LeExprPT / / < = LessExprPT / / < BorExprPT / / or BandExprPT / / and BnotExprPT / / not hoặc - ExponentExprPT / / ^ FuncCallExprPT / / gọi hàm ConsPT / / trị hằng_số LefHandSidePT / / left hand side VarExprPT / / biến EleExprPT / / truy_cập mảng Re : Thắc_mắc về các toán_tử Theo mình thì : 1 . Trong_Parser này thì chấp_nhận bình_thường . 2 . Khi nào có đủ 2 toán hạng thì - là 2 ngôi , còn không thì_là 1 ngôi . VD : 1 - 2 / / 2 ngôi 1 - - 2 / / - trước là 2 ngôi , - sau là 1 ngôitrường hợp này có đc nhận hay k Không nhận đâu ! . . . . . Vì x : = mới nhận : ) ) Theo đặc_tả <id> [ <expr> , … , <expr> ] , mà 1 +2 là expr nên nhận thoải_mái ! Token ? Có đó cưng . Xem dòng cuối_cùng trong đặc_tả ass 1 : line 5 : 4 : unexpected token : " token EOF hay <eof> Thì bạn làm_sao cho nó trả về <eof> là được . Const_Array này nhận được ko vậy mọi người kiểm_tra kiểu là kiểm_tra ngữ_nghĩa rồi , thuộc về ass 2.Const Array này nhận được ko vậy mọi người nhan nguyen van wrote : Just A_Tee wrote : Vậy [ 1 ; false ; 3.5 ] với [ [ 2 ; 4 ] ; 3 ; true ] parse thành_công không mọi người ? mình nghỉ [ 1 ; false ; 3.5 ] không được , cái này mình có_thể kiểm_tra token được mà : a [ ListInteger token | Listboolean token ... ] = > cac phan tu tron array phai cung kieu thi co the kiem tra duoc . chi co truong hop a [ [ 2 ; 3 ] ; [ true ; false ] ] la khong kiem tra duoc thoi ... vi 2 phan tu trong mang a deu la mang ca = > chap nhan , con kiem tra kieu tiep nua thi ko duoc . ( ass2 ) Em có_thể check kiểu đó , tuy_nhiên parse vẫn thành_công đơn_giản vì nó đúng cú_pháp . Một_số câu_hỏi về array Các thầy cho em hỏi 1 chút về array : 1 . Truy_cập mảng nhiều chiều như_thế_nào ? VD : a [ 1 ] [ 1 ] : = 1 ; hay : a [ 1,1 ] : = 1 ; 2 . Mảng rỗng có báo lỗi ở phần Parser này không ? Báo như_thế_nào ? VD : var z : array [ ] of integer ; thì_ra : [ var ( z , arr ( [ ] , int ) ) ] hay : line 1 : 15 : unexpected token : ` ] ' Re : Một_số câu_hỏi về array [ var ( x , int ) , var ( y , int ) , var ( z , int ) ] Trong đặc_tả có nói rồi đấy . Một_số câu_hỏi về array Đâu có cần phân_biệt input làm_gì đâu bạn . 1.1 mod 1.2 Ý bạn hỏi là gì ? Nếu hỏi nó có phải là expression không thì đúng . Còn là chương_trình parse được thì không . 1.1 mod 1.2 be_be wrote : vậy bạn cho mình hỏi thêm , thí_dụ a : = 1 mod fun ( 1 ) ; mình có cần phải kiểm_tra kiểu của fun ( 1 ) ko ? Có , nhưng trong ass 2 : Dmột trường_hợp về hằng chuỗi Guest_User wrote : const x = ' ' ' ; line 1 : 11 : unexpected token : ' Guest_User wrote : const x = ' ' ' ' ' ' ' ' ; [ const ( x , ' ' ' ) ] một trường_hợp về hằng chuỗi Just A_Tee wrote : const a = ' ' ; / / 2 dấu nháy đơn thì_ra cái gì mọi người [ const ( c , ) ] Re : Một_số câu_hỏi về array walk alone wrote : cho em hỏi : khi khai_báo constan là array , thì các phần_tử trong array mình có phải kiểm_tra nó có tương_đồng nhau không hả anh ? ? Kiểm_tra kiểu trong ass 2 lận . 1.1 mod 1.2 vì nó không phải là chương_trình , có chương_trình nào chỉ cụt_ngủn vậy đâu ! Re : Một_số câu_hỏi về array Scala ^ ^ wrote : cho mình hỏi const a = [ ] ; thì output là : [ const ( a , [ ] ) ] phải k mấy bạn ? hay la báo lỗi line 1 : 10 : unexpected token : ] [ const ( a , [ ] ) ] Re : Một_số câu_hỏi về array T . D . N wrote : Long_Potter wrote : Scala ^ ^ wrote : cho mình hỏi const a = [ ] ; thì output là : [ const ( a , [ ] ) ] phải k mấy bạn ? hay la báo lỗi line 1 : 10 : unexpected token : ] [ const ( a , [ ] ) ] Array constant đâu có dc rỗng Cái này cũng không chắc lắm nhưng code xử_lí được thì cho xử_lí luôn . Một_số câu_hỏi về array Just A_Tee wrote : Cho mình hỏi luôn : a : = b [ 2 , 3 , [ 3 ] ] ; c : = d [ 3 , [ 4 ; 5 ] , 2 ] ; e : = f [ 5 , [ ] , 2 ] ; ra kết_quả ntn vậy mọi người ? [ proc ( a , [ ] , [ assign ( a , ele ( b , [ 2,3 , [ 3 ] ] ) ) , assign ( c , ele ( d , [ 3 , [ 4 ; 5 ] , 2 ] ) ) , assign ( e , ele ( f , [ 5 , [ ] , 2 ] ) ) ] ) ] Test với procedure a ( ) 1 số thắc_mắc T . D . N wrote : Vậy_là xuất ra lỗi thì xuất EOF hay vậy mọi người <eof> , theo file đặc_tả ass 1.String Literal_Mình nghĩ là mọi người không nên dựa vào code của thầy quá . Đoạn này tự xử_lí được mà . Re : String_Literal_Thanh_Pham_Minh wrote : Trường_hợp 3 : Input : const c = ' ' ; Output : ? ? ? [ const ( c , ) ] Re : Testcase ' không phải là token nên phải ra ErrorToken ' chứ nhỉ .
