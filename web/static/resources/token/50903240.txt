Re : GradeBook Mid_Term MSSV : 50903240 Tên : Lê_Văn Re : Bài 5 solution Tut5 s là kết_quả trả về , đây là procedure thôi chứ không phải là function , bạn xem kỹ lại đề : ) Re : Hỏi về sol TuT 5 và tut 3 1 chút góp_ý về pass by name , during 3rd swap , swap ( value , list [ value ] ) ; void swap ( int a , int b ) { int temp ; temp = a ; ( temp = value = 1 ; ) a = b ; ( value = list [ value ] = list [ 1 ] = 2 - > value = 2 ) b = temp ; ( list [ value ] = temp = 1 ( value = 2 ) - > list [ 2 ] = 1 ) } after 3rd swap value = 2 list [ value ] = 1Re : Hỏi về sol TuT 5 và tut 3 bài 3b tut3 dynamic referencing environments chứ không phải static referencing environments Re : worry mấy huynh cho mình hỏi bài 1 câu a : comment trong string là / * * / thì nó chấp_nhận những điều_kiện gì , mình đọc mãi mà không hiểu : ( hỏi 1 chút về solution tut 1 cho mình hỏi bài 3 câub : mình không hiểu từ q 1 - > q5 có cần_thiết ko , bạn nào giải_thích giúm mình tại_sao có trường_hợp này cho mình hỏi thêm có chấp_nhận " 1 diagram NFA , DNF chấp_nhận chuỗi không đúng với mô_tả không " . ví_dụ trong trong solution bài 5 câu b mình có 1 chuỗi aba không giống với mô_tả ( ( a * b * a * ) * b ) * của đề_bài nhưng lại thỏa_mãn solution Re : Solution_Tut 3 chắc là tut 2 với lab 3 : | Re : Lab 2 hinh nhu cai class symbol cua scala ko co dinh dang string , intRe : Lab 2 minh cung tu define class nhung khi dugn class do thi no lai la class cua thagn scala @ @ Re : Lab 2 ah nhan tien cho minh hoi bai 6 , minh ko ro kieu tra ve cua cai ham deriv , neu tra ve kieu Poly thi man hinh xuat ra cai gi @ @ Re : Lab 2 vay trong class X ( ) cua ban co bien x nao do ko , vi du case class X ( x : String ) chang han Re : Lab 2 vay ban dinh nghia class sum the nao = . = ! Re : Lab 2 thank cau minh da lam ra : " > Re : Testcase cho stage 2 các bạn cho mình hỏi testcase 26 procedure main ( ) ; begin if 1 then if 2 then if 3 then s 3 ( ) ; else s 4 ( ) ; else s 5 ( ) ; else if 7 then s 7 ( ) ; else if 8 then s 8 ( ) ; else if 9 then s 9 ( ) ; end ; ở đây theo bạn Hòa thì s 3 là functioncall trong khi đó định_nghĩa của if statement làif <expression> then <statement> else <statement> or if <expression> then <statement> vậy functioncall lúc này chấp_nhận là statement hả ? nếu_vậy mình không định_nghĩa được @ @ đáp_án của bạn hòa [ proc ( main , [ ] , [ if ( 1 , if ( 2 , if ( 3 , call ( s3 , [ ] ) , call ( s4 , [ ] ) ) , call ( s5 , [ ] ) ) , if ( 7 , call ( s7 , [ ] ) , if ( 8 , call ( s8 , [ ] ) , if ( 9 , call ( s9 , [ ] ) ) ) ) ) ] ) ] Re : Testcase cho mình hỏi test 36 sai chỗ nào thế : ) . Mình không hiểu path of execution cho lắm OneStmt and Stat case class Block ( body : List [ OneStmt ] ) extends Stat / / TODO fix cái này có phải sửa lại là body : List [ Stat ] không thầy , lúc check em không_thể cast từ OnStmt sang Stat được , em cảm_ơn Re : OneStmt and Stat librastar wrote : Dùng as InstanceOf [ Stat ] dùng as InstanceOf bị lỗi bạn , trait OneStmt abstract class Stat extends WithItem with OneStmt hình_như không_thể cast từ OneStmt sang Stat được Re : OneStmt and Stat_Kid wrote : trong hàm check Block mình code val syms N = ( symbols / : block.body ) ( ( a , b ) = > { b match { ... . . case stmt = > checkStatement ( b.asInstanceOf [ Stat ] , a , inLoop ) } nhưng bị báo lỗi : type mismatch ; found : Any required : List [ Symbols ] bạn nào chỉ giúp mình với nha . xem_lại kiểu trả về của hàm check Statement , vì cài hàm ( symbols / : block.body ) ( ( a , b ) nó yêu_cầu trả về kiểu List [ Symbol ] a ? = 0 or 1 các bác giúp em với = . = ! code : import scala . uti.matching . _ val re = new Regex ( " [ 1234 ] \ \ . ( 0 | 0 * [ 123 ] ) ( [ eE ] [ 123 ] ) " ) val x = " 1.0000002e3 " val kq = re.findAllIn ( x ) kq.foreach ( println ) kết_quả là 1.0000002e3 còn nếu val re = new Regex ( " [ 1234 ] \ \ . ( 0 | 0 * [ 123 ] ) ( [ eE ] [ 123 ] ) ? " ) thì lúc này kết_quả chỉ ra 1.0 cho em hỏi dấu ? trong đoạn code trên có phạm_vi ảnh_hưởng ntn . ( [ eE ] [ 123 ] ) thôi hay_là ( 0 | 0 * [ 123 ] ) ( [ eE ] [ 123 ] ) Re : a ? = 0 or 1 ah sr để mình edit lại bài , " 123.000002 " - > " 1.000003e2 " Re : Hỏi về 1 trường_hợp của real và cách ghi = regex trong scala nếu bạn để_ý một xíu khi đặt chuột lên trên chữ r thi nó có dạngdef r : scala.util.matching.Regex = > r là một hàm va return type của nó là 1 Regex , bạn mở interpreter trong eclipse ra , gõ : import scala . util.matching . _ val s = " 123 " s : java.lang.String = 123 s . r res 0 : scala.util.matching.Regex = 123 tới đây mình có_thể hiểu r là 1 method cua lớp string thừa_kế từ java : ) to be continue ... . thânRe : dấu_chấm mấy bạn cho mình hỏi dấu ? có sử_dụng trong scala được không khi mình test regex ( " 1 ? " . r ) thì nó sẽ chạy vô_hạn dấu xuống dòng = . = ! Re : Cách compile các file cho mình hỏi , mình đã làm đúng như trên , khi gõ " scalac TestToken.scala " thì nó báo lỗi not found : type CrazyLexical val lexical = new CrazyLexical ai biết cách sửa không : DRe : Cách compile các file thank u : Dtype checking của Scala def one Dec : Parser [ List [ SubtinePT ] ] = varDec | procDec ^ ^ { case a = > List ( a ) } def proc Dec : Parser [ ProcDecPT ] code mẫu của thầy không bi lỗi def one Dec : Parser [ List [ SubtinePT ] ] = varDec | procDec | funDec ^ ^ { case a = > List ( a ) } def proc Dec : Parser [ ProcDecPT ] ... def fun Dec : Parser [ FuncDecPT ] ... thì lại bị lỗi type mismatch ; found : CrazyParser.this.Parser [ ScalaObject ] required : CrazyParser.this.Parser [ List [ SubtinePT ] ] mình đã kiểm_tra lại class FuncDecPT ( val name : IdPT , val param : List [ ParamDecPT ] , val return Type : TypePT , val block Stmt : BlockStmtPT ) extends SubtinePT class ProcDecPT ( val name : IdPT , param : List [ ParamDecPT ] , val block Stmt : BlockStmtPT ) extends SubtinePT ai có_thể giải_thích hộ mình không : ) , bị lỗi dòng one Dec thôi nhé : DRe : type checking của Scala sr mình mới edit lại bài thiếu dấu ^ ^ bạn có_thể giải_thích lại nếu thấy thay_đổi : ) Re : Test dùm nha ! test procedure main ( a : real ) ; begin end ; procedure main ( a : real ) ; s begin end ; procedure main ( a : real ) ; begin end ; line 4.26 : unexpected token : dentifier ai so sanh voi minh voi
