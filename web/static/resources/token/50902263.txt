Mong anh Hùng phổ_biến rõ hơn về vấn_đề Function_Not_Return vanhoa wrote : 1 > 0 vẫn là true : ) ) Thựcchấtstaticcheckcũngbaogồmnhữngcáinàynữa , tuỳvàongườiđịnhnghĩathôi , VDnhưmấycáiIDEjavađó , netbeans hoặc Eclipsechẳnghạn , nóvẫncheckmấycáiđóđó : D_Cái này a Hùng bảo làm chứ nếu_không thì ass này đơn_giản quá , còn có test hay ko thì mình ko rõ : ) ) Theo ý của bạn Hòa ( bên topic " Function_Not_Return " ) thì khi xét Function_Not_Return thì_phải tính xem những điều_kiện của loop , while và if có chắc_chắn đúng hay không . Hòa nói anh Hùng bảo làm nhưng có_vẻ như chỉ_bảo với 1 nhóm nhỏ chứ chưa phổ_biến cho toàn_thể sinh_viên . Mong anh Hùng làm rõ vấn_đề này giúp bọn em . Em cám_ơn . Re : File PT vẫn chưa tương_thích Thanh_Pham_Minh wrote : Các bạn thử lấy file PT mới test cái này ( của " nhan " bên topic kia ) : function main ( ) : string ; begin return ' a ' ; end ; sẽ được cây sinh_ra : Program ( List ( Func ( main , List ( ) , PrimitiveType ( string ) , Block ( List ( Return ( UnaryOp ( string , StringLit ( " ' a ' " ) ) ) ) ) ) ) ) = ) ) Tui ra y_chang Thành = ) ) Re : Scope của biến global ? ? ? Các bạn cứ dựa vào đặc_tả mà làm . Assignment 1 thầy cũng đã nói là code thầy ko hoàn_toàn đúng mà . Re : Scope của biến global ? ? ? H . T . P ( ^ _ ^ ) wrote : Spec ass 1 wrote : 2.5 . Example of a Crazy program var y , z : integer ; procedure main ( ) ; begin y : = 1 ; writeRealLn ( foo ( y ) ) ; end ; const x = 1.2e3 ; function foo ( p : integer ) : real ; begin return p * x ; end ; đã giải quyếtđược thắc_mắc . Hàm dùng trước khai_báo sauđược thì biến cũng thế . : ) Cẩn_thận cái này chỉ dành cho global thui nhé : ) Re : Element of array ! Ủa như_vậy tức_là chấp_nhận cú_pháp truy_cập phần_tử rỗng à ? Mình thấy trong đặc_tả đâu có phần_nào nói vậy đâu ? Re : Element of array ! À mấy bạn test thử test này xem function child 1 ( ) : real ; begin var child Share : real ; childShare : = 1 / 2 ; return child Share ; foo ( ' abc ' ) ; loop ( 5 ) do const a = 1 ; end ; Re : Element of array ! Tùy thôi . Vấn_đề này ko cãi nhau được đâu : - jRe : cac bạn Test cái này xem . Scala ^ ^ wrote : khi mà test cái này , mình để hàm show xuất ra result . toString thì thấy nó bắt lỗi ngay dấu ' bắt_đầu string trong array , tại array k nhận string . mấy bạn thử coi đi , theo tớ thì line 1 : 10 : unexpected token : ' mới đúng cho tớ hỏi thêm procedure main ( ) ; begin a : = not-not 5 ; end ; ra_gì ? mình ra [ proc ( main , [ ] , [ assign ( a , bnot ( bnot ( bnot ( 5 ) ) ) ) ] ) ] - ở đây 1 ngôi nên là bnot Mình nghĩ là vì cái ' a ' là một cái token hợp_lệ nên nó sẽ xuất ra ' a ' luôn.Thắc mắc điểm lab 5 Thầy cho em hỏi là bài lab 5 của em tại_sao lại bị 5 điểm vậy ạ ? MSSV của em là 50902263 . Em cám_ơn . Re : Điểm_Course _ Grade_Thầy cho em hỏi điểm của em tính ra là 7,09 làm_tròn đáng_ra phải là 7,1 chứ ạ . Ko hiểu sao điểm TB là 7 MSSV của em là 50902263Re : File kết_quả Assignment 2 Thầy cho em hỏi là bài của em được bao_nhiêu test bonus và test bắt_buộc luôn ạ . Em tên Đinh_Trần_Thái_Sơn MSSV : 50902263Re : tut1 Nhat_Nguyen wrote : Thanh_Pham_Minh wrote : Tương_tự cho mình hỏi , câu 5 . a : ( ab ) * ( ba ) * | aa * thì nghĩa_là ( ( ab ) * ( ba ) * ) | aa * hay ( ab ) * ( ( ba ) * | aa * ) theo mình nghĩ nó là ( ab ) * ( ( ba ) * | a ) a * mình lại nghĩ nó là ( ( ab ) * ( ba ) * ) | aa * chứ nhỉ ? Thấy nó in xa nhau vậy_mà : - ? Re : Testcase cho stage 2 / / Post nhầm ^ ^ . Đã xóa Re : Testcase cho stage 2 Mai_Hoa_Đạo wrote : Cho mình hỏi là xuất ra lỗi EOF hay vậy ? Cảm_ơn . <eof> Cannot_Assign_To_Constant_Anh_Hùng ơi cho em hỏi là trong phần này thì chỗ <statement> mình sẽ xuất ra theo nguyên_mẫu input hay xuất ra theo cây cú_pháp ạ ? Vd : const d = 10 ; var a : integer ; begin d : = a ; end ; Vậy_thì sẽ báo lỗi là : Cannot_Assign_To_Constant : d : = a hay_là Cannot_Assign_To_Constant : Assign ( Id ( d ) , Id ( a ) ) Em cảm_ơn . Re : biến có_thể khai_báo nằm sau câu_lệnh gọi nó được không ? Báo lỗi : Undeclared_Identifier : x Bạn_đọc kĩ đặc_tả có nói ở đây : The scope of a global variable : the entire program . The scope of a variable in a block ( i . e . , local variable ) : from the point where it is declared to the end of the block . Re : trong if mà có break và continue hay không ? A break / continue statement must be enclosed directly or indirectly in a loop statement ( i . e . , while or loop statement ) , otherwise the error message Như_vậy break và continue có_thể xuất_hiện trong if nếu if nằm trong while hoặc loop . Re : Function_Not_Return_Cái deadcode đó thì mình đã từng thấy trong Netbeans , còn Eclipse thì chưa . Mà hiện_thực như kiểu Netbeans thì ... . : - sFunction Not_Return vanhoa wrote : 1 > 0 vẫn là true : ) ) Thựcchấtstaticcheckcũngbaogồmnhữngcáinàynữa , tuỳvàongườiđịnhnghĩathôi , VDnhưmấycáiIDEjavađó , netbeans hoặc Eclipsechẳnghạn , nóvẫncheckmấycáiđóđó : D_Cái này a Hùng bảo làm chứ nếu_không thì ass này đơn_giản quá , còn có test hay ko thì mình ko rõ : ) ) Mới vừa code thử dòng này trong eclipse và kq là chẳng báo gì : | while ( true ) return ; return ; Re : hàm with Item ! Lập team 10 người hùn tiền lại thuê người comment dùm đi ; ) ) ai cứu với hix hix ... Quoc_Anh_Nguyen_Bui wrote : mình bị sai giải_thuật phần_nào ko bit , test tất_cả các function ... , đều báo lỗi ngay chính từ_khóa function , ... . Trả_lời trễ rồi nhưng có_thể do bạn quên thêm từ_khóa function vào trong list reserved Re : Eclipse hông tạo ra scala Project_Chọn_File - > New - > Project - > Scala_Wizard - > Scala_Project xong rồi Next rồi đặt tên project là ra được Scala project ( có chữ S nằm kế bên tên project ) . Còn lúc Run thì run file TestToken.scala vì hàm main nằm trong file đó mà . Re : Hỏi về 1 trường_hợp của real và cách ghi = regex trong scala . r có nghĩa_là cho cái String đó thành kiểu Regex đó . Ở trên có hàm regex ( r : Regex ) nên biến truyền vào phải là 1 kiểu regex . Cái chuỗi " ( [ a - z ] [ a-zA - Z] * ) " chỉ là một kiểu String thôi nên . r nữa nó mới thành kiểu Regex.Re : Hỏi về 1 trường_hợp của real và cách ghi = regex trong scala Peter-0989 wrote : Guest_User wrote : cho em hỏi kiểu thực có chấp_nhận số_thực âm không ? ví_dụ : - 1.02 có được chấp_nhận không Được chấp_nhận đấy bạn . giả_sử 1 số nguyên_âm nhân với 1 số_thực dương . kết_quả sẽ là 1 số_âm có kiểu thực Mình thấy trong đặc_tả đâu có nói phần sẽ có dấu " - " phía trước số_thực hoặc số_nguyên đâu . Anh Hùng ơi vô trả_lời dùm tụi em với . Re : Tên file cần nộp . Chắc do có vấn_đề nhầm_lẫn trong lúc gõ tên . Chắc thầy không bắt_bẻ mấy vụ này đâu : DHỏi về phần left HandSide trong đặc_tả Trong đặc_tả phần assignment có đoạn : var a : array [ 3 ] of integer ; a : = [ 2 ; 3 ; 4 ] ; a [ 1 ] : = 4 ; Theo em nghĩ chỗ này phải là const a : = a [ 2 ; 3 ; 4 ] hoặc là a : = a [ 2 ; 3 ; 4 ] chứ ạ . Anh Hung giải_đáp dùm em với . Re : Hỏi về phần left HandSide trong đặc_tả À mình đã hiểu . Đọc đề ko kĩ : d . Thanks bạn nha . Như_vậy thì a : = [ 2 ; 3 ; 4 +1 ] ; thì ko đc đúng ko ? Hỏi về break và continue Mấy bạn cho mình hỏi là trong phần statement lệnh break đặc_tả bảo là phải nằm trong loop hoặc while . Phần đó mình sẽ parse ở bước Parser này luôn hay qua bước sau vậy ? Nếu ở bước này thì bạn nào cho kquả giùm mình 2 vd này với : 1 . procedure child 2 ( a : array [ 1 ] of integer ) ; begin / / a [ 0 ] : = 2 ; loop ( 5 ) do break ; var a , b : integer ; end ; 2 . procedure child 2 ( a : array [ 1 ] of integer ) ; begin / / a [ 0 ] : = 2 ; loop ( 5 ) do begin a : = 5 ; break ; end var a , b : integer ; end ; Thanks all ^ ^ Re : Hỏi về break và continue Mình mới vừa làm được phần này . Cái này parse cũng được mà chứ nhỉ : - ? . Dù_sao cũng cám_ơn bạn : DRe : Hỏi về break và continue Ko . Cả 2 đều parse thành_công hết bạn : D 1 . [ proc ( child2 , [ par ( a , arr ( [ 1 ] , int ) ) ] , [ loop ( 5 , break ( null ) ) , var ( a , int ) , var ( b , int ) ] ) ] 2 . [ proc ( child2 , [ par ( a , arr ( [ 1 ] , int ) ) ] , [ loop ( 5 , [ assign ( a , 5 ) , break ( null ) ] ) , var ( a , int ) , var ( b , int ) ] ) ] Re : Hỏi về break và continue À mình nhầm . Cho mình đính_chính lại phần này ko kiểm_tra phạm_vi của break và continue nên cả 2 test case trên đều đúng . Luôn cả trường_hợp break và continue nằm ngoài loop và while cũng đúng . : D @ Tan_Phat : thầy Tân nói là không kt phạm_vi break và continuemột trường_hợp về hằng chuỗi Guest_User wrote : cho em hỏi test const x = ' ' ' ; kết_quả là gì const x = ' ' ' ' ' ' ' ' ; ra kết_quả là gì vậy Ủa sao cái trường_hợp đầu_tiên mình xuất ra lỗi một đống vậy ta : Exception in thread " main " java.util.NoSuchElementException : next on empty iterator at scala . collection.Iterator $ $ anon $ 3.next ( Iterator.scala : 28 ) at scala . collection.Iterator $ $ anon $ 3.next ( Iterator.scala : 26 ) at scala . collection.IndexedSeqLike $ Elements.next ( IndexedSeqLike.scala : 63 ) at scala . collection.IterableLike $ class.head ( IterableLike.scala : 90 ) at scala . collection.immutable.StringOps.scala $ collection $ IndexedSeqOptimized $ $ super $ head ( StringOps.scala : 31 ) at scala . collection.IndexedSeqOptimized $ class.head ( IndexedSeqOptimized.scala : 121 ) at scala . collection.immutable.StringOps.head ( StringOps.scala : 31 ) at CrazyParser $ $ anonfun $ const $ 4 $ $ anonfun $ apply $ 84.apply ( Crazy2011.scala : 294 ) at CrazyParser $ $ anonfun $ const $ 4 $ $ anonfun $ apply $ 84.apply ( Crazy2011.scala : 291 ) at scala . util.parsing.combinator.Parsers $ Success.map ( Parsers.scala : 108 ) at scala . util.parsing.combinator.Parsers $ Success.map ( Parsers.scala : 107 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1 $ $ anonfun $ apply $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1 $ $ anonfun $ apply $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Failure.append ( Parsers.scala : 163 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Success.flatMapWithNext ( Parsers.scala : 114 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1 $ $ anonfun $ apply $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1 $ $ anonfun $ apply $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Failure.append ( Parsers.scala : 163 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ $ anonfun $ rep1 $ 1.apply ( Parsers.scala : 602 ) at scala . util.parsing.combinator.Parsers $ $ anonfun $ rep1 $ 1.apply ( Parsers.scala : 588 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Success.flatMapWithNext ( Parsers.scala : 114 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Success.flatMapWithNext ( Parsers.scala : 114 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ flatMap $ 1.apply ( Parsers.scala : 201 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1 $ $ anonfun $ apply $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1 $ $ anonfun $ apply $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Failure.append ( Parsers.scala : 163 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ $ anonfun $ rep1 $ 1.apply ( Parsers.scala : 602 ) at scala . util.parsing.combinator.Parsers $ $ anonfun $ rep1 $ 1.apply ( Parsers.scala : 588 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ append $ 1.apply ( Parsers.scala : 210 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ Parser $ $ anonfun $ map $ 1.apply ( Parsers.scala : 204 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 3.apply ( Parsers.scala : 183 ) at scala . util.parsing.combinator.Parsers $ $ anon $ 2.apply ( Parsers.scala : 754 ) at CrazyParser.parse ( Crazy2011.scala : 113 ) at TestParser $ . main ( TestParser.scala : 17 ) at TestParser.main ( TestParser.scala ) Bạn nào biết chỉ mình với ~ ~ ~ một trường_hợp về hằng chuỗi Guest_User wrote : trường_hợp đầu mình giống bạn trên = ( ( một đống lỗi Mình đã tìm được lỗi . Đó là do phần xử_lí string mặc_định ở trong hàm const của thầy . Vô trong đó sửa xíu thì hết bị : D . KQ 2 test ra giống mấy bạn trên : DRe : IF_ESLE Bản_thân if ... then ... . else ... . đã chứa cái statement trong đó : if <expression> then <statement> else <statement> or if <expression> then <statement> nên bạn cứ thêm 1 statement vô đó còn chuyện nó có ; hay ko là do statement đó quyết_định . Re : IF_ESLE Cao_Đại wrote : lúc mình định_dạng if - else có_thể có trường_hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc_đơn k ... cái này đặc_tả k rõ gì cả Thực_chất 1 hay nhiều expression thì cũng_như nhau vì trong expression này có_thể chứa expression kia . Vài_Question mong mọi người giúp_đỡ ( rất gấp ) DoomAce wrote : Cảm_ơn bạn ! mình sơ_suất quá , vậy còn câu số 2 . Có ai biết cho mình vài ví_dụ với Minh cũng muốn hỏi thêm về trường_hợp break và continue , đặc_tả nói break , conti chỉ đc dùng trong statement của while _ do _ và loop _ do _ vậy trong trường_hợp như : while _ do if _ then begin break ; end ; có chấp_nhận ko ? vì break đúng là xảy_ra trong stmt của While nhưng nó lại break trong stmt của If nằm trong While ? Trong bước này chưa kiểm_tra phạm_vi của break với continue nên nằm đâu cũng đúng Vài_Question mong mọi người giúp_đỡ ( rất gấp ) DoomAce wrote : ^ ^ ^ Cảm_ơn bạn nhé ! Cái type về integer thì mình đã biết , nhưng ý mình muốn hỏi là trong đặc_tả phần 3 còn ghi thêm : The keyword integer is used to represent an integer type . Integer values can be operands of the following operators : div mod + - * / < < = > > = = <> ^ thì những cái đó dùng trong trường_hợp nào , bạn cho vài ví_dụ về nó với . tương_tự với real , bool , string , array Mấy cái này ở bước này hình_như chưa cần làm đâu bạn ơi . 1 số thắc_mắc Tay_Doc_Au_Duong_Phong wrote : Scala ^ ^ wrote : Trong quá_trình làm bài , em thấy có 1 số điểm mâu_thuẫn như sau : 1 . const array có chấp_nhận a [ ] không , theo như SPEC đặc_tả thì không , nhưng trong PT.scala thì cho_phép nó rỗng và xuất " " 2 . EleExprPT khi exprs = null thì nó trả về id , nên a [ ] : = thì parser trả về giống như a : = ; hay_là báo lỗi chỗ a [ ] 3 . var a : array [ 0 ] of integer ; Cái này thầy nói là parse đc trong 1 topic , nhưng trong đặc_tả nói cái dimen đó phải là số_nguyên dương . 4 . Trong phần statement lệnh break đặc_tả bảo là phải nằm trong loop hoặc while . ass1 này có hiện_thực không ? Cuối_cùng , cho em hỏi giai_đoạn này không cần check kiểu trong array mà parse được hết phải không thầy ? Những cái này rất nhìu bạn hỏi , mà theo như em đọc thì chưa có câu trả_lời chính_thức từ thầy . em tổng_hợp lại để dễ theo_dõi . mong nhận được câu trả_lời sớm của thầy . Bạn phải tự phân_biệt được việc_gì sẽ phải làm ở Parser . Thân ! Nếu nói tự phân_biệt thì ai cũng phân_biệt được nhưng ko phải ai cũng giống nhau : ) Re : 1 số thắc_mắc Xin trả_lời câu số 3 . Nguyên_văn của thầy : Vo_Thanh_Hung wrote : librastar wrote : 1 ) trường_hợp var x : array [ 0 ] of integer cũng sẽ parse thành_công phải ko ạ ? Parse thành_công Thầy đã nói vậy_thì cứ vậy_mà làm . Bám sát đề và thầy ; ) ) Bổ_sung câu 4 : Ở trong topic test case của bạn vanhoa thì mình tháy có 1 bạn nói là thầy Tân nói ko cần phải kiểm_tra phạm_vi của break và continue ở bước này . Trích : nguyen dung wrote : @ Tan_Phat : thầy Tân nói là không kt phạm_vi break và continue Re : String_Literal H . T . P ( ^ _ ^ ) wrote : vẫn chưa thấy có dấu_hiệu trả_lời . thôi_thì cứ làm theo đúng đặc_tả . Có j còn ý_kiến được . : D_Làm theo đặc_tả là làm_sao bạn ? Là dấu " thì dup lên 2 dấu " " còn 2 dấu ' ' thì giảm xuống còn 1 ' hả ? Re : access Array_Element ? ? ? ? Theo mình là được vì expression có chứa const mà const thì chứa tất ; ) ) Hỏi về các hàm NumericLit , Boolean , FloatLit , processIdent , . . Anh Hùng cho em hỏi là trong file Crazy2011.scala em có thấy các hàm NumericLit và process Ident được nối với các regex ( " [ a - z ] [ a-zA - Z] * " . r ) và regex ( " 0 | [ 1-9 ] [ 0 - 9 ] * " . r ) thì em tạm hiểu là xử_lí chuỗi và xử_lí số_nguyên . Vậy còn các hàm BooleanLit và FloatLit được định_nghĩa phía trên thì_sao ạ ? Lúc em xử_lí chuỗi " true " , " false " như sau regex ( " true | false " . r ) ^ ^ { Boolean ( _ ) } thì khi chạy thì lại xuất ra màn_hình " identifier true " và " identifier false " . Cho em hỏi như_vậy có đúng không ạ ? Và mình có cần chỉnh_sửa gì các hàm BooleanLit hay FloatLit ko ? Em cám_ơn . Re : Thắc_mắc về delimiter Nếu_mà ' là delimiters ( được để trong list delimiters ) thì khi chạy sẽ xuất ra ` ' ' Mà anh Hùng đã nói là Vo_Thanh_Hung wrote : Dấu ' là 1 token hay không phải ( ErrorToken ) Có_nghĩa là nếu để trong delimiters tức_là nó sẽ là token ( không xuất ra ErrorToken ) còn ngược_lại thì xuất ra ErrorToken . Mình nghĩ vậy . Không biết các bạn khác nghĩ sao . hỏi về sol của vài case axe wrote : Cho em hỏi là sol của mấy case này đúng không : 1 / 015.34 0 | ErrorToken 15 | . 34 hay ErrorToken 015 | . 34 2 / 000.15 000.15 hay 0 | ErrorToken 00 | . 15 3 / 0015.2 0 | ErrorToken 015 | . 2 hay 00 | ErrorToken 15 | . 2 hay ErrorToken 0015 | . 2 4 / 1.100e6 1.1 | ErrorToken 00 | e6 hay 1 | ErrorToken . 100 | e6 5 / 1.2e001 1.2 | ErrorToken e001 hay 1.2e | ErrorToken 001 6 / 0e2 ? ? ? 7 / 00.000e4 ? ? ? Ủa 0e2 hợp_lệ mà bạn Re : Testcase_Trong result của bạn có dòng ErrorToken ' Trong cái list delimiters có dấu ' mà bạn , sao lại báo cái đó là ErrorToken nhỉ ? Re : Testcase_Nhưng trong code mẫu down về thì_có . Không biết thực_hư ra_sao nữa . Thôi_thì đành chờ anh Hùng vô giải_quyết vậy : DTestcase vanhoa wrote : Các bạn thử test này nhé : ) http : / / www.vhn.vn/u/tes.zip Sau khi test xong test 9.my.txt thì_có 1 số chỗ mình khác với Văn_Hòa sau đây : 1 / true và false là 1 keyword nên sẽ xuất ra là ` true ' hay ` false ' ( cái này có ở tbên trang 1 dòng thứ 3 từ dưới lên ) 2/0.01 vẫn là một kiểu real hợp_lệ nên sẽ ra là Code : 0.01 chứ ko fải là 0.0 1 tương_tự với 1.01 , v . . v . v 3/Chắc Hòa chưa đọc Notice nên chưa biết là ví_dụ . 3e-30 trong ví_dụ là ví_dụ đúng . Vì_vậy . 0e-10 , . 0e10 đều là hợp_lệ ( kiểu real ) . Mình ra là . 0e-10 . 0e10 còn Hòa ra là . 0 identifier e 10 Mà hình_như test của Hòa chỉ ra tới var Const1974 thôi_thì phải : - ? Không biết có bạn nào ra giống mình không ? Re : Testcase vanhoa wrote : Uh mình quên xét độ ưu_tiên , bạn tải lại kiểm_tra nhé . OK đã test . Same : ) . Chỉ còn thắc_mắc mỗi cái dấu ' . Anh Hùng ơi vô trả_lời tụi em với . Re : Testcase_Nếu mà ' là delimiters ( được để trong list delimiters ) thì khi chạy sẽ xuất ra ` ' ' Mà anh Hùng đã nói là Vo_Thanh_Hung wrote : Dấu ' là 1 token hay không phải ( ErrorToken ) Có_nghĩa là nếu để trong delimiters tức_là nó sẽ là token ( không xuất ra ErrorToken ) còn ngược_lại thì xuất ra ErrorToken . Mình nghĩ vậy . Không biết các bạn khác nghĩ sao .
