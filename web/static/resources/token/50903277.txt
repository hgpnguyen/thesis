Re : Nộp bài cho_rồi OK đồng_ý . Mình cũng nộp bài luôn đây . Ngày_mai con đi GSC nữa.Re : Scope của biến global ? ? ? nhan nguyen van wrote : Most closed nested rule : For every applied occurrence ( i . e . , use ) of an identifier I in a block A , there must be a corresponding declaration of I . The declaration is in a block that is smallest enclosing the applied occurrence of I . Due to the above rule , the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block . = Tầm vực của một định_nghĩa không bao_gồm tầm vực của định_nghĩa khác cùng tên bên trong một block . Ví_dụ : function demo ( ) : real ; begin return 0 ; end ; procedure main ( ) ; begin var demo : real ; = > Chổ này không thấy hàm demo nữa . end ; Chỗ này bạn giải_thích rất đúng , mình cũng có cùng cách hiểu như_vậy là hàm demo sẽ bị che = > báo lỗi Re : GradeBook Mid_Term_Họ tên : Phạm_Quốc_Việt MSSV : 50903277Re : Element of array ! line 7 : 14 : unexpected token : ` const ' Cac ban oi vay la van chua xac dinh duoc la truy xuat phan tu mang rong hay khong rong a ` . Re : Element of array ! T . D . N wrote : Mai_Hoa_Đạo wrote : line 7 : 14 : unexpected token : ` const ' Cac ban oi vay la van chua xac dinh duoc la truy xuat phan tu mang rong hay khong rong a ` . Bạn phải bỏ 2 cái dấu ở 2 đầu chứ . Trong phần notice có ví_dụ tương_tự cho kí_tự ] mà ( ` ] ' bỏ 2 dấu ở 2 đầu thành ] ) Mai_Hoa_Đạo wrote : Mình cũng dùng if - else để thể_hiện nhưng_mà không hiểu bị lỗi gì . Nếu chỉ if rồi else thì không có lỗi . Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là " type missmatch ; found : Unit required : String " . Các bạn giúp mình với . Hix . Mình vẫn chưa sửa được lỗi này . Hiện_tại mình chỉ xài dc có 1 cặp if - else nên chưa thể_hiện dc hết lỗi . Re : Element of array ! line 7 : 14 : unexpected token : const Mừng quá ! Mình làm được rồi . Cảm_ơn bạn @ T . N . D nhiều lắm . Thì_ra Scala cũng crazy không kém . ^ ^ Re : Các bạn cho mình hỏi về cái def Show tý nhé ! Qui_Pham_Xuan wrote : Gợi_ý tí : Cái def show bạn dựa vào hàm clean ( ) trong TestToken ấy . Để in token thì dùng next . first ... . . nhé ! ! ! Ở đây có thểdùng if ... else ... sẽ ra đúng theo mọi trường_hợp báo lỗi theo yêu_cầu đề . Good luck ! ! ! Mình cũng dùng if - else để thể_hiện nhưng_mà không hiểu bị lỗi gì . Nếu chỉ if rồi else thì không có lỗi . Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là " type missmatch ; found : Unit required : String " . Các bạn giúp mình với . Re : 1 thắc_mắc cần đính_chính ! [ proc ( a , [ ] , [ assign ( a , ele ( b , [ add ( 1,2 ) , ele ( c , [ 2 ] ) ] ) ) ] ) ] Re : cac bạn Test cái này xem . [ var ( y , int ) , var ( z , int ) , proc ( main , [ ] , [ assign ( y , 1 ) , call ( writeRealLn , [ call ( foo , [ y ] ) ] ) ] ) , const ( x , 1.2e3 ) , func ( foo , [ par ( p , int ) ] , float , [ return ( times ( p , x ) ) ] ) ] Re : cac bạn Test cái này xem . theo mình hiểu là : writeRealLn ( foo ( y ) ) ; là một procedure . Và chỗ này là một lời gọi hàm ( CallStmtPT ) Re : cac bạn Test cái này xem . thêm 1 test nữa các cậu ra ntn vậy ? var a : array [ 5 ] of integer ; / / global variable procedure fill ( x : array [ 5 ] of integer ) ; begin var a : real ; var x : real ; a : = 5.9 ; init ( x ) ; end ; procedure init ( x : array [ 5 ] of integer ) ; begin var i : integer ; / / block variable i : = 0 ; x [ i ] : = a [ i ] ; / / a is global var . end ; procedure main ( ) ; begin fill ( a ) ; end ; của tớ nó ra line 13 : 3 : unexpected token : i trong kai ass này mình có làm cái golbal vs kai block ko mấy cậu ? ? ? ? còn chổ where <lefthandside> is a variable or an element of an array vậy an element of an array nó cho kiểu INT thôi đúng ko ? hay còn chấp_nhận kiểu String nữa ? ? ? Re : cac bạn Test cái này xem . [ var ( a , arr ( [ 5 ] , int ) ) , proc ( fill , [ par ( x , arr ( [ 5 ] , int ) ) ] , [ var ( a , float ) , var ( x , float ) , assign ( a , 5.9 ) , call ( init , [ x ] ) ] ) , proc ( init , [ par ( x , arr ( [ 5 ] , int ) ) ] , [ var ( i , int ) , assign ( i , 0 ) , assign ( ele ( x , [ i ] ) , ele ( a , [ i ] ) ) ] ) , proc ( main , [ ] , [ call ( fill , [ a ] ) ] ) ] cái i đó là 1 expr ( variable ) đó bạn , ko phải String đâu . x [ i ] và a [ i ] là element nên ko lỗi j cả . cái element nó định_nghĩa chỗ toán_tử [ ] đó bạn Re : cac bạn Test cái này xem . [ var ( a , arr ( [ 5 ] , int ) ) , proc ( fill , [ par ( x , arr ( [ 5 ] , int ) ) ] , [ var ( a , float ) , var ( x , float ) , assign ( a , 5.9 ) , call ( init , [ x ] ) ] ) , proc ( init , [ par ( x , arr ( [ 5 ] , int ) ) ] , [ var ( i , int ) , assign ( i , 0 ) , assign ( ele ( x , [ i ] ) , ele ( a , [ i ] ) ) ] ) , proc ( main , [ ] , [ call ( fill , [ a ] ) ] ) ] Re : cac bạn Test cái này xem . uh.đúng rồi ... mìh mới check lại : D ... cho_phép NullRe : cac bạn Test cái này xem . thêm 1 test nào : D : D : procedure init ( x : array [ 5 ] of integer ) ; begin var i : integer ; / / block variable i : = 0 ; x [ true ] : = a [ i ] ; / / a is global var . end ; Điểm_Course _ Grade_Thưa thầy Tân_Em là Phạm_Quốc_Việt MSSV : 50903277 Sau khi em tự tính điểm từ các thành_phần của em xong thì được 7.29 . Nhưng_mà trong Course _ Grade của thầy em chỉ được 7.2 . Vậy có phải điểm trên AAO của em sẽ bị giảm xuống còn 7.0 không vậy thầy . Nếu thật như_vậy thì em hơi buồn vì 7.29 rất gần với 7.3 . Mong thầy xem_xét . Em cảm_ơn thầy . Trường_hợp break và continue Thầy_Hưng ơi tuy thầy nói trong assignment 1 này chưa xét đến break và continue không dc nằm ngoài loop và while . Nhưng nếu em đã hiện_thực luôn thì_có tính là bị sai không vậy thầy . Trong trường_hợp này em mong là testcase sẽ né đc mâu_thuẫn này . input : procedure main ( ) ; begin while 1 do begin end break ; end ; output [ proc ( main , [ ] , [ while ( 1 , [ ] ) , break ( null ) ] ) ] hoặc line 4 : 2 : unexpected token : breakRe : Trường_hợp break và continue Còn một trường_hợp chưa thống_nhất nữa_là truy_xuất mảng rỗng Khi khai_báo mãng rỗng thì chắc_chắn là sai , nhưng khi truy_xuất mảng rỗng thì_có một_số bạn truy_xuất dc va một_số bạn không truy_xuất dc . input procedure main ( ) ; begin a [ ] : = 0 ; end ; output [ proc ( main , [ ] , [ assign ( a , 0 ) ] ) ] hoặc line 3 : 4 : unexpected token : ] Re : Trường_hợp break và continue Mong thầy thống_nhất lại hoặc testcase sẽ không rơi vào các trường_hợp trên . Cảm_ơn thầy . Re : định_nghĩa path of the execution of the function ? Mình có một_cách hiểu về execution path như_thế_này muốn chia_sẻ cùng bạn : - execution path là đường thực_thi của chương_trình mà từ lúc chương_trình bắt_đầu đi vào và cho_đến khi đi hết đường thực_thi đó thì cũng là lúc kết_thúc chương_trình . Trong một chương_trình thì có_thể có một hoặc nhiều execution path . vd : - Các execution path này đôi_khi chồng_lấn lẫn nhau ở một_số bộ_phận . function example ( a : integer ) : real ; begin var x : integer ; x : = 3 ; if ( ( a + x ) > 10 ) then a : = 0 ; else a : = 1 ; loop ( a ) do begin a : = 0 ; return a ; end return a ; end ; - Đôi_khi phân_định rõ_ràng function example ( a : real ) : real ; begin if ( a > 3 ) then return 0 ; else return 1 end ; Re : định_nghĩa path of the execution of the function ? có 1 đường bạn . Đường vào là if ... . , sau khi hết đường đó thì cũng là lúc kết_thúc hàm func . Re : Testcase cho stage 2 vd : = not not not not 4 ; Các bạn cho mình hỏi xài not như_vậy là not có kết_hợp phải rồi phải không . Nhưng ma trong đề thì mình thấy not không có kêt hợp nào cả . Có phải nên sửa lại là : vd : = not ( not ( not ( not 4 ) ) ) ; Re : Testcase cho stage 2 Bạn @ vanhoa ơi cho mình hỏi link ở đầu topic là testcase + testsolution mới nhất phải không bạn Re : Testcase cho stage 2 Mình làm theo trường_hợp truy_xuất mãng rỗng dc vì trong EleExprPT thì exprs : List [ ExprPT ] có_thể null dc . Và các phần_tử trong List [ ExprPT ] thì không_thể null dc , nhưng_mà List [ ExprPT ] thì có_thể null dc . Re : Testcase cho stage 2 Các bạn ơi cho mình hỏi input : const g = true ; thì kết_quả là : const ( g , true ) hay const ( g , ' true ' ) Cảm_ơn Re : Testcase cho stage 2 Tran_Quoc_Anh wrote : Mai_Hoa_Đạo wrote : Các bạn ơi cho mình hỏi input : const g = true ; thì kết_quả là : const ( g , true ) hay const ( g , ' true ' ) Cảm_ơn Theo test case của thầy thì_là const ( g , true ) Cam on ban Re : Testcase cho stage 2 Cho mình hỏi là xuất ra lỗi EOF hay <eof> vậy ? Cảm_ơn . Re : Testcase cho stage 2 procedure main ( ) ; begin a [ ] : = 0 ; end ; Testcase 31 . Hòa ơi bạn làm theo trường_hợp ko truy_xuất mãng rỗng dc hả . Trường_hợp này mình parse dc vì mình thấy trong EleExprPT cho_phép List [ ExprPT ] null . Và mình xem như a [ ] là a vậy . Result của mình : [ proc ( main , [ ] , [ assign ( a , 0 ) ] ) ] Trong notice thầy chỉ nói ra trường_hợp ko dc khai_báo mảng rỗng thôi . var a : array [ ] of real ; = > line 1 : 15 : unexpected token : ] Re : Testcase_Kid wrote : Mai_Hoa_Đạo wrote : Test 27 : mình nghĩ ( 1 < 1.0 ) vẫn so_sánh được mà . Luật cùng kiểu chỉ có tác_dụng trong phép gán thôi mà , sao lại báo lỗi nhỉ ? integer và real đúng là dc phép sử_dụng phép < , tuy_nhiên chúng phải cùng kiểu . ví_dụ 1 < 2 hoặc 1.2 < 2.1 However , for + - * / , their operands can be in mixed types : integer and real . ( trích đặc_tả ass 1 ) Cảm_ơn bạn nhưng sau khi tui xem_lại Crazy spec thì phát_hiện ra rằng không có sự so_sánh bằng " = " cho kiểu real . Nghĩa_là kiểu real sẽ không_bao_giờ được đem đi so_sánh " = " . Re : Testcase / / sorry deleted Hội những người Crazy . Sau_Assignment 2 kì này , bạn nào bị assignment làm cho crazy thì vào đây bùng_nổ tâm_sự cùng_với mọi người nhé . Bản_thân mình thì thật_sự bị crazy rồi , làm xong rồi sửa , sửa xong rồi làm lại , làm lại rồi lại sửa , cứ_thế như một vòng lạp while ( true ) do sửa vậy . Quả_thật đúng như tên gọi của nó . Chỉ còn vài tiếng nữa thôi là chúng_ta đc giải_thoát rồi . Cuối_cùng chúc các bạn sẽ gặt_hái được thật nhiều testcase nhé . Hội những người Crazy . M . U . wrote : vậy bạn có file main . scala để test trên cywin ko , chia_sẻ mình với , mình đã đánh_liều nộp đại luôn , chua test dc thế_nào trên cywin nữa ... sorry bạn , mình cũng không có test tren cygwin nên không có . Chắc không sao đâu , bạn yên_tâm đi . Re : Testcase cuối_cùng . zz Chỗ này cố_tình bẫy cái def show đây mà . procedure the LastTest ( henxui : boolean ) ; begin ' identifier ab ' ; end ; Re : Testcase cuối_cùng . assignment kì này sôi_nổi quá nhỉ . Số_lượng topic đến hơn 1000 . Bây_giờ thì mọi người dc nghỉ_ngơi rồi . Gấp gấp : : Mấy bạn cho hỏi trường_hợp này Parse dc ko mấy bạn ! ! ! M . U . wrote : function test Struct ( ) : boolean ; begin loop 1 do begin a : = 1 ; b : = 2 ; break ; end ; end ; procedure main ( ) ; begin fill ( a ) ; end ; line 7 : 4 : unexpected token : ; M . U . wrote : var a : integer ; ; line 1 : 15 : unexpected token : ; Re : Testcase cuối_cùng . Sao mình resubmit quá_trời mà cái này ko có gì thay_đổi nhỉ . Number of resubmissions allowed : 10Khai báo đè Các bạn ơi trong cái block thứ 2 có phải là x đã bị đè rồi không ? procedure main ( ) ; begin var x : integer ; begin const x = 3 ; end ; end ; Re : Khai_báo đè Cảm_ơn bạn Re : Type ! ! ! ! line 9 : 8 : unexpected token : = Size_Must_Be_Integer_Các bạn ơi trong đặc_tả không có nói đến thông_báo lỗi này : Size_Must_Be_Integer_Mà lỗi này mình nghĩ nó nằm trong phần Expression vậy mình có nên sửa lại thành : Type_Missmatch_In_Expression hay vẫn giữ nguyên như của thầy . Re : Size_Must_Be_Integer àh thì_ra là vậy . Cảm_ơn bạn Re : câu_lệnh Return_Đúng thật_là assignment 2 spec ko có nói_gì đến string hay array . Mình cũng có một lỗi không biết là do PT.scala hay code của mình nữa , có ai gặp lỗi này như mình chưa ? procedure main ( a : string ) ; begin a : = ' maihoadao ' ; end Cứ mỗi lần mình gán một biến string thì chương_trình hoàn_toàn không chạy được . Ngay cả AST cũng chưa được sinh_ra . Re : câu_lệnh Return_Mình có một_cách hiểu câu_lệnh return như_thế_này : Cũng giống như break và continue phải nằm loop và while vậy , return phải nằm trong một function nào_đó . Tuy đặc_tả không nói , nhưng mình thấy return cũng có họ_hàng bà_con xa với break và continue vậy . ^ ^ Re : câu_lệnh Return_Kid wrote : @ mai hoa dao : bạn dùng ass 1 để parser hả ? sửa lại chỗ string thêm dấu " vào đầu và cuối chuỗi thử . mình sửa lại vậy và chạy dc Cảm_ơn bạn @ Kid . Cuối_cùng nó đã chạy được . Re : Thứ_tự kiểm_tra procedure please TellMeWhy ( ) ; / / ( 1 ) begin h : = true ; var h : boolean ; end ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - procedure please TellMeWhy ( ) ; / / ( 2 ) begin var h : real ; h : = true ; var h : boolean ; end ; Type_Mismatch_In_Statement : assign ( h , true ) hay_là RedeclaredVariable : h Mình có một mâu_thuẫn là : ( 1 ) thì chắc_chắn không báo lỗi . Vì trước khi kiểm_tra phép gán StaticCheck sẽ tìm xem biến h đã được khai_báo hay chưa . Nếu chưa thì báo lỗi : Undeclared_Identifier : h ( 2 ) Nếu theo như cách StaticCheck kiểm_tra trong đoạn chương_trình ( 1 ) của mình ở trên . Thì ( 2 ) sẽ báo lỗi : Redeclared_Variable : h Cuối_cùng ý mình muốn nói là khi vào kiểm_tra một block thì điều đầu_tiên là StaticCheck sẽ làm là kiểm_tra các khai_báo rồi xem chúng có bị Redeclared hay không , sau đó mới kiểm_tra các statement . Hay_là StaticCheck kiểm_tra lỗi từ trên xuống , thấy chỗ nào_là bụp chỗ đó liền . Re : Thứ_tự kiểm_tra Còn trường_hợp này thì_sao ? procedure why ( ) ; begin var a : array [ 3,3,3 ] of integer ; a [ 1,8,1 ] : = c end ; = > Undeclared_Identifier : <> hay Type_Missmatch_In_Statement : <> Re : Thứ_tự kiểm_tra Mình hiều nhầm biến h là local var chứ không phải global var . ^ ^ Re : Thứ_tự kiểm_tra Assignment này nhiều mâu_thuẫn quá . Ngay cả trong gin code của thầy cũng đã có mâu_thuẫn . Cách thầy check Unique trong Program thì đi từ trên xuống , chỗ nào Redeclared thì bụp chỗ đó liền . Còn khi check Unique trong Function hoặc Procedure thì thầy lại gom các Var lại rồi check 1 lần sau đó thì mới check đến các phần trong block . ... checkUnique ( paramSymbols2 + + varConstSyms ( getVarConst ( body.body ) , symbols ) ) checkBlock ( body , paramSymbols2 + + symbols , false ) ... Re : định_dạng output ! Type_Missmatch_In_Statement : if ( 1 , [ var ( a , string ) , assign ( a , " ' ass ' " ) ] ) Re : string trong Assign ? Lúc đầu mình nghĩ là string thì_phải tự hiểu mà thêm vào . Giờ nghe các bạn nói vậy nghĩa_là nếu mình hiện_thực điều mình nghĩ là hợp_lý thì thật_ra nó là điều vô_lý trong Crazy à ? Re : Kiểu của Parameter ? ? ? Trong trường_hợp này kiểu string vẫn không được chấp_nhận đâu bạn . Theo mình thì kiểu string chẳng có tác_dụng gì cả ngoài làm cảnh ( không gán được , không truyền tham_số được ) . file PT.scala Xin_lỗi mọi người nếu_như câu_hỏi của mình là spam . Thầy nói là đã up file PT.scala đã được chỉnh_sửa lên lâu rồi . Nhưng thực_sự mình đã tìm khắp trong mục Assignment , Module và trong Discussion rồi mà vẫn không thấy . Bạn nào biết thầy đã up ở đâu xin chỉ giúp mình , mình đang cần cái PT.scala đó để test . Xin cảm_ơn . Re : file PT.scala Cảm_ơn bạn Vắng TA Trong assignment này còn nhiều mâu_thuẫn đang chờ thầy giải_quyết . Nhưng sao gần đến deadline rồi mà vẫn không thấy thầy trả_lời . Mong thầy sẽ sớm xuất_hiện để giải_quyết các mâu_thuẫn của chúng_em . Re : Return statement ! Một function phải có ít_nhất một return trong các execution path . Nhưng một return không bắt_buộc phải nằm trong 1 function . Vì_vậy không báo lỗi . Re : khai_báo a : array [ 4 ] - - > gọi a [ 1000 ] Lỗi hay k ? same size of each dimension = > báo lỗi bạn . Re : khai_báo a : array [ 4 ] - - > gọi a [ 1000 ] Lỗi hay k ? Cảm_ơn các bạn . Do mình hiểu sai đặc_tả nên làm_vậy . Thanks mọi người Re : Function_Not_Return_Thưa thầy Hưng chúng_em cần thầy xác_nhận vấn_đề này : Nếu return không nằm trong 1 function nào_đó thì : 1 . Báo lỗi : Type_Missmatch_In_Statement : <statement> 2 . Báo lỗi : Return_Must_Be_In_Function 3 . Bỏ_qua , không kiểm_tra . Hỏi về Array_Constant_Van_Persie wrote : còn trường_hợp [ [ 1 ; 2 ] ; 3 ; true ] có parse thành_công không ? và nếu em xử_lý chuỗi đó luôn ( báo lỗi ) thì_có bị sai không ? Em cung co cung cau hoi nhu ban nay . Re : Mấy bạn cho mình hỏi lỗi này Vấn_đề 2 của bạn có một_số mâu_thuẫn : 1 . Hàm mũ là kết_hợp phải , mà bạn để kết_hợp trái do phép lặp ở bên phải = > đem lặp qua bên trái expr 2 . case a ~ lst = > ( a : \ lst ) = > case lst ~ a = > ( lst : \ a ) 3 . case ( x , " ^ " ~ y ) = > new ExponentExprPT ( x , y ) = > case ( x ~ " ^ " , y ) = > new ExponentExprPT ( x , y ) Bạn thử xem sao . Re : Mấy bạn cho mình hỏi lỗi này case a ~ lst = > ( a : \ lst ) = > case lst ~ a = > ( lst : \ a ) 3.Re : Hỏi về break và continue @ Tan_Phat : thầy Tân nói là không kt phạm_vi break và continue Re : Vài_Question mong mọi người giúp_đỡ ( rất gấp ) Guest_User wrote : Moi nguoi giup minh voi , khi minh khai bao : const a = [ ; ( noi chung la rerserved word hay delimiters ) thi deu parse thanh cong . Minh khong hieu sao nua ! ! ! Đây là phần khai_báo const . Mình thấy đến chỗ dấu [ mà bạn vẫn parse dc , thì mình nghi là do cách parse array Literal của bạn . Bạn kiểm_tra lại cách bạn nhận_dạng array Literal . Đây là cách nhận_dạng của mình : ( " [ " ~ > lstliteral < ~ " ] " ) Trong đó lstliteral là một danh_sách List [ LiteralPT ] . Các_Literal PT trong danh_sách đó gồm có : intLiteral | realLiteral | stringLiteral | boolLiteral | arrayLiteral Good luck ! 1 số thắc_mắc Em yêu Scala ♥ ♥ ♥ wrote : Nếu nói tự phân_biệt thì ai cũng phân_biệt được nhưng ko phải ai cũng giống nhau : ) Like 1 + Re : 1 số thắc_mắc Thanh_Pham_Minh wrote : A program in Crazy consists of many declarations which are variable , constant , procedure and function declarations . Nếu_không có hoặc chỉ có một declaration thì_sao ? : D_Trường hợp chỉ có một declaration : có test mẫu và đáp_án mẫu rồi = > không cần lo . Trường_hợp không có gì cả ( file input trống_trơn ) : theo mình nên để parse được . Output là [ ] . Vì nếu đáp_án là không parse được thì đáp_án đó mâu_thuẫn với test mẫu rồi . Đồng_ý với bạn . Với input trống_trơn thì mình ra output là : [ ] Re : String_Literal_Em cung co thac mac ve string Literal nhu tren Re : access Array_Element ? ? ? ? line 3 : 15 : unexpected token : [
