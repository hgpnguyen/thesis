Testcase cho stage 2 Bước này chưa kt kiểu . Testcase cho stage 2 Download : http : / / www.vhn.vn/u/tesS2.zip [ update 07/11/2011 ] Code gen output : Code : import scala . io.Source
import java . io.FileWriter
object TestParser {
/ / - | not | and | or | > | > = | < | < = | <> | = = | * | / | div | mod | + | - | ^
def main ( args : Array [ String ] ) : Unit = {
( 11 to 27 ) . foreach ( testNC ( _ ) )
}
def pretty Print ( s : String ) = {
var sp = " "
var sc = 0
var ln = 1
var stack : List [ Int ] = List ( )
( " % 4d | % 4d | % 4d : " . format ( 0,0,0 ) / : s.toCharArray ( ) ) {
( r : String , c : Char ) = > {
r + ( c match {
case ' , ' = > ln + = 1 ; c + " \ n " + " % 4d | % 4d | % 4d : " . format ( ln , sc , stack.head ) + sp
case ' ( ' = > sp = sp + " " ; sc + = 1 ; stack = ln : : stack ; c / / + sp
case ' ) ' = > sp = sp.substring ( 0 , sp.length ( ) - 2 ) ; sc - = 1 ; stack = stack.tail ; c / / + sp
case ' [ ' = > sp = sp + " " ; sc + = 1 ; stack = ln : : stack ; c / / + sp
case ' ] ' = > sp = sp.substring ( 0 , sp.length ( ) - 2 ) ; sc - = 1 ; stack = stack.tail ; c / / + sp
case c = > c
} )
}
}
}
def test NC ( no : Integer ) : Unit = {
val input File = " desc/testcase/test " + no + " . my.txt "
println ( " # # # # # # # # # # # # Process [ [ " + inputFile + " ] ] # # # # # # # # # # # # # # # " ) ;
val lines = Source.fromFile ( inputFile ) . getLines
val input = if ( ! lines.isEmpty ) lines.reduceLeft [ String ] ( _ + ' \ n ' + _ ) else " "
val parser = new CrazyParser
val result = parser.parse ( input )
var res = parser.show ( result ) ;
/ / println ( " _ _ _ _ _ _ _ Result : " + res ) ;
/ / println ( " _ _ _ _ _ _ _ Result : " + prettyPrint ( res ) ) ;
var out Put = new FileWriter ( inputFile.replace ( " testcase " , " testsol " ) . replace ( " txt " , " pt " ) )
outPut.write ( res + " \ n " )
outPut.close ( ) ;
outPut = new FileWriter ( inputFile.replace ( " testcase " , " testsol " ) . replace ( " txt " , " pretty.pt " ) )
outPut.write (
( result match {
case parser . Failure ( msg , next ) = >
" line " + next.pos.line + " : " + next.pos.column + " : unexpected token : " + parser.clean ( next.first )
case _ = > prettyPrint ( result.get.toString )
} ) + " \ n " )
outPut.close ( ) ;
}
def test ( no : Integer ) : Unit = {
val input File = " desc/testcase/test " + no + " . txt "
println ( " # # # # # # # # # # # # Process [ [ " + inputFile + " ] ] # # # # # # # # # # # # # # # " ) ;
val lines = Source.fromFile ( inputFile ) . getLines
val input = if ( ! lines.isEmpty ) lines.reduceLeft [ String ] ( _ + ' \ n ' + _ ) else " "
val parser = new CrazyParser
val result = parser.parse ( input )
var in 2 = inputFile.replace ( " testcase " , " testsol " ) . replace ( " txt " , " pt " )
var res = parser.show ( result ) ;
println ( " _ _ _ _ _ _ _ Result : " + res ) ;
print ( " Correct_Result : " ) ;
val Cresult = Source.fromFile ( in2 ) . getLines.foreach ( println ( _ ) )
}
} Để kiểm_tra bằng file pretty , các bạn có_thể dùng diff . Testcase cho stage 2 A_Hùng xem giúp e test 25 xem e hiểu đúng ko nhé . Code : procedure main ( ) ;
begin
while 1 do begin end
break ;
end ; Cái này break nằm ngoài while nên sẽ báo lỗi ? Testcase cho stage 2 Mình nghĩ h chưa cần kt type : - ? Testcase cho stage 2 Thì nó chỉ là ( 1 - ( - 2 ) ) - ( - ( - ( - ( - 4 ) ) ) ) thôi : ) Testcase cho stage 2 @ cong thanh : hien tai minh chua kiem tra cai do ban . @ Long : Ủa có test nào mình xuất cái đó ah ? Testcase cho stage 2 Ý mình là ở bước này chưa cần kiểm_tra kiểu Testcase cho stage 2 Ok thx bạn : ) Mình nhỡ cho opt vào cái dấu ngoặc nên var thành call hết : D mình update ở link cũ rồi . Testcase cho stage 2 - là sub đó bạn Testcase cho stage 2 Mình cập_nhật result ở đầu_bài rồi đó . Re : Testcase cho stage 2 ah lúc nãy mình chưa rename , bạn tải lại đi : ) Testcase cho stage 2 Đúng là thầy có cho_phép cái list kia là null , nhưng mình nghĩ vậy_thì nó lại ko có ý_nghĩa gì cả ( a [ ] và a là một thì tại_sao lại phải dùng a [ ] ? ) , nên hoặc là test của thầy sẽ ko có trường_hợp này hoặc là thầy sẽ ghi rõ_ràng trong đặc_tả ngôn_ngữ . File đặc_tả khá đơn_giản , nên mình chỉ nên đơn_giản làm theo thôi . Còn nếu bạn muốn có cơ_sở , mình nghĩ câu đặc_tả này cũng đủ rồi : Brackets ( array subscript to access array element ) a là array , a [ ... ] là array element , vậy_thì a [ ] là một array element thì cũng là bản_thân array luôn ? Re : Testcase nguyen dung wrote : Test # 84 varx : integer ; proceduremain ( ) ; begin while ( 1 > x ) do begin varz : real ; begin break ; end z : = 1 ; z : = z ; / / ( 1 ) end end ; z nằm sau break vậy phép gán z : = 1 ; có tính không ? Mình ra Not_Defined_Before_Used : z Khôngcólỗibạn.Testcase Mình vừa cập_nhật lại các test short circuit . Testcase_Uh giờ các test mình không đúng nữa đâu , giờ mình cũng chán rồi , sẽ không sửa gì nữa , các bạn chỉ nên tham_khảo các test ngoài bonus : ) Testcase_Mình vừa update lại một_số test cũ . @ TDD : - integer - > integer - real - > realTestcase 83 thì func được khai_báo ở block trong của hàm , 76 thì không . Testcase_Test 52 làm_gì có 2 nhánh.Testcase Mình đã update lại các test case và thêm một_số test case mới . Testcase_Uh lâu rồi mình không xem ass này nên quên mất còn có kiểu Parameter nữa . Mình sửa rồi đó bạn . Testcase @ MU : Ok mình sửa rồi . @ TTT : xem Test # 76.Re : Testcase_Thanh_Pham_Minh wrote : Thêm một test về Not_Defined_Before_Used : ) var u : integer ; var v : integer ; procedure main ( ) ; begin var x , y : integer ; while ( u > 0 ) do begin var u : integer ; while ( v > 0 ) do begin / / vong lap nay chua chac da duoc chay u : = 1 ; y : = 2 ; if ( u > 0 ) then continue ; x : = 1 ; y : = x ; v : = 2 ; end x : = y ; / / y is not defined . y : = x ; end u : = u ; v : = v ; end ; Output : / / NoneTestcase Mình update lại testcase theo file PT của a Hùng.Testcase Thầy cập_nhật lại rồi đó bạn : ) Testcase @ TV : Test 39 lỗi vậy vì không gán đc vào String ( theo đặc_tả ) : | @ nhan : test đó báo y chưa được khai_báo , vì hàm demo chỉ thấy được các biến toàncục ở trên nó thôi . EDIT : uh test của nhan không báo lỗi . Testcase_Mình vừa cập_nhật testcase và thêm một_số case mới . Testcase_Most closed nested rule : For every applied occurrence ( i . e . , use ) of an identifier I in a block A , there must be a corresponding declaration of I . The declaration is in a block that is smallest enclosing the applied occurrence of I . Due to the above rule , the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block . Testcase_Mình vừa cập_nhật thêm một_số testcase . Testcase_Notice : Giờ các test mình không đúng nữa đâu , mình cũng chán rồi , sẽ không sửa gì nữa , các bạn chỉ nên tham_khảo các test ngoài bonus : ) Các bạn click vào số thứ_tự test để xem test nhé . Program INPUT_AST_OUTPUT [ 017 ] proceduremain ( ) ; begin vara , b , c , d , e : integer ; varr : array [ 10 ] ofreal ; r [ hello ] : = 0 ; end ; [ proc ( main , [ ] , [ var ( a , integer ) , var ( b , integer ) , var ( c , integer ) , var ( d , integer ) , var ( e , integer ) , var ( r , arr ( [ 10 ] , real ) ) , assign ( ele ( r , [ hello ] ) , 0 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Var ( b , PrimitiveType ( integer ) ) , Var ( c , PrimitiveType ( integer ) ) , Var ( d , PrimitiveType ( integer ) ) , Var ( e , PrimitiveType ( integer ) ) , Var ( r , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( real ) ) ) , Assign ( Ele ( r , List ( Id ( hello ) ) ) , IntLit ( 0 ) ) ) ) ) ) ) Undeclared_Identifier : hello [ 018 ] proceduremain ( ) ; begin vara , b , c , d , e : integer ; varr : array [ 10 ] ofreal ; r [ 0 ] : = r [ 1/2 ] ; end ; [ proc ( main , [ ] , [ var ( a , integer ) , var ( b , integer ) , var ( c , integer ) , var ( d , integer ) , var ( e , integer ) , var ( r , arr ( [ 10 ] , real ) ) , assign ( ele ( r , [ 0 ] ) , ele ( r , [ rdiv ( 1,2 ) ] ) ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Var ( b , PrimitiveType ( integer ) ) , Var ( c , PrimitiveType ( integer ) ) , Var ( d , PrimitiveType ( integer ) ) , Var ( e , PrimitiveType ( integer ) ) , Var ( r , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( real ) ) ) , Assign ( Ele ( r , List ( IntLit ( 0 ) ) ) , Ele ( r , List ( BinaryOp ( rdiv , IntLit ( 1 ) , IntLit ( 2 ) ) ) ) ) ) ) ) ) ) Type_Mismatch_In_Expression : ele ( r , [ rdiv ( 1,2 ) ] ) [ 019 ] proceduremain ( ) ; begin vara , b , c , d , e : integer ; varr : array [ 10,20 ] ofreal ; r [ 0 ] : = 0 ; end ; [ proc ( main , [ ] , [ var ( a , integer ) , var ( b , integer ) , var ( c , integer ) , var ( d , integer ) , var ( e , integer ) , var ( r , arr ( [ 10,20 ] , real ) ) , assign ( ele ( r , [ 0 ] ) , 0 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Var ( b , PrimitiveType ( integer ) ) , Var ( c , PrimitiveType ( integer ) ) , Var ( d , PrimitiveType ( integer ) ) , Var ( e , PrimitiveType ( integer ) ) , Var ( r , Arr ( List ( IntLit ( 10 ) , IntLit ( 20 ) ) , PrimitiveType ( real ) ) ) , Assign ( Ele ( r , List ( IntLit ( 0 ) ) ) , IntLit ( 0 ) ) ) ) ) ) ) Type_Mismatch_In_Expression : ele ( r , [ 0 ] ) [ 020 ] proceduremain ( ) ; begin vara , b , c , d , e : integer ; varr : array [ 10 ] ofreal ; r [ 0 ] : = 0 ; end ; [ proc ( main , [ ] , [ var ( a , integer ) , var ( b , integer ) , var ( c , integer ) , var ( d , integer ) , var ( e , integer ) , var ( r , arr ( [ 10 ] , real ) ) , assign ( ele ( r , [ 0 ] ) , 0 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Var ( b , PrimitiveType ( integer ) ) , Var ( c , PrimitiveType ( integer ) ) , Var ( d , PrimitiveType ( integer ) ) , Var ( e , PrimitiveType ( integer ) ) , Var ( r , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( real ) ) ) , Assign ( Ele ( r , List ( IntLit ( 0 ) ) ) , IntLit ( 0 ) ) ) ) ) ) ) [ 021 ] proceduremain ( ) ; begin vara , b , c , d , e : integer ; varr , r1 , r2 : array [ 10 ] ofreal ; r [ r1divr2 ] : = 0 ; end ; [ proc ( main , [ ] , [ var ( a , integer ) , var ( b , integer ) , var ( c , integer ) , var ( d , integer ) , var ( e , integer ) , var ( r , arr ( [ 10 ] , real ) ) , var ( r1 , arr ( [ 10 ] , real ) ) , var ( r2 , arr ( [ 10 ] , real ) ) , assign ( ele ( r , [ idiv ( r1 , r2 ) ] ) , 0 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Var ( b , PrimitiveType ( integer ) ) , Var ( c , PrimitiveType ( integer ) ) , Var ( d , PrimitiveType ( integer ) ) , Var ( e , PrimitiveType ( integer ) ) , Var ( r , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( real ) ) ) , Var ( r1 , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( real ) ) ) , Var ( r2 , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( real ) ) ) , Assign ( Ele ( r , List ( BinaryOp ( idiv , Id ( r1 ) , Id ( r2 ) ) ) ) , IntLit ( 0 ) ) ) ) ) ) ) Type_Mismatch_In_Expression : idiv ( r1 , r2 ) [ 022 ] proceduremain ( ) ; begin vara , b , c , d , e : integer ; varr : array [ 7,7 ] ofreal ; r [ 0,0 ] : = 0 ; end ; [ proc ( main , [ ] , [ var ( a , integer ) , var ( b , integer ) , var ( c , integer ) , var ( d , integer ) , var ( e , integer ) , var ( r , arr ( [ 7,7 ] , real ) ) , assign ( ele ( r , [ 0,0 ] ) , 0 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Var ( b , PrimitiveType ( integer ) ) , Var ( c , PrimitiveType ( integer ) ) , Var ( d , PrimitiveType ( integer ) ) , Var ( e , PrimitiveType ( integer ) ) , Var ( r , Arr ( List ( IntLit ( 7 ) , IntLit ( 7 ) ) , PrimitiveType ( real ) ) ) , Assign ( Ele ( r , List ( IntLit ( 0 ) , IntLit ( 0 ) ) ) , IntLit ( 0 ) ) ) ) ) ) ) [ 023 ] proceduremain ( ) ; begin vara , b , c , d , e : integer ; varr : array [ 10,0 ] ofreal ; r [ 0,0 ] : = 0 ; end ; [ proc ( main , [ ] , [ var ( a , integer ) , var ( b , integer ) , var ( c , integer ) , var ( d , integer ) , var ( e , integer ) , var ( r , arr ( [ 10,0 ] , real ) ) , assign ( ele ( r , [ 0,0 ] ) , 0 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Var ( b , PrimitiveType ( integer ) ) , Var ( c , PrimitiveType ( integer ) ) , Var ( d , PrimitiveType ( integer ) ) , Var ( e , PrimitiveType ( integer ) ) , Var ( r , Arr ( List ( IntLit ( 10 ) , IntLit ( 0 ) ) , PrimitiveType ( real ) ) ) , Assign ( Ele ( r , List ( IntLit ( 0 ) , IntLit ( 0 ) ) ) , IntLit ( 0 ) ) ) ) ) ) ) Size_Is_Not_Zero : var ( r , arr ( [ 10,0 ] , real ) ) [ 024 ] proceduremain ( ) ; begin while 1 = 2dobegin break ; continue ; end end ; [ proc ( main , [ ] , [ while ( eql ( 1,2 ) , [ break ( null ) , continue ( null ) ] ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 2 ) ) , Block ( List ( Break ( ) , Continue ( ) ) ) ) ) ) ) ) ) [ 025 ] proceduremain ( ) ; begin while 1 = 2dobegin break ; continue ; end break ; end ; [ proc ( main , [ ] , [ while ( eql ( 1,2 ) , [ break ( null ) , continue ( null ) ] ) , break ( null ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 2 ) ) , Block ( List ( Break ( ) , Continue ( ) ) ) ) , Break ( ) ) ) ) ) ) Break_Not_In_Loop [ 026 ] proceduremain ( ) ; begin while 1 = 2dobegin break ; continue ; end continue ; end ; [ proc ( main , [ ] , [ while ( eql ( 1,2 ) , [ break ( null ) , continue ( null ) ] ) , continue ( null ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 2 ) ) , Block ( List ( Break ( ) , Continue ( ) ) ) ) , Continue ( ) ) ) ) ) ) Continue_Not_In_Loop [ 027 ] proceduremain ( ) ; begin while 1 = 2dobegin if1 = 1then begin begin if 2 > 3then begin break ; continue ; end end end end if 1 < 1.0then begin end end ; [ proc ( main , [ ] , [ while ( eql ( 1,2 ) , [ if ( eql ( 1,1 ) , [ [ if ( greater ( 2,3 ) , [ break ( null ) , continue ( null ) ] ) ] ] ) ] ) , if ( less ( 1,1.0 ) , [ ] ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 2 ) ) , Block ( List ( If ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Block ( List ( Block ( List ( If ( BinaryOp ( greater , IntLit ( 2 ) , IntLit ( 3 ) ) , Block ( List ( Break ( ) , Continue ( ) ) ) , None ) ) ) ) ) , None ) ) ) ) , If ( BinaryOp ( less , IntLit ( 1 ) , FloatLit ( 1.0 ) ) , Block ( List ( ) ) , None ) ) ) ) ) ) Type_Mismatch_In_Expression : less ( 1,1.0 ) [ 028 ] proceduremain ( ) ; begin while 1 = 1dobeginend end ; [ proc ( main , [ ] , [ while ( eql ( 1,1 ) , [ ] ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Block ( List ( ) ) ) ) ) ) ) ) [ 029 ] proceduremain ( ) ; begin while 1dobeginend end ; [ proc ( main , [ ] , [ while ( 1 , [ ] ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( While ( IntLit ( 1 ) , Block ( List ( ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : while ( 1 , [ ] ) [ 030 ] proceduremain ( ) ; begin if 1 = 1thenbeginend end ; [ proc ( main , [ ] , [ if ( eql ( 1,1 ) , [ ] ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( If ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Block ( List ( ) ) , None ) ) ) ) ) ) [ 031 ] proceduremain ( ) ; begin if 1thenbeginend end ; [ proc ( main , [ ] , [ if ( 1 , [ ] ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( If ( IntLit ( 1 ) , Block ( List ( ) ) , None ) ) ) ) ) ) Type_Mismatch_In_Statement : if ( 1 , [ ] ) [ 032 ] proceduremain ( ) ; begin loop 1dobeginend end ; [ proc ( main , [ ] , [ loop ( 1 , [ ] ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Loop ( IntLit ( 1 ) , Block ( List ( ) ) ) ) ) ) ) ) [ 033 ] proceduremain ( ) ; begin loop 1 = 1dobeginend end ; [ proc ( main , [ ] , [ loop ( eql ( 1,1 ) , [ ] ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Loop ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Block ( List ( ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : loop ( eql ( 1,1 ) , [ ] ) [ 034 ] functionmain ( ) : real ; begin return 1 ; end ; [ func ( main , [ ] , real , [ return ( 1 ) ] ) ] Program ( List ( Func ( main , List ( ) , PrimitiveType ( real ) , Block ( List ( Return ( IntLit ( 1 ) ) ) ) ) ) ) [ 035 ] functionmain ( ) : real ; begin while 1 = 1do return1 ; loop1do return1 ; if1 = 1thenreturn1 ; end ; [ func ( main , [ ] , real , [ while ( eql ( 1,1 ) , return ( 1 ) ) , loop ( 1 , return ( 1 ) ) , if ( eql ( 1,1 ) , return ( 1 ) ) ] ) ] Program ( List ( Func ( main , List ( ) , PrimitiveType ( real ) , Block ( List ( While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Return ( IntLit ( 1 ) ) ) , Loop ( IntLit ( 1 ) , Return ( IntLit ( 1 ) ) ) , If ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Return ( IntLit ( 1 ) ) , None ) ) ) ) ) ) [ 036 ] functionmain1 ( ) : real ; begin while 1 = 1do return1 ; end ; functionmain2 ( ) : real ; begin loop 1do return1 ; end ; functionmain3 ( ) : real ; begin if 1 = 1thenreturn1 ; end ; functionmainx ( x : real ) : real ; begin if 1 > 1thenreturn1 ; while1 = 1dobegin ifx < 1.0thenbreak ; return1 ; end while 1 = 0doreturn1 ; loop10-20 +11 dobegin if 1.0 [ func ( main1 , [ ] , real , [ while ( eql ( 1,1 ) , return ( 1 ) ) ] ) , func ( main2 , [ ] , real , [ loop ( 1 , return ( 1 ) ) ] ) , func ( main3 , [ ] , real , [ if ( eql ( 1,1 ) , return ( 1 ) ) ] ) , func ( mainx , [ par ( x , real ) ] , real , [ if ( greater ( 1,1 ) , return ( 1 ) ) , while ( eql ( 1,1 ) , [ if ( less ( x , 1.0 ) , break ( null ) ) , return ( 1 ) ] ) , while ( eql ( 1,0 ) , return ( 1 ) ) , loop ( add ( sub ( 10,20 ) , 11 ) , [ if ( less ( 1.0 , x ) , break ( null ) ) , return ( 1 ) ] ) , loop ( 0 , return ( 1 ) ) , if ( greater ( x , 1.0 ) , return ( 1 ) ) , if ( bnot ( greater ( x , 1.0 ) ) , return ( 1 ) ) ] ) ] Program ( List ( Func ( main1 , List ( ) , PrimitiveType ( real ) , Block ( List ( While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Return ( IntLit ( 1 ) ) ) ) ) ) , Func ( main2 , List ( ) , PrimitiveType ( real ) , Block ( List ( Loop ( IntLit ( 1 ) , Return ( IntLit ( 1 ) ) ) ) ) ) , Func ( main3 , List ( ) , PrimitiveType ( real ) , Block ( List ( If ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Return ( IntLit ( 1 ) ) , None ) ) ) ) , Func ( mainx , List ( Var ( x , PrimitiveType ( real ) ) ) , PrimitiveType ( real ) , Block ( List ( If ( BinaryOp ( greater , IntLit ( 1 ) , IntLit ( 1 ) ) , Return ( IntLit ( 1 ) ) , None ) , While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 1 ) ) , Block ( List ( If ( BinaryOp ( less , Id ( x ) , FloatLit ( 1.0 ) ) , Break ( ) , None ) , Return ( IntLit ( 1 ) ) ) ) ) , While ( BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 0 ) ) , Return ( IntLit ( 1 ) ) ) , Loop ( BinaryOp ( add , BinaryOp ( sub , IntLit ( 10 ) , IntLit ( 20 ) ) , IntLit ( 11 ) ) , Block ( List ( If ( BinaryOp ( less , FloatLit ( 1.0 ) , Id ( x ) ) , Break ( ) , None ) , Return ( IntLit ( 1 ) ) ) ) ) , Loop ( IntLit ( 0 ) , Return ( IntLit ( 1 ) ) ) , If ( BinaryOp ( greater , Id ( x ) , FloatLit ( 1.0 ) ) , Return ( IntLit ( 1 ) ) , None ) , If ( UnaryOp ( bnot , BinaryOp ( greater , Id ( x ) , FloatLit ( 1.0 ) ) ) , Return ( IntLit ( 1 ) ) , None ) ) ) ) ) ) Function_Not_Return : mainx [ 037 ] functionmain ( ) : real ; begin varx : boolean ; x : = false ; ifxthenbegin return 1 ; endelsebegin return 1 ; end end ; [ func ( main , [ ] , real , [ var ( x , boolean ) , assign ( x , false ) , if ( x , [ return ( 1 ) ] , [ return ( 1 ) ] ) ] ) ] Program ( List ( Func ( main , List ( ) , PrimitiveType ( real ) , Block ( List ( Var ( x , PrimitiveType ( boolean ) ) , Assign ( Id ( x ) , BoolLit ( false ) ) , If ( Id ( x ) , Block ( List ( Return ( IntLit ( 1 ) ) ) ) , Some ( Block ( List ( Return ( IntLit ( 1 ) ) ) ) ) ) ) ) ) ) ) [ 038 ] varx : array [ 10,0 ] ofreal ; [ var ( x , arr ( [ 10,0 ] , real ) ) ] Program ( List ( Var ( x , Arr ( List ( IntLit ( 10 ) , IntLit ( 0 ) ) , PrimitiveType ( real ) ) ) ) ) Size_Is_Not_Zero : var ( x , arr ( [ 10,0 ] , real ) ) [ 039 ] proceduremain ( ) ; begin vara : string ; conststrConst = ' hello ' ' world ' ; a : = ' 2 ' + strConst ; end ; [ proc ( main , [ ] , [ var ( a , string ) , const ( strConst , string ( " ' hello ' ' world ' " ) ) , assign ( a , add ( string ( " ' 2 ' " ) , strConst ) ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( string ) ) , Const ( strConst , StringLit ( " ' hello ' ' world ' " ) ) , Assign ( Id ( a ) , BinaryOp ( add , UnaryOp ( string , StringLit ( " ' 2 ' " ) ) , Id ( strConst ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( a , add ( string ( " ' 2 ' " ) , strConst ) ) [ 040 ] proceduremain ( ) ; begin vara : string ; a : = 1 + true ; end ; [ proc ( main , [ ] , [ var ( a , string ) , assign ( a , add ( 1 , true ) ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( string ) ) , Assign ( Id ( a ) , BinaryOp ( add , IntLit ( 1 ) , BoolLit ( true ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( a , add ( 1 , true ) ) [ 041 ] proceduremain ( ) ; begin vara : string ; constarrConst = [ ' hello ' ' world ' ; ' ' ] ; vararrVar : array [ 2 ] ofstring ; arrVar : = [ ' 1 ' ; ' 2 ' ] ; arrVar : = arrConst ; a : = arrConst ; end ; [ proc ( main , [ ] , [ var ( a , string ) , const ( arrConst , array ( [ string ( " ' hello ' ' world ' " ) , string ( " ' ' " ) ] ) ) , var ( arrVar , arr ( [ 2 ] , string ) ) , assign ( arrVar , array ( [ string ( " ' 1 ' " ) , string ( " ' 2 ' " ) ] ) ) , assign ( arrVar , arrConst ) , assign ( a , arrConst ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( string ) ) , Const ( arrConst , ArrayLit ( List ( StringLit ( " ' hello ' ' world ' " ) , StringLit ( " ' ' " ) ) ) ) , Var ( arrVar , Arr ( List ( IntLit ( 2 ) ) , PrimitiveType ( string ) ) ) , Assign ( Id ( arrVar ) , ArrayLit ( List ( StringLit ( " ' 1 ' " ) , StringLit ( " ' 2 ' " ) ) ) ) , Assign ( Id ( arrVar ) , Id ( arrConst ) ) , Assign ( Id ( a ) , Id ( arrConst ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( arrVar , array ( [ string ( " ' 1 ' " ) , string ( " ' 2 ' " ) ] ) ) [ 042 ] proceduremain ( ) ; begin vararr Var : array [ 2 ] ofstring ; arrVar : = [ 1 ; 2 ] ; end ; [ proc ( main , [ ] , [ var ( arrVar , arr ( [ 2 ] , string ) ) , assign ( arrVar , array ( [ 1,2 ] ) ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( arrVar , Arr ( List ( IntLit ( 2 ) ) , PrimitiveType ( string ) ) ) , Assign ( Id ( arrVar ) , ArrayLit ( List ( IntLit ( 1 ) , IntLit ( 2 ) ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( arrVar , array ( [ 1,2 ] ) ) [ 043 ] proceduremain ( ) ; begin vararr Var : array [ 2 ] ofstring ; arrVar : = [ ' 1 ' ; ' 2 ' ] ; arrVar [ 1 ] : = 13 ; end ; [ proc ( main , [ ] , [ var ( arrVar , arr ( [ 2 ] , string ) ) , assign ( arrVar , array ( [ string ( " ' 1 ' " ) , string ( " ' 2 ' " ) ] ) ) , assign ( ele ( arrVar , [ 1 ] ) , 13 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( arrVar , Arr ( List ( IntLit ( 2 ) ) , PrimitiveType ( string ) ) ) , Assign ( Id ( arrVar ) , ArrayLit ( List ( StringLit ( " ' 1 ' " ) , StringLit ( " ' 2 ' " ) ) ) ) , Assign ( Ele ( arrVar , List ( IntLit ( 1 ) ) ) , IntLit ( 13 ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( arrVar , array ( [ string ( " ' 1 ' " ) , string ( " ' 2 ' " ) ] ) ) [ 044 ] proceduremain ( ) ; begin vararr Var : array [ 2 ] ofstring ; arrVar : = [ ' 1 ' ; ' 2 ' ] ; arrVar [ 1 ] : = ' 13 ' ; end ; [ proc ( main , [ ] , [ var ( arrVar , arr ( [ 2 ] , string ) ) , assign ( arrVar , array ( [ string ( " ' 1 ' " ) , string ( " ' 2 ' " ) ] ) ) , assign ( ele ( arrVar , [ 1 ] ) , string ( " ' 13 ' " ) ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( arrVar , Arr ( List ( IntLit ( 2 ) ) , PrimitiveType ( string ) ) ) , Assign ( Id ( arrVar ) , ArrayLit ( List ( StringLit ( " ' 1 ' " ) , StringLit ( " ' 2 ' " ) ) ) ) , Assign ( Ele ( arrVar , List ( IntLit ( 1 ) ) ) , UnaryOp ( string , StringLit ( " ' 13 ' " ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( arrVar , array ( [ string ( " ' 1 ' " ) , string ( " ' 2 ' " ) ] ) ) [ 045 ] proceduremain ( ) ; begin vara : boolean ; a : = ( 1 +2 * 3.4 ) = 5.0 ; a : = 1 = 2 ; a : = 1.2 = 2.2 ; a : = 1 = 2.2 ; a : = ( 1 < 2 ) and ( 2 < 3 ) ; a : = 1 < 2 < 3 ; end ; [ proc ( main , [ ] , [ var ( a , boolean ) , assign ( a , eql ( add ( 1 , times ( 2,3.4 ) ) , 5.0 ) ) , assign ( a , eql ( 1,2 ) ) , assign ( a , eql ( 1.2,2.2 ) ) , assign ( a , eql ( 1,2.2 ) ) , assign ( a , band ( less ( 1,2 ) , less ( 2,3 ) ) ) , assign ( a , less ( less ( 1,2 ) , 3 ) ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( a , PrimitiveType ( boolean ) ) , Assign ( Id ( a ) , BinaryOp ( eql , BinaryOp ( add , IntLit ( 1 ) , BinaryOp ( times , IntLit ( 2 ) , FloatLit ( 3.4 ) ) ) , FloatLit ( 5.0 ) ) ) , Assign ( Id ( a ) , BinaryOp ( eql , IntLit ( 1 ) , IntLit ( 2 ) ) ) , Assign ( Id ( a ) , BinaryOp ( eql , FloatLit ( 1.2 ) , FloatLit ( 2.2 ) ) ) , Assign ( Id ( a ) , BinaryOp ( eql , IntLit ( 1 ) , FloatLit ( 2.2 ) ) ) , Assign ( Id ( a ) , BinaryOp ( band , BinaryOp ( less , IntLit ( 1 ) , IntLit ( 2 ) ) , BinaryOp ( less , IntLit ( 2 ) , IntLit ( 3 ) ) ) ) , Assign ( Id ( a ) , BinaryOp ( less , BinaryOp ( less , IntLit ( 1 ) , IntLit ( 2 ) ) , IntLit ( 3 ) ) ) ) ) ) ) ) Type_Mismatch_In_Expression : eql ( add ( 1 , times ( 2,3.4 ) ) , 5.0 ) [ 046 ] proceduremain ( ) ; begin varx : integer ; x : = 2 ; begin x : = 3 ; varx : real ; x : = 3 ; x : = 3.0 ; end x : = 4 ; x : = 4.4 ; end ; [ proc ( main , [ ] , [ var ( x , integer ) , assign ( x , 2 ) , [ assign ( x , 3 ) , var ( x , real ) , assign ( x , 3 ) , assign ( x , 3.0 ) ] , assign ( x , 4 ) , assign ( x , 4.4 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( x , PrimitiveType ( integer ) ) , Assign ( Id ( x ) , IntLit ( 2 ) ) , Block ( List ( Assign ( Id ( x ) , IntLit ( 3 ) ) , Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( x ) , IntLit ( 3 ) ) , Assign ( Id ( x ) , FloatLit ( 3.0 ) ) ) ) , Assign ( Id ( x ) , IntLit ( 4 ) ) , Assign ( Id ( x ) , FloatLit ( 4.4 ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( x , 4.4 ) [ 047 ] proceduremain ( ) ; begin varx : integer ; x : = 2 ; begin x : = 3 ; varx : real ; x : = 3 ; x : = 3.0 ; end x : = 4 ; x : = z ; x : = 4.4 ; constz = 2 ; end ; [ proc ( main , [ ] , [ var ( x , integer ) , assign ( x , 2 ) , [ assign ( x , 3 ) , var ( x , real ) , assign ( x , 3 ) , assign ( x , 3.0 ) ] , assign ( x , 4 ) , assign ( x , z ) , assign ( x , 4.4 ) , const ( z , 2 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( x , PrimitiveType ( integer ) ) , Assign ( Id ( x ) , IntLit ( 2 ) ) , Block ( List ( Assign ( Id ( x ) , IntLit ( 3 ) ) , Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( x ) , IntLit ( 3 ) ) , Assign ( Id ( x ) , FloatLit ( 3.0 ) ) ) ) , Assign ( Id ( x ) , IntLit ( 4 ) ) , Assign ( Id ( x ) , Id ( z ) ) , Assign ( Id ( x ) , FloatLit ( 4.4 ) ) , Const ( z , IntLit ( 2 ) ) ) ) ) ) ) Undeclared_Identifier : z [ 048 ] proceduremain ( ) ; begin varx : integer ; x : = 2 ; begin constz = 2 ; x : = 3 ; varx : real ; x : = 3 ; x : = 3.0 ; end x : = 4 ; x : = z ; x : = 4.4 ; end ; [ proc ( main , [ ] , [ var ( x , integer ) , assign ( x , 2 ) , [ const ( z , 2 ) , assign ( x , 3 ) , var ( x , real ) , assign ( x , 3 ) , assign ( x , 3.0 ) ] , assign ( x , 4 ) , assign ( x , z ) , assign ( x , 4.4 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( x , PrimitiveType ( integer ) ) , Assign ( Id ( x ) , IntLit ( 2 ) ) , Block ( List ( Const ( z , IntLit ( 2 ) ) , Assign ( Id ( x ) , IntLit ( 3 ) ) , Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( x ) , IntLit ( 3 ) ) , Assign ( Id ( x ) , FloatLit ( 3.0 ) ) ) ) , Assign ( Id ( x ) , IntLit ( 4 ) ) , Assign ( Id ( x ) , Id ( z ) ) , Assign ( Id ( x ) , FloatLit ( 4.4 ) ) ) ) ) ) ) Undeclared_Identifier : z [ 049 ] functionmain ( ) : real ; begin varx : real ; x : = 1 ; returnx ; end ; [ func ( main , [ ] , real , [ var ( x , real ) , assign ( x , 1 ) , return ( x ) ] ) ] Program ( List ( Func ( main , List ( ) , PrimitiveType ( real ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( x ) , IntLit ( 1 ) ) , Return ( Id ( x ) ) ) ) ) ) ) [ 050 ] functionmain ( ) : real ; begin varx : real ; x : = x ; end ; [ func ( main , [ ] , real , [ var ( x , real ) , assign ( x , x ) ] ) ] Program ( List ( Func ( main , List ( ) , PrimitiveType ( real ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 051 ] proceduremain ( x : real ) ; begin x : = x ; end ; [ proc ( main , [ par ( x , real ) ] , [ assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( Var ( x , PrimitiveType ( real ) ) ) , Block ( List ( Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) [ 052 ] proceduremain ( ) ; begin varbool Var : boolean ; varx : real ; boolVar : = false ; ifboolVarthenbegin x : = 1 ; x : = 2 ; end x : = x ; end ; [ proc ( main , [ ] , [ var ( boolVar , boolean ) , var ( x , real ) , assign ( boolVar , false ) , if ( boolVar , [ assign ( x , 1 ) , assign ( x , 2 ) ] ) , assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( boolVar , PrimitiveType ( boolean ) ) , Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( boolVar ) , BoolLit ( false ) ) , If ( Id ( boolVar ) , Block ( List ( Assign ( Id ( x ) , IntLit ( 1 ) ) , Assign ( Id ( x ) , IntLit ( 2 ) ) ) ) , None ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 053 ] proceduremain ( ) ; begin varbool Var : boolean ; varx : real ; boolVar : = false ; ifboolVarthenx : = 1 ; elsex : = 1 ; x : = x ; end ; [ proc ( main , [ ] , [ var ( boolVar , boolean ) , var ( x , real ) , assign ( boolVar , false ) , if ( boolVar , assign ( x , 1 ) , assign ( x , 1 ) ) , assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( boolVar , PrimitiveType ( boolean ) ) , Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( boolVar ) , BoolLit ( false ) ) , If ( Id ( boolVar ) , Assign ( Id ( x ) , IntLit ( 1 ) ) , Some ( Assign ( Id ( x ) , IntLit ( 1 ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) [ 054 ] proceduremain ( ) ; begin varbool Var : boolean ; varx : real ; boolVar : = false ; ifboolVarthen x : = 1 ; elsebegin varx : real ; x : = 1 ; end x : = x ; end ; [ proc ( main , [ ] , [ var ( boolVar , boolean ) , var ( x , real ) , assign ( boolVar , false ) , if ( boolVar , assign ( x , 1 ) , [ var ( x , real ) , assign ( x , 1 ) ] ) , assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( boolVar , PrimitiveType ( boolean ) ) , Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( boolVar ) , BoolLit ( false ) ) , If ( Id ( boolVar ) , Assign ( Id ( x ) , IntLit ( 1 ) ) , Some ( Block ( List ( Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( x ) , IntLit ( 1 ) ) ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 055 ] proceduremain ( ) ; begin varbool Var : boolean ; varx : real ; boolVar : = false ; ifboolVarthen x : = 1 ; elsebegin x : = 1 ; varx : real ; x : = 1 ; end begin varx : real ; x : = 1 ; end x : = x ; end ; [ proc ( main , [ ] , [ var ( boolVar , boolean ) , var ( x , real ) , assign ( boolVar , false ) , if ( boolVar , assign ( x , 1 ) , [ assign ( x , 1 ) , var ( x , real ) , assign ( x , 1 ) ] ) , [ var ( x , real ) , assign ( x , 1 ) ] , assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( boolVar , PrimitiveType ( boolean ) ) , Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( boolVar ) , BoolLit ( false ) ) , If ( Id ( boolVar ) , Assign ( Id ( x ) , IntLit ( 1 ) ) , Some ( Block ( List ( Assign ( Id ( x ) , IntLit ( 1 ) ) , Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( x ) , IntLit ( 1 ) ) ) ) ) ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , Assign ( Id ( x ) , IntLit ( 1 ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) [ 056 ] proceduremain ( b : boolean ) ; begin varx : real ; whiletruedobegin ifbthenbegin x : = 1 ; continue ; endelsebreak ; x : = 2 ; end x : = x ; end ; [ proc ( main , [ par ( b , boolean ) ] , [ var ( x , real ) , while ( true , [ if ( b , [ assign ( x , 1 ) , continue ( null ) ] , break ( null ) ) , assign ( x , 2 ) ] ) , assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , While ( BoolLit ( true ) , Block ( List ( If ( Id ( b ) , Block ( List ( Assign ( Id ( x ) , IntLit ( 1 ) ) , Continue ( ) ) ) , Some ( Break ( ) ) ) , Assign ( Id ( x ) , IntLit ( 2 ) ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 057 ] proceduremain ( b : boolean ) ; begin varx : real ; whilebdobegin ifbthenbegin whilenotbdobreak ; x : = 1 ; continue ; endelsebegin x : = 3 ; break ; end x : = 2 ; end x : = x ; end ; [ proc ( main , [ par ( b , boolean ) ] , [ var ( x , real ) , while ( b , [ if ( b , [ while ( bnot ( b ) , break ( null ) ) , assign ( x , 1 ) , continue ( null ) ] , [ assign ( x , 3 ) , break ( null ) ] ) , assign ( x , 2 ) ] ) , assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , While ( Id ( b ) , Block ( List ( If ( Id ( b ) , Block ( List ( While ( UnaryOp ( bnot , Id ( b ) ) , Break ( ) ) , Assign ( Id ( x ) , IntLit ( 1 ) ) , Continue ( ) ) ) , Some ( Block ( List ( Assign ( Id ( x ) , IntLit ( 3 ) ) , Break ( ) ) ) ) ) , Assign ( Id ( x ) , IntLit ( 2 ) ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 058 ] proceduremain ( b : boolean ) ; begin varx : real ; constt = [ [ 1 ; 2 ] ; [ 3 ; 4 ] ] ; whilet [ 0,0 ] [ proc ( main , [ par ( b , boolean ) ] , [ var ( x , real ) , const ( t , array ( [ array ( [ 1,2 ] ) , array ( [ 3,4 ] ) ] ) ) , while ( less ( ele ( t , [ 0,0 ] ) , ele ( t , [ 0,1 ] ) ) , [ assign ( x , 2 ) ] ) , assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , Const ( t , ArrayLit ( List ( ArrayLit ( List ( IntLit ( 1 ) , IntLit ( 2 ) ) ) , ArrayLit ( List ( IntLit ( 3 ) , IntLit ( 4 ) ) ) ) ) ) , While ( BinaryOp ( less , Ele ( t , List ( IntLit ( 0 ) , IntLit ( 0 ) ) ) , Ele ( t , List ( IntLit ( 0 ) , IntLit ( 1 ) ) ) ) , Block ( List ( Assign ( Id ( x ) , IntLit ( 2 ) ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) [ 059 ] proceduremain ( b : boolean ) ; begin varx : real ; constt = [ [ 1 ; 2 ] ; [ 3 ; 4 ] ] ; whilet [ 0,0 ] > t [ 0,1 ] dobegin x : = 2 ; end x : = x ; end ; [ proc ( main , [ par ( b , boolean ) ] , [ var ( x , real ) , const ( t , array ( [ array ( [ 1,2 ] ) , array ( [ 3,4 ] ) ] ) ) , while ( greater ( ele ( t , [ 0,0 ] ) , ele ( t , [ 0,1 ] ) ) , [ assign ( x , 2 ) ] ) , assign ( x , x ) ] ) ] Program ( List ( Proc ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , Const ( t , ArrayLit ( List ( ArrayLit ( List ( IntLit ( 1 ) , IntLit ( 2 ) ) ) , ArrayLit ( List ( IntLit ( 3 ) , IntLit ( 4 ) ) ) ) ) ) , While ( BinaryOp ( greater , Ele ( t , List ( IntLit ( 0 ) , IntLit ( 0 ) ) ) , Ele ( t , List ( IntLit ( 0 ) , IntLit ( 1 ) ) ) ) , Block ( List ( Assign ( Id ( x ) , IntLit ( 2 ) ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 060 ] constbTrue = true ; proceduremain ( b : boolean ) ; begin varx : real ; whilebTruedobegin ifbTruethenbreak ; x : = x ; end x : = x ; end ; [ const ( bTrue , true ) , proc ( main , [ par ( b , boolean ) ] , [ var ( x , real ) , while ( bTrue , [ if ( bTrue , break ( null ) ) , assign ( x , x ) ] ) , assign ( x , x ) ] ) ] Program ( List ( Const ( bTrue , BoolLit ( true ) ) , Proc ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , While ( Id ( bTrue ) , Block ( List ( If ( Id ( bTrue ) , Break ( ) , None ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 061 ] constbTrue = true ; proceduremain ( b : boolean ) ; begin varx : real ; whilebTruedobegin ifnotbTruethenbreak ; elsex : = - 1 ; end write Int ( x ) ; end ; [ const ( bTrue , true ) , proc ( main , [ par ( b , boolean ) ] , [ var ( x , real ) , while ( bTrue , [ if ( bnot ( bTrue ) , break ( null ) , assign ( x , sub ( 1 ) ) ) ] ) , call ( writeInt , [ x ] ) ] ) ] Program ( List ( Const ( bTrue , BoolLit ( true ) ) , Proc ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , While ( Id ( bTrue ) , Block ( List ( If ( UnaryOp ( bnot , Id ( bTrue ) ) , Break ( ) , Some ( Assign ( Id ( x ) , UnaryOp ( sub , IntLit ( 1 ) ) ) ) ) ) ) ) , ProcCall ( writeInt , List ( Id ( x ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : call ( writeInt , [ x ] ) [ 062 ] constbTrue = true ; functionmain ( b : boolean ) : boolean ; begin ifb Truethenreturntrue ; end ; [ const ( bTrue , true ) , func ( main , [ par ( b , boolean ) ] , boolean , [ if ( bTrue , return ( true ) ) ] ) ] Program ( List ( Const ( bTrue , BoolLit ( true ) ) , Func ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , PrimitiveType ( boolean ) , Block ( List ( If ( Id ( bTrue ) , Return ( BoolLit ( true ) ) , None ) ) ) ) ) ) [ 063 ] constbTrue = true ; functionmain ( b : boolean ) : boolean ; begin ifnotb Truethenreturntrue ; end ; [ const ( bTrue , true ) , func ( main , [ par ( b , boolean ) ] , boolean , [ if ( bnot ( bTrue ) , return ( true ) ) ] ) ] Program ( List ( Const ( bTrue , BoolLit ( true ) ) , Func ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , PrimitiveType ( boolean ) , Block ( List ( If ( UnaryOp ( bnot , Id ( bTrue ) ) , Return ( BoolLit ( true ) ) , None ) ) ) ) ) ) Function_Not_Return : main [ 064 ] constbTrue = true ; functionmain ( b : boolean ) : boolean ; begin varx , y : real ; whilebTruedobegin ifbthenbreak ; elsey : = 2 ; x : = 7 ; end write Int ( x ) ; writeInt ( y ) ; end ; [ const ( bTrue , true ) , func ( main , [ par ( b , boolean ) ] , boolean , [ var ( x , real ) , var ( y , real ) , while ( bTrue , [ if ( b , break ( null ) , assign ( y , 2 ) ) , assign ( x , 7 ) ] ) , call ( writeInt , [ x ] ) , call ( writeInt , [ y ] ) ] ) ] Program ( List ( Const ( bTrue , BoolLit ( true ) ) , Func ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , PrimitiveType ( boolean ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , Var ( y , PrimitiveType ( real ) ) , While ( Id ( bTrue ) , Block ( List ( If ( Id ( b ) , Break ( ) , Some ( Assign ( Id ( y ) , IntLit ( 2 ) ) ) ) , Assign ( Id ( x ) , IntLit ( 7 ) ) ) ) ) , ProcCall ( writeInt , List ( Id ( x ) ) ) , ProcCall ( writeInt , List ( Id ( y ) ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 065 ] constbTrue = true ; functionmain ( b : boolean ) : boolean ; begin varx , y : real ; whilebdobegin x : = 7 ; end x : = x ; returnfalse ; end ; [ const ( bTrue , true ) , func ( main , [ par ( b , boolean ) ] , boolean , [ var ( x , real ) , var ( y , real ) , while ( b , [ assign ( x , 7 ) ] ) , assign ( x , x ) , return ( false ) ] ) ] Program ( List ( Const ( bTrue , BoolLit ( true ) ) , Func ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , PrimitiveType ( boolean ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , Var ( y , PrimitiveType ( real ) ) , While ( Id ( b ) , Block ( List ( Assign ( Id ( x ) , IntLit ( 7 ) ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) , Return ( BoolLit ( false ) ) ) ) ) ) ) Not_Defined_Before_Used : x [ 066 ] constbTrue = true ; functionmain ( b : boolean ) : boolean ; begin varx : real ; whiletruedobegin whiletruedobreak ; x : = 2 ; end x : = x ; whiletruedobegin whilefalsedo whilefalsedo break ; return1 > 1 ; end end ; [ const ( bTrue , true ) , func ( main , [ par ( b , boolean ) ] , boolean , [ var ( x , real ) , while ( true , [ while ( true , break ( null ) ) , assign ( x , 2 ) ] ) , assign ( x , x ) , while ( true , [ while ( false , while ( false , break ( null ) ) ) , return ( greater ( 1,1 ) ) ] ) ] ) ] Program ( List ( Const ( bTrue , BoolLit ( true ) ) , Func ( main , List ( Var ( b , PrimitiveType ( boolean ) ) ) , PrimitiveType ( boolean ) , Block ( List ( Var ( x , PrimitiveType ( real ) ) , While ( BoolLit ( true ) , Block ( List ( While ( BoolLit ( true ) , Break ( ) ) , Assign ( Id ( x ) , IntLit ( 2 ) ) ) ) ) , Assign ( Id ( x ) , Id ( x ) ) , While ( BoolLit ( true ) , Block ( List ( While ( BoolLit ( false ) , While ( BoolLit ( false ) , Break ( ) ) ) , Return ( BinaryOp ( greater , IntLit ( 1 ) , IntLit ( 1 ) ) ) ) ) ) ) ) ) ) ) [ 067 ] functionmain ( x : boolean ) : real ; begin ifxthenreturn 1 ; end ; [ func ( main , [ par ( x , boolean ) ] , real , [ if ( x , return ( 1 ) ) ] ) ] Program ( List ( Func ( main , List ( Var ( x , PrimitiveType ( boolean ) ) ) , PrimitiveType ( real ) , Block ( List ( If ( Id ( x ) , Return ( IntLit ( 1 ) ) , None ) ) ) ) ) ) Function_Not_Return : main [ 068 ] functionmain ( x : boolean ) : real ; begin ifxortruethenreturn 1 ; end ; [ func ( main , [ par ( x , boolean ) ] , real , [ if ( bor ( x , true ) , return ( 1 ) ) ] ) ] Program ( List ( Func ( main , List ( Var ( x , PrimitiveType ( boolean ) ) ) , PrimitiveType ( real ) , Block ( List ( If ( BinaryOp ( bor , Id ( x ) , BoolLit ( true ) ) , Return ( IntLit ( 1 ) ) , None ) ) ) ) ) ) Function_Not_Return : main [ 069 ] functionmain ( x : boolean ) : real ; begin iftrueorxthenreturn 1 ; end ; [ func ( main , [ par ( x , boolean ) ] , real , [ if ( bor ( true , x ) , return ( 1 ) ) ] ) ] Program ( List ( Func ( main , List ( Var ( x , PrimitiveType ( boolean ) ) ) , PrimitiveType ( real ) , Block ( List ( If ( BinaryOp ( bor , BoolLit ( true ) , Id ( x ) ) , Return ( IntLit ( 1 ) ) , None ) ) ) ) ) ) Function_Not_Return : main [ 070 ] functionmain ( x : boolean ) : real ; begin ifnot ( falseandx ) thenreturn1 ; end ; [ func ( main , [ par ( x , boolean ) ] , real , [ if ( bnot ( band ( false , x ) ) , return ( 1 ) ) ] ) ] Program ( List ( Func ( main , List ( Var ( x , PrimitiveType ( boolean ) ) ) , PrimitiveType ( real ) , Block ( List ( If ( UnaryOp ( bnot , BinaryOp ( band , BoolLit ( false ) , Id ( x ) ) ) , Return ( IntLit ( 1 ) ) , None ) ) ) ) ) ) Function_Not_Return : main [ 071 ] proceduremain ( ) ; begin varva : array [ 10 ] ofreal ; constca = [ 1 ; 2 ; 3 ; 4 ] ; va [ 10 ] : = 2 ; ca [ 3 ] : = 2 ; end ; [ proc ( main , [ ] , [ var ( va , arr ( [ 10 ] , real ) ) , const ( ca , array ( [ 1,2,3,4 ] ) ) , assign ( ele ( va , [ 10 ] ) , 2 ) , assign ( ele ( ca , [ 3 ] ) , 2 ) ] ) ] Program ( List ( Proc ( main , List ( ) , Block ( List ( Var ( va , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( real ) ) ) , Const ( ca , ArrayLit ( List ( IntLit ( 1 ) , IntLit ( 2 ) , IntLit ( 3 ) , IntLit ( 4 ) ) ) ) , Assign ( Ele ( va , List ( IntLit ( 10 ) ) ) , IntLit ( 2 ) ) , Assign ( Ele ( ca , List ( IntLit ( 3 ) ) ) , IntLit ( 2 ) ) ) ) ) ) ) Cannot_Assign_To_Constant : assign ( ele ( ca , [ 3 ] ) , 2 ) [ 072 ] functionmain ( ) : real ; begin constca = [ 1 ; 2 ; 3 ; 4 ] ; returnca [ 1 ] - ca [ 1,2 ] ; end ; [ func ( main , [ ] , real , [ const ( ca , array ( [ 1,2,3,4 ] ) ) , return ( sub ( ele ( ca , [ 1 ] ) , ele ( ca , [ 1,2 ] ) ) ) ] ) ] Program ( List ( Func ( main , List ( ) , PrimitiveType ( real ) , Block ( List ( Const ( ca , ArrayLit ( List ( IntLit ( 1 ) , IntLit ( 2 ) , IntLit ( 3 ) , IntLit ( 4 ) ) ) ) , Return ( BinaryOp ( sub , Ele ( ca , List ( IntLit ( 1 ) ) ) , Ele ( ca , List ( IntLit ( 1 ) , IntLit ( 2 ) ) ) ) ) ) ) ) ) ) Type_Mismatch_In_Expression : ele ( ca , [ 1,2 ] ) [ 073 ] functionmain ( ) : real ; begin vara : array [ 10 ] ofinteger ; vars : string ; a [ 3 ] : = 7-3 ; s : = ' hello ' ; return2 ; end ; [ func ( main , [ ] , real , [ var ( a , arr ( [ 10 ] , integer ) ) , var ( s , string ) , assign ( ele ( a , [ 3 ] ) , sub ( 7,3 ) ) , assign ( s , string ( " ' hello ' " ) ) , return ( 2 ) ] ) ] Program ( List ( Func ( main , List ( ) , PrimitiveType ( real ) , Block ( List ( Var ( a , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( integer ) ) ) , Var ( s , PrimitiveType ( string ) ) , Assign ( Ele ( a , List ( IntLit ( 3 ) ) ) , BinaryOp ( sub , IntLit ( 7 ) , IntLit ( 3 ) ) ) , Assign ( Id ( s ) , UnaryOp ( string , StringLit ( " ' hello ' " ) ) ) , Return ( IntLit ( 2 ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( s , string ( " ' hello ' " ) ) [ 074 ] varglobalX , globalY : real ; functionmain ( ) : real ; begin vara : array [ 10 ] ofreal ; varlocalX , localY : real ; localY : = globalY ; globalX : = localX ; return2 ; end ; [ var ( globalX , real ) , var ( globalY , real ) , func ( main , [ ] , real , [ var ( a , arr ( [ 10 ] , real ) ) , var ( localX , real ) , var ( localY , real ) , assign ( localY , globalY ) , assign ( globalX , localX ) , return ( 2 ) ] ) ] Program ( List ( Var ( globalX , PrimitiveType ( real ) ) , Var ( globalY , PrimitiveType ( real ) ) , Func ( main , List ( ) , PrimitiveType ( real ) , Block ( List ( Var ( a , Arr ( List ( IntLit ( 10 ) ) , PrimitiveType ( real ) ) ) , Var ( localX , PrimitiveType ( real ) ) , Var ( localY , PrimitiveType ( real ) ) , Assign ( Id ( localY ) , Id ( globalY ) ) , Assign ( Id ( globalX ) , Id ( localX ) ) , Return ( IntLit ( 2 ) ) ) ) ) ) ) Not_Defined_Before_Used : localX [ 075 ] varx : boolean ; procedureproc ( y : integer ; j : integer ) ; begin vara : integer ; x : = a-true ; end ; [ var ( x , boolean ) , proc ( proc , [ par ( y , integer ) , par ( j , integer ) ] , [ var ( a , integer ) , assign ( x , sub ( a , true ) ) ] ) ] Program ( List ( Var ( x , PrimitiveType ( boolean ) ) , Proc ( proc , List ( Var ( y , PrimitiveType ( integer ) ) , Var ( j , PrimitiveType ( integer ) ) ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Assign ( Id ( x ) , BinaryOp ( sub , Id ( a ) , BoolLit ( true ) ) ) ) ) ) ) ) Not_Defined_Before_Used : a [ 076 ] proceduref ( a : real ) ; begin varf : real ; end ; [ proc ( f , [ par ( a , real ) ] , [ var ( f , real ) ] ) ] Program ( List ( Proc ( f , List ( Var ( a , PrimitiveType ( real ) ) ) , Block ( List ( Var ( f , PrimitiveType ( real ) ) ) ) ) ) ) Redeclared_Variable : f [ 077 ] proceduredemo ( ) ; begin y : = true ; vary : integer ; y : = 0 ; end ; vary : boolean ; [ proc ( demo , [ ] , [ assign ( y , true ) , var ( y , integer ) , assign ( y , 0 ) ] ) , var ( y , boolean ) ] Program ( List ( Proc ( demo , List ( ) , Block ( List ( Assign ( Id ( y ) , BoolLit ( true ) ) , Var ( y , PrimitiveType ( integer ) ) , Assign ( Id ( y ) , IntLit ( 0 ) ) ) ) ) , Var ( y , PrimitiveType ( boolean ) ) ) ) [ 078 ] vary , z : integer ; proceduremain ( ) ; begin y : = 1 ; writeRealLn ( foo ( y ) ) ; end ; constx = 1.2e3 ; functionfoo ( p : integer ) : real ; begin returnp * x ; end ; [ var ( y , integer ) , var ( z , integer ) , proc ( main , [ ] , [ assign ( y , 1 ) , call ( writeRealLn , [ call ( foo , [ y ] ) ] ) ] ) , const ( x , 1.2e3 ) , func ( foo , [ par ( p , integer ) ] , real , [ return ( times ( p , x ) ) ] ) ] Program ( List ( Var ( y , PrimitiveType ( integer ) ) , Var ( z , PrimitiveType ( integer ) ) , Proc ( main , List ( ) , Block ( List ( Assign ( Id ( y ) , IntLit ( 1 ) ) , ProcCall ( writeRealLn , List ( FuncCall ( foo , List ( Id ( y ) ) ) ) ) ) ) ) , Const ( x , FloatLit ( 1200.0 ) ) , Func ( foo , List ( Var ( p , PrimitiveType ( integer ) ) ) , PrimitiveType ( real ) , Block ( List ( Return ( BinaryOp ( times , Id ( p ) , Id ( x ) ) ) ) ) ) ) ) [ 079 ] vara : array [ 5 ] ofinteger ; / / globalvariable procedurefill ( x : array [ 5 ] ofinteger ) ; begin vara : real ; / / supersedingglobalvariablea / / varx : real ; / / WRONGbecauseparameterxhasthesamename a : = 5.9 ; init ( x ) ; end ; procedureinit ( x : array [ 5 ] ofinteger ) ; begin vari : integer ; / / blockvariable i : = 0 ; x [ i ] : = a [ i ] ; / / aisglobalvar . end ; proceduremain ( ) ; begin fill ( a ) ; end ; [ var ( a , arr ( [ 5 ] , integer ) ) , proc ( fill , [ par ( x , arr ( [ 5 ] , integer ) ) ] , [ var ( a , real ) , assign ( a , 5.9 ) , call ( init , [ x ] ) ] ) , proc ( init , [ par ( x , arr ( [ 5 ] , integer ) ) ] , [ var ( i , integer ) , assign ( i , 0 ) , assign ( ele ( x , [ i ] ) , ele ( a , [ i ] ) ) ] ) , proc ( main , [ ] , [ call ( fill , [ a ] ) ] ) ] Program ( List ( Var ( a , Arr ( List ( IntLit ( 5 ) ) , PrimitiveType ( integer ) ) ) , Proc ( fill , List ( Var ( x , Arr ( List ( IntLit ( 5 ) ) , PrimitiveType ( integer ) ) ) ) , Block ( List ( Var ( a , PrimitiveType ( real ) ) , Assign ( Id ( a ) , FloatLit ( 5.9 ) ) , ProcCall ( init , List ( Id ( x ) ) ) ) ) ) , Proc ( init , List ( Var ( x , Arr ( List ( IntLit ( 5 ) ) , PrimitiveType ( integer ) ) ) ) , Block ( List ( Var ( i , PrimitiveType ( integer ) ) , Assign ( Id ( i ) , IntLit ( 0 ) ) , Assign ( Ele ( x , List ( Id ( i ) ) ) , Ele ( a , List ( Id ( i ) ) ) ) ) ) ) , Proc ( main , List ( ) , Block ( List ( ProcCall ( fill , List ( Id ( a ) ) ) ) ) ) ) ) [ 080 ] varvar2 : integer ; functionfun1 ( var1 : integer ) : integer ; begin vara : integer ; return0 ; end ; proceduremain ( ) ; begin var 2 : = 3 ; constconst2 = 2.2 ; / / var2 : = var2 + fun1 ( const2 ) ; fun1 ( const2 ) ; end ; [ var ( var2 , integer ) , func ( fun1 , [ par ( var1 , integer ) ] , integer , [ var ( a , integer ) , return ( 0 ) ] ) , proc ( main , [ ] , [ assign ( var2 , 3 ) , const ( const2 , 2.2 ) , call ( fun1 , [ const2 ] ) ] ) ] Program ( List ( Var ( var2 , PrimitiveType ( integer ) ) , Func ( fun1 , List ( Var ( var1 , PrimitiveType ( integer ) ) ) , PrimitiveType ( integer ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) , Return ( IntLit ( 0 ) ) ) ) ) , Proc ( main , List ( ) , Block ( List ( Assign ( Id ( var2 ) , IntLit ( 3 ) ) , Const ( const2 , FloatLit ( 2.2 ) ) , ProcCall ( fun1 , List ( Id ( const2 ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : call ( fun1 , [ const2 ] ) [ 081 ] varvar2 : integer ; procedurefun1 ( var1 : real ; var3 : integer ) ; begin vara : integer ; end ; proceduremain ( ) ; begin var 2 : = 3.1 ; constconst2 = 2 ; / / var2 : = var2 + fun1 ( const2 ) ; fun1 ( const2 , var2 ) ; end ; [ var ( var2 , integer ) , proc ( fun1 , [ par ( var1 , real ) , par ( var3 , integer ) ] , [ var ( a , integer ) ] ) , proc ( main , [ ] , [ assign ( var2 , 3.1 ) , const ( const2 , 2 ) , call ( fun1 , [ const2 , var2 ] ) ] ) ] Program ( List ( Var ( var2 , PrimitiveType ( integer ) ) , Proc ( fun1 , List ( Var ( var1 , PrimitiveType ( real ) ) , Var ( var3 , PrimitiveType ( integer ) ) ) , Block ( List ( Var ( a , PrimitiveType ( integer ) ) ) ) ) , Proc ( main , List ( ) , Block ( List ( Assign ( Id ( var2 ) , FloatLit ( 3.1 ) ) , Const ( const2 , IntLit ( 2 ) ) , ProcCall ( fun1 , List ( Id ( const2 ) , Id ( var2 ) ) ) ) ) ) ) ) Type_Mismatch_In_Statement : assign ( var2 , 3.1 ) [ 082 ] varvar2 : integer ; procedurefun1 ( var3 , var4 : array [ 2,1 ] ofreal ) ; begin vara : integer ; end ; proceduremain ( ) ; begin varvar 4 : real ; var4 : = 3.1 ; constconst2 = 2 ; varmyArr : array [ 2,1 ] ofinteger ; varmyArr2 : array [ 2,1 ] ofreal ; fun1 ( myArr , myArr ) ; fun1 ( myArr , myArr2 ) ; fun1 ( myArr , [ [ 100 ] ; [ 200 ] ] ) ; constarrConst = [ [ 101 ] ; [ 201 ] ] ; fun1 ( myArr , arrConst ) ; fun1 ( myArr , [ [ [ 102 ] ] ; [ [ 202 ] ] ] ) ; end ; [ var ( var2 , integer ) , proc ( fTestcase @ MU : dòng dưới là mảng hằng với dim [ 2,1,1 ] , dòng trên là [ 2,1 ] . @ TN : tầm vực của một hàm biến / hằngtoàncục là toàn_bộ chương_trình , bất_kể nó khai_báo ở đâu : ) Testcase_Ok mình đã sửa lại . Testcase_Bạn nhập cái input của mình và kiểm_tra output . Testcase_Mình mới edit lại test . Sửa từ int thành integer , float thành real . Testcase_Cannot_Assign_To_Constant Testcase_Bạn cứ sửa lại PT để xuất ra dạng như mình đi : ) Testcase_Function bạn.Testcase Uhm sr mình sai test 15 : ) Test 13 mình nghĩ ý thầy là mình phải kiểm_tra lá trong cây phân_tích cú_pháp trước khi kiểm_tra gốc . Mình đã update . Testcase_Vẫn_None bạn.Function Not_Return Ý mình là các đoạn dead code ấy : ) ) Nó chỉ kiểm_tra dead code của if thôi_thì phải : Pkhai báo a : array [ 4 ] - - > gọi a [ 1000 ] Lỗi hay k ? Static check chỉ check số chiều , không check boundary mỗi chiều đâu bạn . Function_Not_Return_Có 2 loại while : 1 . while chắc_chắn được thực_hiện ( while có mệnh_đề điều_kiện luôn đúng ) : mình xem thân nó như một block bình_thường . 2 . while không chắc đúng hoặc while luôn sai : không cần xem_xét . Tương_tự cho loop . Function_Not_Return_Đây là static check : ) Function_Not_Return có chứ , vd while true . Function_Not_Return các bạn cứ yên_tâm là cái nào k có trong đặc_tả sẽ k có trong testcase : pFunction Not_Return 1 > 0 vẫn là true : ) ) Thựcchấtstaticcheckcũngbaogồmnhữngcáinàynữa , tuỳvàongườiđịnhnghĩathôi , VDnhưmấycáiIDEjavađó , netbeans hoặc Eclipsechẳnghạn , nóvẫncheckmấycáiđóđó : D_Cái này a Hùng bảo làm chứ nếu_không thì ass này đơn_giản quá , còn có test hay ko thì mình ko rõ : ) ) Function_Not_Return_Hi thựcsựnếunỏđi cácthứ khóthìbạnsẽthấynórấtdễ : ) ^ ^ Nói_chung các bạn có làm hay ko thì tuỳ , nếu_không làm cái đó , thì các execution path sẽ loại_bỏ hoàn_toàn các vòng lặp ( mặc_định xem như nó ko đc thực_thi ) , lúc đó mọi chuyện lại quá đơn_giản : ) . type checking của Scala_Cái toán_tử | có độ ưu_tiên thấp hơn hàm pack ^ ^ Testcase_Các bạn thử test này nhé : ) http : / / www.vhn.vn/u/tes.zipRe : Testcase_Cai do dau co trong file dac ta , sao ' lai la delimiter dc Re : Testcase_Uh mình quên xét độ ưu_tiên , bạn tải lại kiểm_tra nhé . Re : Testcase là delimiter , đã edit lại testcase , các bạn kiểm_tra nhé . Re : Testcase @ axe : Bạn tải bản cũ rồi , tải lại bản mới đi . @ Lost : http : / / en.wikipedia.org/wiki/DelimiterRe : Testcase_Theo như mình đọc thì delimiters có 2 loại : token và non - token
