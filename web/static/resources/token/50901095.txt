Cách biên_dịch Prolog trong Eclipse_Bước 1 : Cài SWI-Prolog . 1 . Vô trang http : / / www.swi-prolog.org/download/stable , download file SWI - Prolog 5.10.5 . 2 . Chạy file tải về để cài . 3 . Set biến PATH : 3.1 Windows 7 : Nhấp phải Computer - > Properties - > Advanced system settings - > Tab_Advance - > Enviroment_Variables ... Windows XP : Nhấp phải Computer - > Properties - > Tab_Advance - > Enviroment_Variables ... 3.2 Chọn biến PATH trong System variables - > Edit ... - > thêm dòng % prolog % \ bin ( % prolog % là thư_mục cài đăt SWI-Prolog nha ) . 3.3 Khởi_động lại máy . Bước 2 : Cài_đặt tool Prolog cho Eclipse 1 . Chạy_Eclipse - > Help - > Install_New_Software ... - > Add . 2 . Mục_Name để tên nào cũng được ^ ^ ( mình để là Prolog > " < ) , mục Location thì copy đường link sauhttp : / / sewiki.iai.uni-bonn.de/public-downloads/update-site / 3 . Nhấp OK 4 . Mở_rộng 2 nhánh " Program_Analysis and Transformation " với " Prolog_Development_Tool ( PDT ) " 5 . Chọn 2 mục " JTransformer " và " Prolog_Development_Tools " . 6 . Nhấp_Next và cài thôi : D_Cách sử_dụng : 1 . Tạo 1 empty project : File - > New - > Project ... - > General - > Project - > Next - > Đặt tên project - > Finish 2 . Nhấp phải tên project - > New - > File - > đặt tên file có phần mở_rộng là . pl ( vd : Demo.pl ) 3 . Viết code trong file vừa tạo - > save file ( phải save trước nha ) 4 . Từ menu Prolog - > Prolog_Console 5 . Để build file Prolog , chọn Prolog - > ( re ) consult - > xuất_hiện mấy cái predicate trong cửa_sổ Outline ( nếu nó không xuất_hiện là bị lỗi đó ) 6 . Trong cửa_sổ Project_Console , mình viết mấy câu query thôi ^ ^ 7 . còn để debug thì gõ " noguitracer . " , rồi gõ theo cú_pháp " trace , p ( X , Y , Z ) . " Link : http : / / sewiki.iai.uni-bonn.de/research/pdt/start P / S : Cái này mình mới tìm ra , chia_sẻ cho anh_em ^ ^ Re : Element of array ! Parse thành_công [ proc ( a , [ par ( x , float ) ] , [ assign ( a , b ) ] ) ] Một_số vấn_đề trong Lab4 Có một sô đoạn code mà mình không hiểu cho lắm , mong thầy với các bạn giải_đáp , cụ_thể : 1 . assert ( ) 2 . Toán_tử : : : 3 . scala.Function.tupled { ... } " trong hàm typeof ( ) Re : Lab4 Bạn phải tạo 1 package có tên là sl 2 , trong package đó bạn tạo 1 file Scala_Object , rồi copy code lab 4 vào file Scala_Object là xong . Re : lab 5 mấy bạn biết câu 5 làm_gì không ? ? Mình chép nguyên code của thầy vô chạy ok luôn mà , không biết làm_gì với cái hàm min hết > " < Re : Hỏi về nhận_dạng array ở stage 1 trong phần Failure ( msg , next ) trong hàm show ( ) , bạn thay chuỗi " " thành result . toString để xem lỗi trong quá_trình viết parse sau_này xử_lí chỗ Failure ( msg , next ) sau.Giá trị của biến toàn_cục Nếu biến x là biến toàn_cục thì x có được xem là được gán giá_trị ban_đầu hay x không có giá_trị ? ? vd : / / 1 var x : real ; procedure main ( ) ; begin write Real ( x ) ; end ; / / 2 var x : real ; procedure main ( ) ; begin x : = 1.0 ; writeReal ( x ) ; end ; Trường_hợp 1 : 1 Not_Defined_Before_Used , 2 None_Trường hợp 2 : 1 None , 2 NoneRe : Lỗi utf ? ? ? Bạn thử copy code rồi paste vào Notepad , lưu lại file khác . Trong hộp_thoại Save_As ... , mục Encoding chọn ANSI - - > Save . Mở lại file đó rồi copy code vào trình biên_dịch coi còn lỗi không ? Re : ai cứu với hix hix ... xóa cái code đi bạn , lỡ ai chép lại bi gian_lận nữa Re : Hỏi về Array_Constant vd : const a = [ ' 123 ' ] ; Trường_hợp này parse thành_công hay sẽ thông_báo lỗi . 1 . Parse thành_công : Cú_pháp chấp_nhận , còn kiểu của phần_tử array constant có_thể được kiểm_tra ở bước kiểm_tra kiểu . 2 . Bị lỗi ở ' 123 ' Hỏi về Array_Constant T . D . N wrote : Mình thấy đặc_tả nói các phần_tử của array constant đâu có kiểu string đâu bạn Mình cũng làm theo ý bạn , nhưng hỏi lại cho chắc ^ ^ Re : Hỏi về Array_Constant_Mình cũng nghĩ là trường_hợp trên mới đúng . Theo đặc_tả : The elements may be integer , real , boolean or array constant . Nghĩa_là phần_tử trong array constant [ ( 3 ) ] không chứa có phần_tử ( 3 ) vì ( 3 ) là 1 biểu_thức Thắc_mắc về các toán_tử Có 2 chỗ trong ngôn_ngữ Crazy mà mình không rõ , mong thầy với mấy bạn giải_thích giùm : : ( 1 . Nếubiểu thức là : 1 < 2 > = 3 thì_có được chấp_nhận bởi ngôn_ngữ Crazy không ? 2 . toán_tử trừ ( - ) được dùng trong kiểu nguyên với kiểu thực thì khi nào toán_tử - là unary - , khi nào_là binary - ? ? function call ? ? ? Thầy có_thể cho em biết định_dạng lời gọi hàm ( function call ) là sao không ? + độ ưu_tiên , em thấy có khai_báo định_nghĩa hàm mà không thấy có chỗ nào nói về lời gọi hàm hết . Re : function call ? ? ? mình thấy rùi ^ ^ . Thanks mấy bạn nha Re : một trường_hợp về hằng chuỗi / * delete * / Giúp mình khai_báo BooleanLiteral với ! ! ! ! ! Lions wrote : Mình khai_báo boolean thế_này def boolean Literal : Parser [ BooleanLiteralPT ] = elem ( " boolean " , _ . isInstanceOf [ lexical.BooleanLit ] ) ^ ^ { a = > new BooleanLiteralPT ( a.chars ) } và chỗ regex mình thêm vào regex ( " " " true | false " " " . r ) ^ ^ { BooleanLit ( _ ) } nó không báo lỗi nhưng vẫn không hỉu hàm def boolean Literal mấy bạn giúp mình với ^ ^ Cách 2 : cho regex ( " " " true | false " " " . r ) ^ ^ { BooleanLit ( _ ) } lên trướcregex ( " [ a - z ] [ a-zA - Z] * " . r ) ^ ^ { processIdent ( _ ) } = > hết lỗi : ) Re : IF_ESLE Ban đọc kĩ đặc_tả một_chút : if <expr> then <statement> nếu theo bạn thì " <expr> ; <expr> " sẽ là <expr> = > " ; " là 1 toán_tử ? nên không có trường_hợp if <expr> ; <expr> then <statement> Vài_Question mong mọi người giúp_đỡ ( rất gấp ) DoomAce wrote : Mình chỉ còn đêm nay để hoàn_tất ass 1 thôi , sáng_mai phải về quê sớm rồi , có vài câu_hỏi thôi , mong ai biết giúp mình nhé : 1 . Trong hàm def show , mình hiểu hướng để làm nhưng ko hiểu cách_thức trình_bày cái unexpected token sao ko đc chấp_nhận : " line " + < > + " : " + < > " : " + " unexpected token : " + if ( ... . . ) { ... . . } else { ... . . } Có bạn nào biết sai ở đâu nhắc mình tí với , dấu + dùng ở đây có phù_hợp ko ? Bạn thử dùng ( ) đối_với biểu_thức if , như_thế_này nè : " line " + < > + " : " + < > " : " + " unexpected token : " + ( if ( ... . . ) { ... . . } else { ... . . } ) Re : hỏi thông_số vào của call procedure CallStmtPT không chấp_nhận list = null đâu , lớp CallStmtPT chỉ nhận kiểu list và list này có_thể rỗng ( list.isEmpty = = true ) . Do_đó , bạn chỉ cần xử_lí trường_hợp case a ~ lst là đủ rồi Re : hỏi thông_số vào của call procedure Phần class CallStmtPT trong file PT nè bạn : class CallStmtPT ( val ident : IdPT , val exprs : List [ ExprPT ] ) extends StmtPT { override def to String = " call ( " + ident + " , " + " [ " + ( if ( ! exprs.isEmpty ) ( exprs.head.toString / : exprs.tail ) ( _ + " , " + _ . toString ) else " " ) + " ] ) " } exprs luôn có , nhưng exprs có_thể rỗng . P / s : Nil có khác null không ? ? Re : access Array_Element ? ? ? ? Cho mình hỏi trường_hợp này xuất ra cái gì : procedure main ( ) ; begin a : = true [ 2 ] ; end ; Re : access Array_Element ? ? ? ? Đỗ_Sỹ_Hưng wrote : Cho mình hỏi trường_hợp này xuất ra cái gì : procedure main ( ) ; begin a : = true [ 2 ] ; end ; Theo tình_hình mình hỏi mấy bạn thì_có 2 kết_quả cho trường_hợp này : 1 . Xuất ra error : " [ " 2 . Xuất ra error : " true " Mấy bạn cho ý_kiến nha , mình đã chỉnh code và cũng đã parse ra 2 trường_hợp trên
