Return_String , Array_Thấy cho em hỏi . Trong đặc_tả có đoạn như_thế_này : For a return statement , the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . For an assignment statement , the LHS can be in real , integer or boolean type . The right - hand side ( RHS ) is either in the same type as that of the LHS or in the type that can coerce to the LHS type . In_Crazy , just the integer can coerce to the real . Vậy nếu xem kiểu trả về như_là một LHS thì kiểu trả về chỉ có_thể là real , integer hoặc boolean . Không được trả về kiểu string hay array đúng không ạ ? For a call statement , the callee must be in procedure type and the number of arguments must be equal to that of callee parameters . In addition , for parameter passing , the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS . Tương_tự , parameter có_thể là kiểu string không ? Re : Scope của biến global ? ? ? procedure demo ( ) ; begin y : = true ; var y : integer ; y : = 0 ; end ; var y : boolean ; = > None_Test case này test tầm vực nè , ra None là ok Re : Scope của biến global ? ? ? var x : real ; function demo ( a : real ) : real ; begin return 0 ; end ; procedure main ( ) ; begin var demo : real ; x : = demo ( demo ) ; end ; Cái này sao mấy bác ? ? biến demo có che hàm demo không ? Nếu_không che thì có_thể gọi demo ( demo ) Function demo ( biến demo ) ko ? Re : Scope của biến global ? ? ? Most closed nested rule : For every applied occurrence ( i . e . , use ) of an identifier I in a block A , there must be a corresponding declaration of I . The declaration is in a block that is smallest enclosing the applied occurrence of I . Due to the above rule , the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block . = Tầm vực của một định_nghĩa không bao_gồm tầm vực của định_nghĩa khác cùng tên bên trong một block . Ví_dụ : function demo ( ) : real ; begin return 0 ; end ; procedure main ( ) ; begin var demo : real ; = > Chổ này không thấy hàm demo nữa . end ; Re : Thi cuối kỳ Vote cho đề đóng Lab4 Bai 1 : cho minh hoi Trong ubuntu Ctrl + z thi khong co hien tuong gi xay ra het , minh hoi mot so nguoi dung windows thi ok . Vay la sao nhi ? Re : Lab4 nguyen dung wrote : Nếu nó không dùng Ctrl + Z được thì bạn_đọc từ file , chữa_cháy cũng được đó , new Input ... ( new FileInput ... ( new File ( " path " ) ) Thanks ban ... chay OKRe : định_nghĩa path of the execution of the function ? Vậy chương_trình sau có bao nhiểu đường thực_thi . var a : boolean ; function func ( ) : real ; begin if a then return 1 ; end ; Re : định_nghĩa path of the execution of the function ? Vậy nếu trong chương_trình có một câu_lệnh return ở ngoài thì trong if else , while , loop không cần xét nữa đúng ko ? Vì đường thực_thi luôn đi qua câu_lệnh return này Ví du 1 : var a : boolean ; function main ( ) : real ; begin if a then a : = true ; return 0 ; end ; Ví du 2 : var a : boolean ; function main ( ) : real ; begin return 0 ; if a then a : = true ; end ; 2 trường_hợp trên có báo lỗi không Re : Testcase cho stage 2 procedure main ( ) ; begin a : = [ 1 ; true ] ; end ; vậy nếu có testcase như_vậy thì kết_quả là gì ? line 3 : 10 : unexpected token : true hay [ proc ( main , [ ] , [ assign ( a , [ 1 ; true ] ) ] ) ] Re : Biểu_thức hằng ? ? Const array có tính không ? Nếu tính thì chỉ_số của Array được đánh_bắt đầu là 0 hay_là 1 ? function main ( ) : real ; begin const a = [ 1 ; 2 ; 3 ] ; const b = [ [ 1 ; 0 ] ; [ 4 ; 3 ] ] ; var c : real ; if ( a [ 1 ] <> b [ 1,1 ] ) then c : = 0 ; return 0 ; end ; Nếu đánh là 1 thì_ra thế_này a [ 1 ] = 1 b [ 1,1 ] = 1 = > if ( a [ 1 ] <> b [ 1,1 ] ) then c : = 0 ; = if ( false ) then c : = 0 ; = > None_Còn đánh là 0 thì a [ 1 ] = 2 b [ 1,1 ] = 3 Function_Not_Return : mainTestcase vanhoa wrote : Vẫn_None bạn . đâu có đúng đâu ? Ngoài câu lện if else , while , loop , block thì các câu_lệnh còn lại vẫn phải tính là 1 đường thực_thi chứ . vidu : function main ( ) : real ; begin var a : real ; end ; với function main ( ) : real ; begin if false return 0 ; var a : real ; end ; thì_sao ? Re : Testcase_Test case Vui procedure demo ( ) ; begin y : = true ; var y : integer ; y : = 0 ; end ; var y : boolean ; = > NoneRe : Testcase var x : real ; function demo ( a : real ) : real ; begin return 0 ; end ; procedure main ( ) ; begin var demo : real ; x : = demo ( demo ) ; end ; Ra gi cac bac ? Re : Testcase function main ( ) : string ; begin return ' a ' ; end ; Ra gi ? Re : Testcase_Test này : Test # 7 Program proceduremain ( ) ; begin constv = 0 ; v : = 0 ; end ; INPUT [ proc ( main , [ ] , [ const ( v , 0 ) , assign ( v , 0 ) ] ) ] OUTPUT Cannot_Assign_To_Constant : v Hình_như chưa đúng : Ouput là " Cannot_Assign_To_Constant : <satement> " chứ đâu có phải là Cannot_Assign_To_Constant : <identifier> đâu Hòa ? Re : Testcase procedure main ( ) ; begin const a = [ 1 ; 2 ; 3 ] ; a : = [ 1 ; 3 ; 4 ] ; end ; Test thu . Testcase vanhoa wrote : Cannot_Assign_To_Constant_Văn_Hòa có sửa lại PT đúng không ? Theo mặc_định thì Parser xuất ra constant array ở dạng [ 1 ; 2 ; 3 ] nhưng ass 2 yêu_cầu dạng array ( [ 1,2,3 ] ) Re : Testcase function read Int ( d : real ) : real ; begin var d : real ; return 0 ; end ; = > Redeclared_Variable : d hay Redeclared_Function : readInt ? Phải kiểm_tra hàm trước rồi mới kiểm_tra biến chứ nhỉ ? Re : Testcase_Testcase 1 : function func ( ) : integer ; begin var a : integer ; if true then a : = 0 ; return 0 ; end ; Testcase 2 : function func ( ) : integer ; begin while true do begin end return 0 ; end ; Trường_hợp function not return Kết_quả là gì mọi người ? Re : Testcase_Hòa coi lại Test # 13 nha Type_Mismatch_In_Statement : <statement> is released . The type rules for statements are as follows : - The type of a conditional expression in an if , or while statement must be boolean . - The type of the expression in a loop statement must be integer . - For an assignment statement , the LHS can be in real , integer or boolean type . The right - hand side ( RHS ) is either in the same type as that of the LHS or in the type that can coerce to the LHS type . In_Crazy , just the integer can coerce to the real . Cái này thì chỉ có_thể là Variable real , integer hoặc boolean thôi . test 13 gán cho function thì báo lỗi Type_Mismatch_In_Statement : assign ( f , add ( add ( sub ( a ) , times ( b , d ) ) , call ( f , [ 1 ] ) ) ) Ko cần check vế phải nữa . Re : Testcase_Test 15 : proceduretest ( a : string ) ; begin end ; proceduremain ( ) ; begin test ( 1 ) ; end ; Output phải là chứ Type_Mismatch_In_Statement : call ( test , [ 1 ] ) test ( 1 ) ; là câu_lệnh mà Re : Testcase_Test 35 functionmain ( ) : real ; begin while 1 = 1do return1 ; loop1do return1 ; if1 = 1thenreturn1 ; end ; = > None vay bay gio them 1 dong lenh vao functionmain ( ) : real ; begin while 1 = 1do return1 ; loop1do return1 ; if1 = 1thenreturn1 ; var a : real ; end ; = > Ket qua la : " Function_Not_Return : main " hay la None ? câu_lệnh Return_Thấy cho em hỏi . Trong đặc_tả có đoạn như_thế_này : For a return statement , the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . For an assignment statement , the LHS can be in real , integer or boolean type . The right - hand side ( RHS ) is either in the same type as that of the LHS or in the type that can coerce to the LHS type . In_Crazy , just the integer can coerce to the real . Vậy nếu xem kiểu trả về như_là một LHS thì kiểu trả về chỉ có_thể là real , integer hoặc boolean . Không được trả về kiểu string hay array đúng không ạ ? For a call statement , the callee must be in procedure type and the number of arguments must be equal to that of callee parameters . In addition , for parameter passing , the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS . Tương_tự , parameter có_thể là kiểu string không ? Re : file PT.scala Tình_hình là thầy chưa up đâu , hỏi quá_trời mà thấy chưa trả_lời , bạn chỉ cần fix lại PT.scala của Ass1 một_chút là ok Function_Not_Return_Thưa thầy cho em hỏi : function test ( ) : integer ; begin var a : integer ; if true then a : = 0 ; return 0 ; end Vậy có báo lỗi " Function_Not_Return : test " không ? Trong đặc_tả có đoạn : In each path of the execution of the function , there is at least a return statement , otherwise , the error message . Nhưng chương_trình trên chắc_chắn chạy câu lện return cuối_cùng ? Re : Function_Not_Return_Thanh_Pham_Minh wrote : H . T . P ( ^ _ ^ ) wrote : Cho hỏi ngoài_lề 1 tí . nếu trong Proceduce có lệnh return thì sử lý làm_sao ? * For a return statement , the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . * The right - hand side ( RHS ) is either in the same type as that of the LHS or in the type that can coerce to the LHS type . Procedure có return type là gì nhỉ : p Nên mình nghĩ sẽ xuất lỗi Type_Mismatch_In_Statement : . Type_Mismatch_In_Statement : Có_nghĩa là câu_lệnh này bị sai kiểu , còn return trong procedure là sai câu_lệnh , nếu có kiểm_tra thì parser phải kiểm_tra chứ , theo mình nghỉ là StaticChecker không kiểm_tra cái này . Re : Function_Not_Return_Vậy như_thế nào_là một đường thực_thi ? function main ( ) : real ; begin var a : real ; end ; trong begin ... end ; có tính là 1 đường ko ? Nếu có = > yêu_cầu phải có return = > Ví_dụ : function foo ( a : integer ) : integer ; begin if ( a > 0 ) then return 0 ; else return 1 ; writeLn ( ' this line never runs ' ) ; end cũng phải cần 1 câu_lệnh return sau dòng WriteLnThầy cho em hỏi vê hàm Typeof_Trong hàm typeof có đoạn : case IntLit ( _ ) = > PrimitiveType ( " integer " ) case FloatLit ( _ ) = > PrimitiveType ( " real " ) case BoolLit ( _ ) = > PrimitiveType ( " boolean " ) khi gọi typeof cho một số_nguyên ( ví_dụ là số 3 ) thì sẽ ra kiểu là : integer còn khi khai_báo một biến kiểu nguyên thì do parser của Assignment 1 quy đinh thì sẽ có kiểu là : int = > khi so kiểu sẽ không trùng . Vậy PT của Assignment 1 sẽ được sửa lại hay_là em có_thể sửa trong hàm typeof : case IntLit ( _ ) = > PrimitiveType ( " integer " ) thànhcase IntLit ( _ ) = > PrimitiveType ( " int " ) Lỗi array constant procedure main ( ) ; begin var c : array [ 0 ] of real ; c : = [ 1.2 ] ; end ; sử_dụng array constant bất_kỳ chổ nào đều bị báo lỗi : Exception in thread " main " scala.MatchError : [ 1.2 ] ( of class ItemList ) do class ItemList không hiểu [ 1.2 ] . Thầy cho em hỏi : Vậy trong chương_trình có sử_dụng array constant như trên không ạ ? Token ? ' ' có phải là một token không vậy mọi người ? Re : Const_Array này nhận được ko vậy mọi người nguyen duc thien wrote : array kieu gi cung duoc ma Note that the elements of an array must be in the same type . For example [ 1 ; 3 ; 2 ] [ 3.2 ; . 2E - 2 ] [ [ 1 ; 2 ] ; [ 3 ; 4 ] ] [ ] [ [ 1 ; 2 ] ; 3 ; 4 ] [ 1 ; 2 ; true ] Các phần_tử trong mảng phải cùng kiểu chứ ... Vậy [ [ 1 ; 2 ] ; [ 1 ] ] , [ [ true ; false ] ; [ 1 ; 2 ] ] được không vây ? Const_Array này nhận được ko vậy mọi người Just A_Tee wrote : Vậy [ 1 ; false ; 3.5 ] với [ [ 2 ; 4 ] ; 3 ; true ] parse thành_công không mọi người ? mình nghỉ [ 1 ; false ; 3.5 ] không được , cái này mình có_thể kiểm_tra token được mà : a [ ListInteger token | Listboolean token ... ] = > cac phan tu tron array phai cung kieu thi co the kiem tra duoc . chi co truong hop a [ [ 2 ; 3 ] ; [ true ; false ] ] la khong kiem tra duoc thoi ... vi 2 phan tu trong mang a deu la mang ca = > chap nhan , con kiem tra kieu tiep nua thi ko duoc . ( ass2 ) Test case la : const a = ' ' ' ' ' ' ; / / 6 dau ' const a = ' " ' / / dau ' , dau ' ' , dau ' May ban chay thu ra ket qua j ? hinh nhu ham thay viet co van de . Test case la : Nhat_Nguyen wrote : line 2 : 44 : unexpected token : const a = ' ' ' ' ' ' ; chi co cai do thoi ... sau dau / / la minh viet chu thich cho ba thoi Re : Test case la : Nguyễn_Thanh_Linh wrote : với input của @ Nhan , ra như trên . Còn với input là const a = ' ' ' ' ' ' ; / / 6 dau ' const a = ' " ' ; / / dau ' , dau ' ' , dau ' của tui đây : [ const ( a , ' ) , const ( a , " ) ] vay la sai roi do ban . ham cua thay la : neu co hai dau ' thi bo di mot dau , co dau ' ' thi nhan doi thanh ' ' ' ' ; ban thu chay 2 cai nay lai coi const a = ' ' ' a ' ' ' ; const a = ' a " ' ; Re : String_Literal_Nguyễn_Thanh_Linh wrote : Code mẫu cho thấy : khi 1 token là StringLit rồi thì xử_lí là : - các dấu nháy đơn liên_tiếp nhau được cắt_giảm thành 1 dấu nháy đơn . - các dấu nháy_kép đều được nhân đôi , trừ dấu nháy_kép ở vị_trí đầu string ( nếu có ) thì giữ nguyên không nhân đôi . Theo mình đây là cách xử_lí có chủ_ý của anh_ấy . các output đều ra theo quy_luật này . sao lai ' ' trừ dấu nháy_kép ở vị_trí đầu string ( nếu có ) thì giữ nguyên không nhân đôi . ' ' vay ? co the la do thay viet sai cho nay .
