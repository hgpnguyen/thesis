Re : Các bạn cho mình hỏi về cái def Show tý nhé ! cơ_bản thì dùng hàm clean ( ) như mấy bạn trên kia . kết_hợp thêm 1 số hàm về StringBuilder : Re : Kết_quả assignment 1 - stage 2 Test 39 failed
Correct result compares with your result
1d0
< line 3 : 16 : unexpected token : 9.8
\ No newline at end of file
Em bị lỗi này hầu_hết . Mong thầy xem_xét .
Nguyễn_Quốc_Toản
MSSV : 50602564Re : Phân_biệt SUB và NOT Tks_Tan_Phat Re : Hỏi về nhận_dạng array ở stage 1 Khi test : const h = [ 23 ] ; bên TOKEN = > ` const ' identifier h ` = ' [ 23 ` ] ' ` ; ' EOF ben PARSER = > màn_hình console trống_trơn , không lỗi , không kêt quả các bạn biết vì_sao không ? ^ ^ Re : Hỏi về nhận_dạng array ở stage 1 @ Long_Potter : mình sai chỗ phần real , nên mât ' tong stage 1 : ( ( . pm : tks bạn Re : Hỏi về nhận_dạng array ở stage 1 nhưng còn trường_hợp : ben PARSER = > màn_hình console trống_trơn , không lỗi , không kêt quả mình không biêt bắt_mạch sao luôn Re : Statements-IfStatement vẫn bị lỗi kiểu ở case a ~ b ~ c = > new IfStmtPT ( a , b , c ) a là cái ExprPT kiểu được trả về từ IfStmtPT , vậy_sao lại báo lỗi , mình vẫn còn nhập_nhằng chỗ kiểu này quá . bạn nào giúp mình với . Re : BooleanLiteral mình nghĩ là đúng vì mấy thầy định_nghĩa StringLiteralPT là extend của LiteralPTRe : giúp_đỡ phần khai_báo array Ko bạn nào giúp mình đc ở cái array Type sao : ( Re : giúp_đỡ phần khai_báo array Scala ^ ^ wrote : def var Dec : Parser [ List [ VarDecPT ] ] = ( " var " ~ > identlst < ~ " : " ) ~ ( varType < ~ " ; " ) ^ ^ { case a ~ b = > { List ( new VarDecPT ( new IdPT ( a ) , b ) ) } theo mình hiểu là phải lấy từng phần_tử của identlst để new VarDecPT , mà code như sau thì bị lỗi case a ~ b = > a.map ( x = > List ( new VarDecPT ( new IdPT ( x ) , b ) ) ) : ( ( ( vẫn bị lỗi ở dòng map Dòng map bỏ List trước new VarDecPT đi vì trong hàm map nó tự_động tạo 1 List cho các phần_tử sau = > nên bạn thêm List vào đó bị dư nó báo lỗi List [ List [ ... . . ] ] Khai_báo const def const Dec : Parser [ ConstDecPT ] = ( " const " ~ > ident < ~ " = " ) ~ ( intLiteral < ~ " ; " ) ^ ^ { case a ~ b = > new ConstDecPT ( new IdPT ( a ) , b ) } mình khai_báo const cho int như trên , nhưng sao nó báo lỗi chỗ : def one Dec : Parser [ List [ SubtinePT ] ] = varDec | constDec | procDec ^ ^ { case a = > List ( a ) } các bạn giúp mình với . Re : Khai_báo const ^ ^ , tks bạn . lúc đầu mĩnh nghĩ là cả cụm ( varDec | constDec | procDec ) sẽ dùng chung với { case a = > List ( a ) } Re : Mấy bạn cho mình hỏi lỗi này vấn_đề 2 bạn sửa lại dấu ( a : \ lst ) = > > > > > ( a / : lst ) Re : Mấy bạn cho mình hỏi lỗi này @ M . U , đúng là mình lầm_lẫn chỗ đó . mình nghĩ đây là 1 cách : rep ( expr ~ ( " ^ " ) ) ~ exprRe : Hỏi về Array_Type và Array_Element @ Tri : cách của Trí đúng rồi đó @ Theo van NasregasRe : Hỏi về Array_Type và Array_Element BUT khi parser : var z : array [ 1 ] of integer ; thì báo lỗi ở OF : var z : array [ 1 ] of integer ; Re : Hỏi về Array_Type và Array_Element : D , fixed được rồi . do dư khoảng trắng sau of " of " Re : Hỏi về Array_Type và Array_Element bạn check lại primitive Type xem hoặc test trước với integer Type xem
