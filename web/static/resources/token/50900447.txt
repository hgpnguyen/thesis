Re : Scope của biến global ? ? ? Mình làm theo đặc_tả là toàn_bộ chương_trình , chạy không báo lỗi , còn trước hay sau thì tùy cách duyệt thôi Re : Scope của biến global ? ? ? Còn trong thực_tế thì cái biến demo nó nằm trước hàm demo , nên gọi ra báo lỗi , khi gọi typeof cho demo thì không_thể_nào demo vừa là hàm mà_lại vừa là biến , Nhân cho VD ác quá : ) Re : Element of array ! Nghe_nói thầy phụ_trách đi Thái tham_gia ACM rồi : ( Re : Các bạn cho mình hỏi về cái def Show tý nhé ! Bạn cho xuất cái next . first ra rồi chỉnh_sửa cho đẹp là được mà ^ ^ Re : Các bạn cho mình hỏi về cái def Show tý nhé ! @ tran danh hung : Của mình raline 2 : 1 : unexpected token : bcRe : Lab 3 Mấy dấu " ( " " ) " bạn thêm vào trong quá_trình transform . KQ ra chắc thầy viết lộn , ra thế_này chứ nhỉ ( 3 - ( 4 * 5 ) ) Re : Lab4 Nếu nó không dùng Ctrl + Z được thì bạn_đọc từ file , chữa_cháy cũng được đó , new Input ... ( new FileInput ... ( new File ( " path " ) ) Re : Testcase cho stage 2 dấu " - " đó là 1 ngôi đó bạn . Re : Testcase cho stage 2 Hơ vậy rốt_cuộc mình có phải parse array constant không vậy ? Thầy xác_nhận chỗ này dùm tụi em với Testcase cho stage 2 @ Tan_Phat : thầy Tân nói là không kt phạm_vi break và continue @ Scala ^ ^ : cũng thắc_mắc giống bạn này , mình thấy class EleExprPT và ArrayLiteralPTcó xử_lý chỗ null , nên mình nghĩ là parse thành_công . VD : function a ( ) : real ; begin const a = [ ] ; / / array rong a : = [ ] ; a [ ] : = b [ ] ; / / truy cap dia chi rong end ; Output : [ func ( a , [ ] , float , [ const ( a , [ ] ) , assign ( a , [ ] ) , assign ( a , b ) ] ) ] Mấy bạn xem chỗ này thử he P / S : VD : var a : array [ 7,0,1 ] of real ; Output : line 1 : 17 : unexpected token : 0 Ra vậy phải không mọi người ? Re : Testcase cho stage 2 class EleExprPT ( val id : IdPT , val exprs : List [ ExprPT ] ) extends LefHandSidePT { ... if ( exprs ! = null ) ... else ... } class ArrayLiteralPT ( val ele : List [ LiteralPT ] ) extends LiteralPT { ... ( if ( ! ele . isEmpty ) ( ele.head.toString / : ele.tail ) ( _ + " ; " + _ ) else " " ) + " ] " } Nếu_không rỗng sao thầy code thêm else ? ? Re : Testcase cho stage 2 1 ) trường_hợp var x : array [ 0 ] of integer cũng sẽ parse thành_công phải ko ạ ? Parse thành_công " The integer constant represents the size of the corresponding dimension and it must be a positive number , i . e . number greater than 0 " Chỗ này cũng mâu_thuẫn với đề nè cái demision đề nói phải > 0 mà này parse thành_công . Nguồn : https : / / elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3407.pageRe : Testcase_Test # 84 varx : integer ; proceduremain ( ) ; begin while ( 1 > x ) do begin varz : real ; begin break ; end z : = 1 ; z : = z ; / / ( 1 ) end end ; z nằm sau break vậy phép gán z : = 1 ; có tính không ? Mình ra Not_Defined_Before_Used : zRe : Testcase_Mới sửa lại ra NoneRe : Testcase_Cái test 70 functionmain ( x : boolean ) : real ; begin if not ( falseandx ) thenreturn1 ; end ; Chỗ đó - > if ( true ) then return 1 ; bình_thường mà_sao Hòa báo lỗi Function_Not_Return : mainRe : Testcase_Sao cái test 6 ra ngộ vậy Hòa : Type_Mismatch_In_Statement_Some ( Symbol ( main , ProcType ( List ( ) ) , Procedure ) ) : assign ( main , 0 ) Ra : Type_Mismatch_In_Statement : assign ( main , 0 ) thôi chứ nhỉ ? Re : Testcase LHS trong đặc_tả không nói kiểu String nhưng_mà trong file lại định_nghĩa 2 proc sau Symbol ( " writeStr " , ProcType ( List ( PrimitiveType ( " string " ) ) ) , " Procedure " ) Symbol ( " writeStrLn " , ProcType ( List ( PrimitiveType ( " string " ) ) ) , " Procedure " ) Vậy_là chạy 2 proc này luôn báo lỗi , có mâu_thuẫn gì không nhỉ ? Re : Testcase_Nếu trong procedure có return thì báo lỗi Type_Mismatch_In_Statement phải không mấy bạn , trong đặc_tả hình_như không nói . Re : lỗi trong file Util.scala . Mong anh Hùng xem_lại giúp Chắc bạn sửa chưa hết cái PT rồi mình chạy bt : Program ( List ( Const ( x , ArrayLit ( List ( IntLit ( 9 ) , IntLit ( 8 ) ) ) ) ) ) Bạn xem ArrayLiteralPT trong PT có xuất ra thế_này không override def to String = " array " + " ( [ " + ( if ( ! ele.isEmpty ) ( ele.head.toString / : ele.tail ) ( _ + " , " + _ ) else " " ) + " ] ) " Re : Phần_tử của mảng Trong đặc_tả cũ có ghi : The first index of a dimension is 0 Còn cái đặc_tả mới : For an array subscripting A[ E1 , E2 , ... , En ] , A must be declared as an n - dimensionarray and the type of all Ei must be integer . Trong typeof có đoạn check ! indexes.forall ( typeof ( _ , symbols , declare ) = = PrimitiveType ( " integer " ) mà - 1 - > PrimitiveType ( integer ) . Vậy chỉ_số mảng ở đây có được âm không ? Nếu index > = 0 thì sẽ phải tính cái expr , khá mắc_công - - - - - - - - - - - Mấy bạn chạy thử VD này : procedure main ( ) ; begin var x : array [ 3 ] of integer ; const y = 7 ; x [ a ( y ) + b ( ) ] : = 1 ; end ; function a ( y : integer ) : integer ; begin y : = y-10 ; return y - 1 ; end ; function b ( ) : integer ; begin return - 8 ; end ; Re : string trong Assign ? Như_vậy là phép gán này cũng lỗi luôn à : var a : array [ 2 ] of real ; ... . a [ 0 ] : = 2.1 ; LHS không có array type ? ? Re : Function_Not_Return_Theo như đặc_tả thì chỉ cần return xuất_hiện trong func là đủ , ngay cả khi nó không_bao_giờ chạy = > test trên bt Re : Function_Not_Return_Cảm ơn bạn , mình không đọc kỹ chỗ excution path nên hèn_chi tưởng chỗ đó dễ òm : ) Re : Function_Not_Return VD này function foo ( ) : real ; begin var a : real ; while ( 1 > 0 ) do if ( 1 > 0 ) then return 1 ; else return 0 ; end ; Return trong while đã đủ , còn trong Block thì_có cần không và , ( nếu cần ) thì trước hay sau While cũng được đúng không ? Re : khai_báo a : array [ 4 ] - - > gọi a [ 1000 ] Lỗi hay k ? Bổ_sung câu_hỏi trên nếu gọi a [ - 4 ] có lỗi không , trong đặc_tả chỉ nói A[ E1 , E2 ... ] thì Ei là kiểu integer thôi Re : khai_báo a : array [ 4 ] - - > gọi a [ 1000 ] Lỗi hay k ? ^ Chỗ bạn nói đâu phải luật của phép gán , nó là kt tương_thích của param và argue mà Cho em hỏi về PrimitiveType Thưa thầy trong file StaticCheck.scala có dòngcase FloatLit ( _ ) = > PrimitiveType ( " real " ) . Còn trong parser tree thìnó ra PrimitiveType ( " float " ) . Vậy nếu làmcase BinaryOp ( ... ) trong hàm typeof thìcase PrimitiveType ( " float " ) = > PrimitiveType ( " float " ) chứ không phảicase PrimitiveType ( " float " ) = > PrimitiveType ( " real " ) ? ? Tương_tự có vd : var man : integer ; Parse ra : Program ( List ( Var ( man , PrimitiveType ( int ) ) ) ) Còntrong hàm typeof case IntLit ( _ ) = > PrimitiveType ( " integer " ) - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - P / S : Còn 1 điểm nữa_là nếu tự định_nghĩa 1 Function sau : function a ( ) : integer ; begin return read Int ( ) ; end ; thì bảng symbols : List ( Symbol ( a , FuncType ( List ( ) , PrimitiveType ( int ) ) , FuncVar ) , Symbol ( readInt , FuncType ( List ( ) , PrimitiveType ( integer ) ) , Function ) ) Tương_tự là trường_hợp real và float function a ( ) : real ; begin return read Real ( ) ; end ; List ( Symbol ( a , FuncType ( List ( ) , PrimitiveType ( float ) ) , FuncVar ) , Symbol ( readReal , FuncType ( List ( ) , PrimitiveType ( real ) ) , Function ) ) Xin thầy xác_nhận là chỗ này để nguyên hay cần sửa lại gì không ạ ? Thắc_mắc về output Thưa thầy cho em hỏi 2 vấn_đề 1 - Nếu có hằng 1.2e0 không thỏa thì sẽ báo lỗi fail hay xuất ra 1.2identifier e0 ? , tương_tự cho các trường_hợp chuỗi và mảng . 2-Trong đề có ghi trường_hợp . 3e-30 là sai , trong đặc_tả ghi sau e là chuỗi không rỗng , không bắt_đầu bằng 0 chứ không nói là kết_thúc phải khác 0 . Xin thầy giải_đáp dùm , em xin cảm_ơn . Re : Thắc_mắc về output Cảm_ơn thầy đã giải_đáp Re : Mot truong hop trong chuoi string The character set ∑ of Crazy is the characters in ASCII . Any character in ∑ except a newline character can be appeared in a string constant . Re : Các_Test_Case " Hóc_Búa " Về_String_Cho mình hỏi " * " và " / " có phải là delimitter không ? Những ký_tự sử_dụng trong String_Phan_Nguyen wrote : Thấy và các bạn cho mình hỏi , những ký_tự nào được sử dung trong một chuỗi ( string ) vây ? Mình đặc_biệt muốn nói đến những ký_tự đặc_biệt như dấu * , + , ? , \ , " . " . Nhân_tiện cho mình hỏi làm cách nào add nó vào regex mà không bị báo lỗi ( nếu chuỗi cho_phép chứa nó ) . Thì bạn dùng 2 cách 1 ) Dùng \ . 2 ) Dùng [ ^ ( ký_tự cần loại ra ) ] Thường thì mình hay dùng cách 2 trong trường_hợp số ký cần loại là ít Re : Mọi người test thử chuổi này xem c . ronaldo wrote : ' ' ' a _ ' ' ' ' màu đen là nháy_kép đó , kết_thúc là ' , nên nó còn dư ra một dấu ' ok ... ... : D thank bác ! ... nhầm chổ này tưởng nháy đơn hết ... : D : D vì tớ đang thấy đặc_tả chổ này có tí vấn_đề : If a single - quote belongs to the string constant , it must be duplicated . Re : Hỏi về Array_Constant_Mấy bạn thử cái này xem : function a ( ) : real ; begin b : = a [ 4 +5 , [ ( 3 ) ] , i + j ] ; end ; Re : Hỏi về Array_Constant_Cái VD ấy ai parse thành_công cho mình xin output he . Re : Hỏi về Array_Constant @ Tan_Phat : sửađộ ưu_tiên là sao bạn ? Re : Hỏi về Array_Constant Ý của mình giống bạn Hưng , mình để chỗ [ ( 3 ) ] nó là const vậy ( 3 ) ? ? , trong const nó không biết " ( " nên báo lỗi . Sửa lại cái VD , lần này tất_cả đều là expr : function a ( ) : real ; begin b : = a [ 4 +5 , ( 3 ) , i + j ] ; end ; Re : Hỏi về Array_Constant_Nếu chỗ & & thay bằng and thì parse bình_thường Re : giúp_đỡ phần khai_báo array def var Dec : Parser [ List [ VarDecPT ] ] = ( " var " ~ > identlst < ~ " : " ) ~ ( varType < ~ " ; " ) ^ ^ { case a ~ b = > { List ( new VarDecPT ( new IdPT ( a ) , b ) ) } theo mình hiểu là phải lấy từng phần_tử của identlst để new VarDecPT , mà code như sau thì bị lỗi case a ~ b = > a.map ( x = > List ( new VarDecPT ( new IdPT ( x ) , b ) ) ) : ( ( ( vẫn bị lỗi ở dòng map Re : token EOF hay <eof> Mặc_định của mình là EOF . muốn xuất ra <eof> thì bạn chỉnh trong hàm show là được mà Re : Một_số câu_hỏi về array Doan_Tuan_Sang wrote : huhu ai chỉ mình với sao mình làm nó ra thế_này [ 1.15 ] failure : int expected var z : array [ ] of integer ; ^ khi sử sụng println ( result ) còn bình_thường không báo gì hết ... Bạn xem hàm int Literal , cái elem có chữ int dùng để xuất khi có lỗi đấy . Bạn sửa cái hàm show cho nó báo lỗi theo ý mình là được thôi Re : String_Literal_Em cũng có câu_hỏi giống như bạn trên , cái output const của String trong code mẫu đã đúng hay chưa bởi trong đề không nói rõ phần này . Re : hỏi về sol của vài case Comment thì nó bỏ_qua không có báo , thầy có code sẵn trong đó rồi , có bạn nào biết trường_hợp nào xảy_ra failure ( " unclosed comment " ) ) không ( trong def whitespace ) .
