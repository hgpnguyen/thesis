Re : Return_String , Array mình nghĩ làđượcđó . Trong specass 1 có ghi " Return type and parameter type can be primitive type or array type . " mà . xem para như LHS vàarg như RHS ý thầy là giữa para vàarg phải có sự tương_thích ( comform ) về kiểu thôi . Re : mong anh Hùng trả_lời : thay da tra loi roi bạn . câu_lệnh gán m : = 1 ko được tính . nhưng câu x : = m + n vẫn check nên sẽ báo lỗi m not difined File PT vẫn chưa tương_thích trong file Util của thầy kiểu int là PrimitiveType ( " integer " ) , kiểu real là PrimitiveType ( " real " ) còn file PT là class IntTypePT extends PrimitiveTypePT { override def to String = " int " } class RealTypePT extends PrimitiveTypePT { override def to String = " float " } VD : procedure c ( ) ; begin var a : real ; var b : real ; b : = 9.0 ; end ; b : = 9.0 bị lỗi vì b kiểu real còn 9.0 kiểu float . Mong thầy xem_lại chỗ này Re : Scope của biến global ? ? ? _ Trung _ Than _ Thong wrote : nhan nguyen van wrote : var x : real ; function demo ( a : real ) : real ; begin return 0 ; end ; procedure main ( ) ; begin var demo : real ; x : = demo ( demo ) ; end ; Cái này sao mấy bác ? ? biến demo có che hàm demo không ? Nếu_không che thì có_thể gọi demo ( demo ) Function demo ( biến demo ) ko ? không báo lỗi gì cả . Theo lý_giải của Nhan bên dưới nhưng_mà 1 cái là biến , 1 cái là hàm thì không liên_quan gì nhau ( nên sẽ không bị che ) . Vd : bạn gọi hàm demo ngay dưới biến demo vẫn OK vì hàm sẽ có cả tham_số nữa mà ( demo ( ) khác với demo ) . @ Dung : Quan trong là cái typeof mình lookup như_thế_nào . Đâu fai cứ lookup cái name vậy rồi nói nó che được Trongass của mìnhđề chỉ nói_chung tên biến , hằng , hàm là identifier chứ có phân_biệt = tên và kindđâu bạn  Most closed nested rule : For every applied occurrence ( i . e . , use ) of an identifier I in a block A , there must be a corresponding declaration of I . The declaration is in a block that is smallest enclosing the applied occurrence of I .  Due to the above rule , the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block . Chỉ cần trùng tên là bị che ở block bên trong rồi . đúng là theo logic bình_thường thì sẽ phân_biệt hàm demo ( ) và biến demo . nhưngởđâyđặc tảđãđơn giảnđi thì mình làm vậyđi ( thầy làm_vậy làđểđơn giản cho mìnhđó ) Scope của biến global ? ? ? các bạn cho mình hỏi biến global có tầm vực như_thế_nào ? kể từ dòng khai_báo biếnđó hay toàn_bộ chương_trình . Tương_tự , 1 hàm cóđược sử_dụng dụng phía trướcđịnh nghĩa hàmđó không ? VD : procedure main ( ) ; begin y : = 1 ; ( 1 ) / / ngay cho nay co bị lỗi không write RealLn ( foo ( y ) ) ; ( 2 ) / / giả_sử dòng trênđúng thì dòng này có báo lỗi không end ; const x = 1.2e3 ; function foo ( p : integer ) : real ; begin return p * x ; end ; var y , z : integer ; Re : Scope của biến global ? ? ? vậy cả 2 VD của mình làđúng hết cả 2 à . ( Chỗ này không hiểu cho lắm nên hỏi lại cho chắc . ) Re : Scope của biến global ? ? ? Spec ass 1 wrote : 2.5 . Example of a Crazy program var y , z : integer ; procedure main ( ) ; begin y : = 1 ; writeRealLn ( foo ( y ) ) ; end ; const x = 1.2e3 ; function foo ( p : integer ) : real ; begin return p * x ; end ; đã giải quyếtđược thắc_mắc . Hàm dùng trước khai_báo sauđược thì biến cũng thế . : ) Thầy cho em hỏi thêm về Access_Array_Element . nhiều bạn cũng thắc_mắc như em . Định_dạng khi truy_xuất 1 phần_tử của array trong Spec là thế_này . [ , … , ] . Nhưng không biết có trường_hợp ko có expr giữa 2 dấu [ ] hay không ? VD : procedure main ( ) ; begin a [ ] : = 3 ; end ; input như_thế_này thì_có parse thành_công hay không . Mong thầy giải_đáp chỗ này vì nhiều bạn cũng thắc_mắc như em và chưa được thống_nhất . Re : Thầy cho em hỏi thêm về Access_Array_Element . nhiều bạn cũng thắc_mắc như em . Em cám_ơn thầy . Re : Các bạn cho mình hỏi về cái def Show tý nhé ! tran danh hung wrote : nguyen dung wrote : @ tran danh hung : Của mình raline 2 : 1 : unexpected token : bc mình thì nghĩ là ra : line 2 : 1 : unexpected token : b mới đúng @ _ @ nguyên cái bc là 1 token đó bạn . cac bạn Test cái này xem . Nhất_Tiếu nại Hà wrote : Nhat_Nguyen wrote : [ proc ( main , [ ] , [ assign ( ele ( a , [ 1.2,1 ] ) , 1 ) ] ) ] zay laf trong kai lefhandside cua minh nhan toan bo lun ha ... . . sao kai mang gi ky the cungx nhan ko bik dat ta thi chang noi gi ? ? ? ? hic ... . . dien lun mat thoi sao lại Spec ko có nói bạn . nó nè : <id> [ <expr> , … , <expr> ] expr là những cái nào thì bạn xem_lại . đúng là a [ 1.2 , 1 ] nhìn hơi kì nhưng ass 1 chỉ làm_tới đây . phần kiểm_tra chỗ đó nằm ở ass 2.Re : cac bạn Test cái này xem . Test này mấy bạn output là gì vậy : const a = b [ 3 ] ; Re : Xem_lại bài thi cuối kì . Xin thầy xem_lại bài thi cuối kì giúp em . Tên : Huỳnh_Phúc_Trí MSSV : 50902923 . Em xin cảm_ơn . tut1 tran danh hung wrote : mấy bạn cho mình hỏi b | a + có độ ưu_tiên ko ? tức_là ( b | a ) + hay b | ( a + ) ? b | a + thì + chỉáp dụng cho a , b | a + = b | ( a + ) . ( b | a ) + thì ap dung cho ca ( b | a ) vấn_đề thầy nói hơi mâu_thuẫn ... ? ? ? Nhất_Tiếu nại Hà wrote : theo thầy nói : const a = ' a ' ; procedure main ( ) ; begin x : = ' test ' ' ' ' prog " " ram ' ; end ; Cấu_trúc PT sinh_ra là : [ const ( a , ' a ' ) , proc ( main , [ ] , [ assign ( x , ' test ' ' ' ' prog " " ram ' ) ] ) ] nhưng trong testsol thứ_hai : const d = 1.23e - 1 ; const e = 12 ; const f = ' qeqwe ' ' qwrqwr ' ; const g = true ; const h = [ 23 ; 45 ; 2 ] ; thầy lại cho kết_quả : [ const ( d , 1.23e - 1 ) , const ( e , 12 ) , const ( f , qeqwe ' qwrqwr ) , const ( g , true ) , const ( h , [ 23 ; 45 ; 2 ] ) ] vậy quá mâu_thuẫn ... thầy giải thik zum tụi em vs ... . ? ? ? ? ? ? ? ? ? thầy đã đính_chính trong phần Noticed , cứ_thế mà làmđịnh nghĩa path of the execution of the function ? đãđọc mấy topic khác mà vẫn chưa hiểuđượcpath of the execution of the function trong Crazy nàyđượcđịnh nghĩa như_thế_nào ? Mỗi ngôn_ngữ có 1đặc tả , cách hiện_thực khác_nhau , vậy_mà thầy cũng chẳngđịnh nghĩa 1 câu.Chẳng biếtđâu mà làm . Biểu_thức hằng ? ? Em có 1 vài thắc_mắc xin thầy giải_đáp . 1 . Thầy cho em hỏi là biểu_thức hằng nghĩa_là trong biểu_thức chỉ có const và giá_trị trực_tiếp . hay biểu_thức hằng là biêu thức có giá_trị không_bao_giờ thay_đổi . VD var x : Boolean ; x : = false ; while ( x or true ) . . thì lúc đó ( x or true ) , có được coi là biểu_thức hằng đúng hay ko ? 2 . Về vấn_đề các điều_kiện loop , while , if , nếu giá các biểu_thức trong đó chắc_chắn đúng hoặc chắc_chắn sai ( với điều_kiện biểu_thức hằng , không có những trường_hợp x < = x hay x < x + 1 ) thì vẫn xem_xét . x có_thể là const hay không ? 3 . Nêu trong biểu thứcđiều kiện mà có biến var thì nóđược xem là khôngđúng không sai phải khôngạ ? 4 . Nếu có while điều_kiện luôn_luôn đúng và trong body có lệnh Ruturn thì mình có cần xem_xét phần dưới while có return hay không ? VD : function foo ( ) : integer ; begin while ( true ) begin return 9 ; end end ; hàm foo trên có bị báo lỗi ko có Return hay ko ? 5 . Câu_lệnh Return có cần có điều_kiện nằm trước break , continue mới được tính như phần h hay không ? Em cám_ơn thầy . Tầm ảnh_hưởng của câu_lệnh Return . Mong thầy giải_đáp giúp . 1.Thầy cho e hỏi là tầmảnh hưởng của câu_lệnh returnđến phép gán tương_tự như break và continue phải không ? ( hy_vọng là sẽ như nhau cho tụi emđỡ khổ ) 2 . procedure pro ( ) ; begin var a , x : integer ; while ( true ) begin while ( true ) begin return 0 ; a : = 0 ; / / câu_lệnh gán này chắc_chắn sẽ khôngđược tính end a : = 9 ; / / câu_lệnh gán này cóđược tính hay không ? end x : = a +1 ; end ; Re : Tầm ảnh_hưởng của câu_lệnh Return . Mong thầy giải_đáp giúp . thầy không thấy câu_hỏi này của mình rồi . có ai giúp mình không Re : Testcase cho stage 2 trường_hợp này có thành_công ko thế function afunc ( ; ) : real ; begin end ; và function fun ( x : real ; : real ) : real ; begin end ; Re : Biểu_thức hằng ? ? Thầy cho em hỏi lại về vấnđề 4 . trong phần Notice thầyđã nói là vẫn check các câu_lệnh nằm phía sau vòng lặpwhile . Nhưngý em muốn hỏi là trongđiều kiện luôn luônđúng thì chương_trình chỉ có 1 luồng thực_thi làđi vàowhile rồi_ra khỏiwhile và tiếp phần còn lại , vậy_thì functionđã có return . Tại_sao bắt buột ngoàiwhile phải có lệnh return nữa ? ( hơi mâu_thuẫn với trường hợpif ( true ) else thì chỉ cần xét nhánhif ) . Em cámơn thầy . Re : Biểu_thức hằng ? ? Mình nghĩ vậy_là hợp_lý rồiđó . Testcase cho stage 2 nguyen dung wrote : @ Tan_Phat : thầy Tân nói là không kt phạm_vi break và continue @ Scala ^ ^ : cũng thắc_mắc giống bạn này , mình thấy class EleExprPT và ArrayLiteralPTcó xử_lý chỗ null , nên mình nghĩ là parse thành_công . VD : function a ( ) : real ; begin const a = [ ] ; / / array rong a : = [ ] ; a [ ] : = b [ ] ; / / truy cap dia chi rong end ; Output : [ func ( a , [ ] , float , [ const ( a , [ ] ) , assign ( a , [ ] ) , assign ( a , b ) ] ) ] Mấy bạn xem chỗ này thử he P / S : VD : var a : array [ 7,0,1 ] of real ; Output : line 1 : 17 : unexpected token : 0 Ra vậy phải không mọi người ? sao const array rỗng mà_lại parse được nhỉ . còn cái elem có định_dạng <id> [ <expr> , … , <expr> ] . nên mình nghĩ nó cũng ko rống như a [ ] dược đâu . Mọi người cho ý_kiến ? ? Re : có được dùng biến var thay cho val ? ? hồi đó đề có ghi là cấm . còn lần này đề không cấm thì cứ xài thoải_mái . Lo_xa . Re : có được dùng biến var thay cho val ? ? spec không cấm , bạn spam kiểuđó thầy không nói j tức_là không saođó . đừng spam nữa bạn ah . xài var vô tưđi Tổng_hợp lại các trường_hợp của bonus Mình xin tổng_hợp lại tất_cả các trường_hợp như sau . Nếu có j sai thì thầy và các bạn nóiđể mình sửa lại . Nếu_không thì chắc là nóđúng . 1.While ( true ) coi nó như_là 1 block bình_thường , mọi câu lện gán , return trong nó vẫn được tính nếu thỏađiều kiện : - assign phải trước break , continue , return ( vì return tươngđương break - trong notice thầy đã nói ) ; - return phải nằm trước break , continue . 2.While ( false ) vàwhile ( unknown ) Coi như ko cówhile , mọi câu lệnhassign và return trong bodyđều khôngđược tính ( không hợp_lệ ) . 3 . if ( true ) các câu_lệnh gán và return hợp lệở nhánh if đềuđược tính . 4 . if ( false ) Coi như ko có - không xem_xét . 5.if ( unknown ) Coi như_không có 6.if ( true ) ... else coi như ko có else vàáp dụng như trường_hợp 3 . 7 , if ( false ) ... else ... Coi như_không có nhánhif vàáp dụng trượng hợp 3 . 8.if ( unknown ) else ... Phải có lênh gán , return hợp lệở cả 2 nhánh . các trường_hợp nói trên chi tính cho case h , i . mọi lỗi khác vẫn test bình_thường . Re : Tổng_hợp lại các trường_hợp của bonus Coi nhu khong co tuc la moi cau lenh assign va return trong block do deu coi nhu khong có ( có cũng không tính ) . : DRe : 4 Testcase ! cais test 1 tùy theo kiểm_tra cái nào trước . Nếu KT nó có phải constant hay ko trước thì_ra connotassign . Nếu KT type của nó trước thì_ra type mismatchexpr . Thầyđã nói test chỉ có 1 lỗi.Re : Testcase test 65 : const b True = true ; function main ( b : boolean ) : boolean ; begin var x , y : real ; while b do begin x : = 7 ; end x : = x ; return false ; end ; ra None chứ trong vòngwhileđã có lệnh gán rồi chứ . đừng nóiwhile ( true ) thì lúcđó phép gán mớiđược tính ? ? ? ? Re : Testcase nguyen dung wrote : Test # 84 varx : integer ; proceduremain ( ) ; begin while ( 1 > x ) do begin varz : real ; begin break ; end z : = 1 ; z : = z ; / / ( 1 ) end end ; z nằm sau break vậy phép gán z : = 1 ; có tính không ? Mình ra Not_Defined_Before_Used : z rađúng rồiđó bạn . giống mình : DRe : Testcase var x : integer ; function a ( ) : real ; begin var b : boolean ; var c , s : real ; b : = false ; while ( b ) do if ( b ) then begin return 3 ; s : = 3 ; end else s : = 5 ; c : = s ; end ; test này ra j vậy ? Re : Testcase varx : integer ; proceduremain ( ) ; begin while ( 1 > x ) do begin varz : real ; begin break ; end z : = 1 ; z : = z ; / / ( 1 ) end end ; cái test này sao lại ra None nhỉ . sau lệnh Break rồi mà . Re : Testcase_Nhất_Tiếu nại Hà wrote : các bạn test này ntn : proceduref ( a : real ) ; begin varf : real ; end ; = > KQ ? Redeclared_Variable : fRe : Testcase function a ( ) : real ; begin var x : real ; var b : boolean ; b : = true ; while ( true ) do begin if ( true ) then return 9 ; x : = 9 ; end x : = 3 ; / / 1 cau lệnh gán này có được tính không x : = x ; end ; output ra j các bạn Re : Testcase_Test 41 : const arr Const = [ ' hello ' ' world ' ; ' ' ] ; hằngarray làm j có kiêu String nhỉ . sai từ cái parse tree . Re : Testcase_Test # 52 = > None_Phần KT Not_Defined_Before_Usedđâu yêu_cầu KT giá_trị biếu thứcđiều kiệnđâu Hòa . chỉ cần có lệnh gán hợp lệở 2 nhánhif làđược rồi mà như Test 52Testcase Assignment2 wrote : Vậy kiểu trả về của function ko thể là string phải ko , tại vì giá_trị trả về của function được xem là một vế phép gán mà mỗi vế chỉ có_thể là các kiểu : real , integer , boolean đề ko nói Func ko thể trả về kiểu String thì cứ vậy_mà làm , đừng quan_tâm nó trả về để làm j . Testcase vanhoa wrote : Test 52 làm_gì có 2 nhánh . Sr , mình nhầm Re : Testcase_Test 59 proceduremain ( b : boolean ) ; begin varx : real ; constt = [ [ 1 ; 2 ] ; [ 3 ; 4 ] ] ; whilet [ 0,0 ] > t [ 0,1 ] dobegin x : = 2 ; end x : = x ; end ; cái phần Not_Defined_Before_Useđâu có yêu_cầu evalđiều kiện đâu . Biết là t [ 0,0 ] > t [ 0,1 ] ra false constant . Nhưngđặc tảđâu yêu_cầu KTđâu . Cái phần Not_Return_Hòa nói eval thì còn chấp nhậnđược . Còn cái nàyđềđã nói thế . Thầy chỉ nói với Hòachứ chưacông bố chính_thức mà . : | Re : Testcase_Cho minh hỏi . File PT của thầy vẫn là kiểu int và float . Vậy mình fai sửa lại kiểu trong file StaticCheck sao . tại trong 12 cái hàm built của thầy làm banđầu thì thầyđể kiểu integer và real . v Vậy cuối_cùng làm theo cái nàođây . Re : Testcase file nguyên_mẫu của thầy có ghi Symbol ( " readInt " , FuncType ( List ( ) , PrimitiveType ( " integer " ) ) , " Function " ) ý mình hỏi là cái kiểu trong file StaticCheck là " integer " . vậy_là mình phải sửa trong file StaticCheck PrimitiveType ( " integer " ) = > PrimitiveType ( " int " ) PrimitiveType ( " real " ) = > PrimitiveType ( " float " ) cho tương_thích với file PT phải không Re : Testcase cho mình hỏi VD này : if ( true ) x : = 9 ; / / không có else vậy x cóđược tính làđã có giá_trị không Re : Testcase_Thanh_Pham_Minh wrote : Test này các bạn ra None hay Type_Mismatch_In_Expression : array ( [ array ( [ array ( [ 1.0,2.0 ] ) ] ) , array ( [ array ( [ 1,2 ] ) ] ) ] ) function foo ( param : array [ 2,1,2 ] of real ) : integer ; begin return 0 ; end ; procedure main ( ) ; begin var a : real ; a : = foo ( [ [ [ 1.0 ; 2.0 ] ] ; [ [ 1 ; 2 ] ] ] ) ; end ; Test này ra None hay Type_Mismatch_In_Expression : ele ( a , [ 1000 ] ) procedure main ( ) ; begin var a : array [ 2 ] of integer ; a [ 1000 ] : = 1000 ; end ; cái 1 ra nhu bạn . cái 2 NoneRe : Xin y kien cua a Hung ! Vo_Thanh_Hung_Last edited : 12/22/2011 08:37:00 AM Messages : 128 Câu_hỏi : 1 . Truyền tham_số , return với kiểu string có chấp_nhận . Có áp_dụng LHS : = RHS ( LHS khác string và array type ) Trả_lời : Theo đặc_tả ngôn_ngữ thì chấp_nhận . Nhưng ở assignment này đã thu_hẹp lại như quy_định ở 3d . Vì_vậy , các em không cần làm tụi em chưa hiểu ý câu " Vì_vậy , các em không cần làm " của thầy . ý thầy ko cần làm là ko cần làm j vậy ? Nói_tóm_lại là : Truyền tham_số với kiểu string , return với kiểu string và array có chấp_nhận hay kh ông vậy thầy ? Phần kiểm_tra này không khó , nhưng nếu sai vì không hiểu ý thầy thì ... Re : Tổng_hợp các câu_hỏi ? Câu_hỏi : Case h : assign sau break và continue ko tính . Thế sau return có tính ko ? Trả_lời : assign sau break và continue sẽ không tính , tương_tự sau return . Tuy_nhiên , các dòng lệnh sau các phần này vẫn sẽ kiểm_tra như bình_thường ( dù assign thì không tính ) Thầy cho em hỏi cú chót function a ( ) : real ; begin return 0 ; end ; function func ( ) : real ; begin var a , func : real ; a : = 0 ; func : = a ( ) ; / / 1 return 9 ; end ; Thầy cho e hỏi biến a có che hàm a ( ) không ? Ngay tại câu_lệnh số 1 có báo lỗi không . nếu thầy trả_lời kịp thì sửa , còn không kịp thì mai_mốt cũng biết sai chỗ nào . : D_Due to the above rule , the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block [ da xu ly ] lỗi trong file Util.scala . Mong anh Hùng xem_lại giúp E đã chỉnh_sửa trong file PTđể rađúngđịnh dạng trong IntermediateCrazyParser là các phần_tử củaarray ngăn_cách nhau bởi dấu_phẩy . quađược cái IntermediateCrazyParser thìđếnASTGenerator lại bị lỗi ngay cái hàm def lit ( item : Item ) : Literal . hình_như bị lỗiở case Term ( " array " , List ( ItemList ( lits ) ) ) = > ArrayLit ( lits.map ( lit _ ) ) VD : const x = [ 9 ; 8 ] ; Mong anh Hùng xem_lại , updateđể tụi e còn làm sớm , sắp deadline rồi Re : lỗi trong file Util.scala . Mong anh Hùng xem_lại giúp được rồi . cảm_ơn Dung.Re : Cannot_Assign_To_Constant_Type_Mismatch_In_Statement : assign ( x , a ) . bạn cứ gọi hàm report của thầy làđược . thầyđã xử lýđịnh dạng xuất rồi . Re : Cannot_Assign_To_Constant trong file staticcheck có sẵn 3 hàm report rồi mà . bạnđọc 3 hàmđóđi là hiểu Re : Làm_sao để chạy thử test ? ? ? Guest_User wrote : Anh Hùng hoặc bạn nào có_thể gửi lại cho mình file PT.scala để mình kiểm_tra BT lớn 2 được không ? Mình đang làm luận_văn nên cần kết_thúc BTL2 sớm , cảm_ơn anh và các bạn nhiều Share cho bạn : dl.dropbox.com/u/5754896/PT.rarRe : Làm_sao để chạy thử test ? ? ? Guest_User wrote : Cảm_ơn bạn nhiều , không hiểu sao mình đăng_nhập rồi mà vẫn là " Guest_User " nữa ? up lại cho bạn : www.mediafire.com/Re : Size_Must_Be_Integer_Sẽ không có trường hợpđó xảy rađâu bạn . Vìở phần Parse tree mìnhđã bắt_buộc nó là Integer rồi Re : câu_lệnh Return_Cũngđang thắc_mắc cái này . Re : câu_lệnh Return đọc lại mới thấy trongđặc tảass 1 thì parameter có_thể là kiểu String vàarray . ass2 lại ko cho truyền tham_số kiểu String ? ? ? ? Bây h chẳng biết làm theo cái nào . Cáiđề mập_mờ quá . Mong thầy sớm giải thíchđể còn biết mà sửa . : ( Re : Thứ_tự kiểm_tra Redeclared_Procedure : readInt đó bạn . Re : Thứ_tự kiểm_tra Thầy cho em hỏi luôn thứ_tự check của toàn_bộ chương_trình . việc kiểm_tra và báo lỗi sẽ theo thứ_tự các câu_lệnh trong cấu_trúc chương_trình input hay theo thứ_tự trong fileđặc tả . VD : procedure proc ( y : integer ; j : integer ) ; begin var h : real ; h : = true ; var h : integer ; end ; thì sẽ báo lỗi Type_Mismatch_In_Statement : assign ( h , true ) hay_là RedeclaredVariable : hRe : Thứ_tự kiểm_tra var x : boolean ; procedure proc ( y : integer ; j : integer ) ; begin var a : integer ; x : = a-true ; end ; Type_Mismatch_In_Expression : sub ( a , true ) hay Not_Defined_Before_Used : a Mình muốn biết thứ tựưu tiên 1 cách tổng_quát mà chưathấy thầy trả_lời . Re : Thứ_tự kiểm_tra H . T . P ( ^ _ ^ ) wrote : Mình muốn biết thứ tựưu tiên 1 cách tổng_quát mà chưathấy thầy trả_lời . Trích đặc_tả : One program have maximum 1 semantic error . Nên thứ tựưu tiên không quan_trọng nữa . Ngoài_ra : <statement> , <expression> , <declaration> ( c , d , e , f ) is in parse tree format . : ) Mình thấy lần này thầy dứt_khoát không trả_lời các câu đặc_tả đã nói . Nên chúng_ta rút kinh_nghiệm nếu_không thấy thầy trả_lời thì_phải xem_lại thôi : pRe : Thứ_tự kiểm_tra @ H . T . P ( ^ _ ^ ) : chương_trình có TỐI_ĐA_MỘT lỗi . Nghĩa_là cho_dù một dòng hay bảy mươi lần bảy dòng cũng chỉ có tối_đa một lỗi . Re : Thứ_tự kiểm_tra Input 1 : procedure a ( ) begin end ; procedurea ( ) / / 1 begin var b : real ; var b : real ; / / 2 end ; báo lỗi ở 1 hayở 2 . input 2 : procedurea ( ) / 1 begin var b : real ; var b : real ; / / 1 end ; procedure a ( ) / / 2 begin end ; báo lỗi ở 1 hayở 2.Re : Thứ_tự kiểm_tra Thanh_Pham_Minh wrote : @ H . T . P ( ^ _ ^ ) : One program have maximum 1 semantic error , your program will be stopped after found first error . Mình vẫn nghĩ rằng chỉ có một lỗi , chứ không phải nhiều lỗi mà cùng một loại . Hơn_nữa " stopped after found first error " phụ_thuộc vào cách mỗi người xử_lý mà cái nào found trước found sau , khác với " stopped after the first error " chỉ phụ_thuộc vào source code . Nên cũng theo mình nghĩ , sẽ không có hai ví_dụ bạn đưa ra ở trên ( trong bộ testcase của thầy ) . Hy_vọng như_thế . Thứ_tự kiểm_tra CHỜ_THẦY_XÁC_NHẬN 1 CÁI_CHO_YÊN_TÂM . Vì chấm theo solution của thầy và testcase khôngđược công_bố nên có sai cũng chẳng biết sai chỗ nàođể màý kiếntrong if mà có break và continue hay không ? ass1 : The break and continue are only used inside a loop or while statement . They are always terminated by a semi - colon ass 2 : after an if statement if the variable is assigned in both branches of the if statement , before the first break or continue in either branch ( or a nested if statement with a break or continue ) . cuối cùngtrongif mà có break và continue hay không ? string trong Assign ? tran ngoc duc wrote : Trong đặc_tả ass 2 có ghi rỏ ở mục d : Type_Mismatch_In_Statement như sau : ĐỐ i với phép gán : LHS có_thể là real , integer , boolean . [ Hết ] VẬY có nghĩa_là phép gán không được thực_hiện trên string hả các bạn . Mình thấy cái này hơi vô_lý ; var a : string ; var b : string ; a : = b ; / / Ko lẽ sai ? ? ? quảđúng là như vậyđấy bạn . nếu hợp_lý thìđâu cóđặc tên là Crazy_Language Kiểu của Parameter ? ? ? Trong phần Funccall : In addition , for parameter passing , the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS . rule ởđây là ( typeof ( LHS ) = typeof ( RHS ) ) hay_là ( typeof ( LHS ) = typeof ( RHS ) vàtypeof ( LHS ) = integer , real , boolean ) Re : string trong Assign ? nguyen dung wrote : Như_vậy là phép gán này cũng lỗi luôn à : var a : array [ 2 ] of real ; ... . a [ 0 ] : = 2.1 ; LHS không có array type ? ? a [ 0 ] là ele kiểu real . a mới là kiểuarray . nên phép gánđó hợp_lệ . Re : Kiểu của Parameter ? ? ? Spec ass 1 wrote : Return type and parameter type can be primitive type or array type . mình nghĩ luật này là luật KT giá_trị 2 vế có tưng thích hay khôngđó bạn . Re : Kiểu của Parameter ? ? ? mình nghĩ làđượcđó bạn . nếu kiểu String kođược chấp_nhận cho para thì nóđã loại_bỏ từ phần parse rồi . bạnđọc lại Spec ass 1 đi , có cau minh vừa nóiđó . mình nghĩ xem para như 1 lhsởđây là dùngđể kiểm_tra type của para và arg có tương_thích hay không như của phép gán thôi . Re : Kiểu của Parameter ? ? ? có . tầm vực của 1 FuncVar bao_gồm cả block statment của nó . Cau lệnh Return nằm sau Break thì_có được tính hay không ? Trong phần check Function_Not_Return_Câu lệnh Return nằm sau Break , continue thì_có được tính hay không ? . Re : Case h : Not_Defined_Before_Used ? thực_chất t hi 2 câu_lệnh m : = 1 ; x : = n + m ; s ẽ ko bao hđược thực_thi nên ko ai KT làm j . nhưng do mình ko làm phầnđó ( Unreachable_Code ) nên câu_lệnh x : = m + n mình vẫn test nên nó báo lỗi . còn nếu m làm luôn Unreachable_Code thì nó se bao loi va cau truc t est của mình nó cũng khác : DRe : Case h : Not_Defined_Before_Used ? Thầy cho em hỏi nếu trường hợpwhile ( false ) Như VD : funtion ... begin var x : integer ; while ( false ) begin x : = 9 ; end x : = x +1 ; / / 1 end ; tại câu_lệnh số 1 , xđã có giá_trị hay chưa ? Re : Case h : Not_Defined_Before_Used ? var x : integer ; function a ( ) : real ; begin var b : boolean ; var c , s : real ; b : = false ; while ( b ) do if ( b ) then begin return 3 ; s : = 3 ; end else s : = 5 ; c : = s ; return 9 ; end ; cho hỏi test này báo lỗi hay ko vậy mấy bác ! và báo lỗi gì ? ( neu co ) Re : Function_Not_Return_Cho hỏi ngoài_lề 1 tí . nếu trong Proceduce có lệnh return thì xử_lý làm_sao ? Re : Function_Not_Return_Còn trường_hợp returnở trong vòngwhile mà nằm sau break ; thì_sao . đường thực thiđi quawhile cóđược tính là có return rồi hay ko ? ? Re : Function_Not_Return_Đơn giản hay phức_tạp ko quan_trọng . Vấnđềởđây là yêu_cầu của thầy là như_thế_nào ? Chứ khó hay dễ thì vẫn phải cắn_răng mà làm thôi . Đằng nàytrong fileđặc tả ko hề ghi 1 câuđịnh nghĩa thì biết làm thế_nào mớiđúngý thầy . @ @ Hỏi về Array_Constant_Van_Persie wrote : Cho em hỏi thêm câu nữa : có chấp_nhận assignment statement dưới đây không ? A[ 4 , C[ 5 ] ] với A , C là hai array variable và A[ 4 +5 , 3 , i + j ] = > i , j hai biến kiểu integer A , C error token rồi bạn Các toán_tử and or not mod div ? Thầy cho em hỏi các toán_tử này ( and or not mod div ) có được phép ghi liền với toán hạng hay ko ? VD : 6mod4 hay_là 6 mod 4 . Vì trường họp 6mod4 nó cứ hiểu mod 4 là 1 identifier chứ ko tách ra dược là thành 6 , mod , 4 Và có trường_hợp not liên_tiếp ko ? VD : not not x Truy_xuất array nhiều chiều ! Nguyen_Nha wrote : Các bạn cho mình cho mình hỏi : Vd : mang hai chieu a [ [ 1,2 ] , [ 1,1 ] ] Truy_xuất array nhiều chiều thi a [ 1,1 ] hay la a [ 1 ] [ 1 ] ... . ? a [ 1,1 ] . trong này a Hùng có trả_lời rồi nè bạn . chịu_khó đọc kiếm trước khi hỏi chứ https : / / elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3643.pageRe : Hỏi về break và continue ass 1 chua can kiem tra cai nay dau ban Re : IF_ESLE Cao_Đại wrote : lúc mình định_dạng if - else có_thể có trường_hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc_đơn k ... cái này đặc_tả k rõ gì cả ghi vậy_là 1 chứ mấy nữa hả bạn . bạn muốn rõ như_thế_nào nữa Re : String_Literal mình nghĩ chắc do thầy chỉ mới xử_lí 2 dấu ' , còn 2 dấu ' trở_lên thì chưa . từ 2 dấu ' trở_lên đều bị duplicate hết là do dùng / : đó.còn nhân đôi dấu " thì nó chỉ là 1 kí_tự bình_thường , đặc_tả ko nói j hết thì_thôi . chắc cái code đó a Hùng copy qua mà quên xóa đi . nhưng quan_trọng hơn là a Hùng xử_lí ntn thì ko biết , xử_lí ko theo cách của a thì lại bị chấm sai . bây h chẳng biết làm thế_nào Re : String_Literal vẫn chưa thấy có dấu_hiệu trả_lời . thôi_thì cứ làm theo đúng đặc_tả . Có j còn ý_kiến được . : DRe : access Array_Element ? ? ? ? Đỗ_Sỹ_Hưng wrote : Cho mình hỏi trường_hợp này xuất ra cái gì : procedure main ( ) ; begin a : = true [ 2 ] ; end ; error cho dau [ do ban . true la keyword nen ko duoc coi la 1 bienRe : access Array_Element ? ? ? ? procedure a ( ) ; begin a [ ] : = 3 ; end ; có parse ko nhỉ . đặc_tả ko nói rõ trường_hợp này . Re : access Array_Element ? ? ? ? . duc hoang wrote : Scala ^ ^ wrote : bạn nào trả_lời giúp mình với . trong cái a [ i ] : = x [ i ] ; thì cái a [ i ] có phải là element of array không , và định_dạng nó là ident [ expr , expr , ... ] nếu cứ làm theo như đặc_tả thì a [ i ] là element of array và x [ i ] cũng vậy , với định_dạng như bạn đưa ra như trên . Nhưng tớ thấy ngồ_ngộ là với định_dạng như đặc_tả thì expr có_thể là const , mà const thì int , real , bool có tất vậy dẫn tới trường_hợp a [ 1 , 3.4 , true ] vẫn phải chấp_nhận . mà chỉ_số array làm_gì có real , bool ? ? ? Nên tớ đang phân_vân không biết_mấy cái này phải ràng_buộc từ stage 2 này chưa ? ? ? cái đó nằm ở bước kiểm_tra kiểu , sẽ làm ở Ass2.Re : Tạo ra file out put . txt . bạn dùng thử đoạn code này đi , hàm main của file TestToken . / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / def main ( args : Array [ String ] ) : Unit = { val input File = " input.txt " val lines = Source.fromFile ( inputFile ) . getLines val input = if ( ! lines.isEmpty ) lines.reduceLeft [ String ] ( _ + ' \ n ' + _ ) else " " val lexical = new CrazyLexical val scanner = new lexical . Scanner ( input ) var out _ file = new java . io.FileOutputStream ( " D : \ \ Ass1 \ \ output.txt " ) / / nhap ten file , nho fai la 2 dau \ \ nhe var out _ stream = new java . io.PrintStream ( out _ file ) / / val output = " " ; runAll ( scanner ) out _ stream.println ( " EOF " ) def clean ( token : lexical.Token ) : String = { val t = token.chars if ( t.indexOf ( " expected but " ) ! = - 1 ) { val from = t.indexOf ( " but " ) val to = t.indexOf ( " found " ) " ErrorToken " + t.subSequence ( from + 4 , to - 1 ) . toString } else token . toString } def run All ( scan : lexical.Scanner ) : Any = if ( scan.atEnd ) println ( scan.first ) else { var output = clean ( scan.first ) println ( output ) out _ stream.println ( output ) runAll ( scan.rest ) } } / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / Re : Testcase cứ làm như fileđặc tả . chắc lúc code a Hùng kođểý thôi .
