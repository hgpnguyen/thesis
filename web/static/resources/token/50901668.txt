Re : File PT vẫn chưa tương_thích Vậy cái UnaryOp mình làm chỉ có 2 TH sub và bnot thui à ? Không liên_quan j đến string như code thầy phải ko mấy bạn ? Tại nếu thầy chấm dùng file PT.scala đó là cái test nào dính string sai hết ! ! ! Re : GradeBook Mid_Term_Họ tên : Đỗ_Thị_Tuyết_Ngân MSSV : 50901668Re : Lab 2 Đúng rùi đó . Hình_như cái solution câu 1a của thầy có j nhầm_lẫn . Mong thầy giải_đáp Mình thì làm thế_này : " ( / \ \ * ( [ ^ \ \ * ] | ( \ \ * ) + [ ^ / ] ) * \ \ * * \ \ * / ) " Re : Biểu_thức hằng ? ? H . T . P ( ^ _ ^ ) wrote : Thầy cho em hỏi lại về vấnđề 4 . trong phần Notice thầyđã nói là vẫn check các câu_lệnh nằm phía sau vòng lặpwhile . Nhưngý em muốn hỏi là trongđiều kiện luôn luônđúng thì chương_trình chỉ có 1 luồng thực_thi làđi vàowhile rồi_ra khỏiwhile và tiếp phần còn lại , vậy_thì functionđã có return . Tại_sao bắt buột ngoàiwhile phải có lệnh return nữa ? ( hơi mâu_thuẫn với trường hợpif ( true ) else thì chỉ cần xét nhánhif ) . Em cámơn thầy . Em đồng_ý với bạn này ! Theo thầy trả_lời trong topic thì while ( unlnown ) = while ( false ) và ko tính cái assign hay return nằm trong while này . Vậy bây h mà while ( true ) ko tính return lun thì làm cái eval condition trong while làm_gì nữa ạ ! Mong thầy giải_đáp ! Re : Tổng_hợp lại các trường_hợp của bonus Đồng_ý với bạn H . T . P ( ^ _ ^ ) Bổ_sung thêm TH loop ( n ) n > 0 thì tương_đương while ( true ) n < = 0 thì tương_đương while ( false ) và while ( unknown ) Tổng_hợp các câu_hỏi ? Thưa thầy , gần deadline rùi mà mọi người vẫn còn những thắc_mắc do đề ko rõ và notice mới của thầy về eval cg ko rõ lắm . Em xin tổng_hợp 1 số câu_hỏi : 1 . Truyền tham_số , return với kiểu string có chấp_nhận . Có áp_dụng LHS : = RHS ( LHS khác string và array type ) 2 . UnaryOp có string ( như AST sinh_ra do PT.scala của thầy ) 3 . Case h : assign sau break và continue ko tính . Thế sau return có tính ko ? 4 . Case i : 3 trường_hợp : While ( true ) { break ; return . . ; } While ( false ) { return ; } While ( unknown ) { return ; } TH nào_là báo lỗi function not return ; 5 . eval giá_trị ảnh_hưởng tới trường_hợp case h và i hay tất_cả các trường_hợp ? Vd như câu thầy nói " trong trường_hợp 1 trong 2 nhánh chắc_chắn không_bao_giờ thỏa_mãn thì mình chỉ kiểm_tra 1 nhánh còn lại " . Vậy nhánh sai sẽ không kiểm_tra cái gì hết hay chỉ không tính phép gán hoặc return thôi . Re : Tổng_hợp các câu_hỏi ? Thì biết logic là thế ! Nhưng đây là crazy language , cái j cg phải hỏi lại cho chắc ! Tại đề ko có nói ! Re : Tổng_hợp các câu_hỏi ? Minh_Nguyen wrote : Vo_Thanh_Hung wrote : Kid wrote : thêm một câu nữa mong thầy giải_đáp : Return trong procedure có được phép không ? chỗ này trong đặc_tả không rõ_ràng và dễ hiểu nhầm . Đọc kỹ yêu_cầu assignment xem , nếu em muốn báo lỗi thì nó sẽ là lỗi gì ? Theo em hiểu trong đề có đặc_tả : For a return statement , the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . Lúc này return statement không xác_định được kiểu trả về và báo lỗi Type_Mismatch_In_Statement_Đây là cách hiểu của em . Em hiểu đúng vấn_đề về đặc_tả rồi , bình_thường , procedure không trả về sẽ được coi như trả về void , và nếu kiểm_tra thì sẽ Type_Mismatch_In_Statement , tuy_nhiên , ở trong assignment này mình không cho nó kiểu gì cả , bởi_vậy kiểu trả về của nó là không xác_định như em nói . Không xác_định tức_là chưa biết , và vì đề đã bỏ_qua không nói bất_cứ ràng_buộc nào bởi_vậy những lỗi như_vậy sẽ không kiểm_tra . Đây là một trường_hợp đơn_giản , nhưng còn rất nhiều ràng_buộc khác về ngôn_ngữ nữa mà chúng_ta không làm ở assignemnt này , nếu để viết một compiler thực_sự thì sẽ rất nhiều thời_gian và công_sức . Vì_vậy , những ràng_buộc mà đề không nói tới dù nhiều ngôn_ngữ thực_tế có làm , thì các em không nên quan_tâm tới Re : Return statement ! Mình nghĩ là test trên nó sẽ báo lỗi Type_Mismatch_In_Statement Case h : Not_Defined_Before_Used ? Cho mình hỏi trong 2 code này , thì cái nào báo lỗi và báo chỗ nào ? VD1 : function func ( ) : integer ; begin var n : integer ; var x : integer ; var m : integer ; while ( 1 > 0 ) do begin n : = 1 ; break ; m : = 1 ; x : = n + m ; end return x ; end ; VD2 : var x : integer ; procedure main ( ) ; begin while ( 1 > x ) do begin var z : real ; begin break ; end z : = 1 ; z : = z ; / / ( 1 ) end end ; p / s : Theo ý mình thì lỗi : VD1 : " Not_Defined_Before_Used : x " . VD2 : ko có lỗi Re : Case h : Not_Defined_Before_Used ? @ Minh : Theo Ngân assign chỉ ko tính khi câu đó x : = m + n nằm ngoài while thui . Theo logic thì_phải thế chứ ! Chắc ngôn_ngữ này là Crazy cũng phải có logic chứ ! Re : Hỏi về Array_Constant_Just A_Tee wrote : nguyen dung wrote : Mấy bạn thử cái này xem : function a ( ) : real ; begin b : = a [ 4 +5 , [ ( 3 ) ] , i + j ] ; end ; Cái này sai cú_pháp mà . Toán_tử [ ] phải có cú_pháp là : [ , … , ] Đâu có ! Nó hiu cái [ ( 3 ) ] là expr - > const array - > mới báo lỗi ( do const array ko cho expr : ) Hỏi về Array_Constant_Van_Persie wrote : Cho em hỏi thêm câu nữa : có chấp_nhận assignment statement dưới đây không ? A[ 4 , C[ 5 ] ] với A , C là hai array variable và A[ 4 +5 , 3 , i + j ] = > i , j hai biến kiểu integer A , C là ident nên phải bắt_đầu bằng chữ thường TH : a [ 4 +5 , 3 , i + j ] thao mình ko parser mà phải ghi là a [ ( 4 +5 ) , 3 , ( i + j ) ] thì dc ( vì cái thứ_tự ưu_tiên trong bảng ) tương_tự a [ 5 , ( c [ 5 ] ) ] ; thì parser Ngoài_ra cho mình hỏi thêm là cái array access ko cần check cùng type như array literal đúng hok ? Nghĩa_là ghi a : = s [ 1 ; 6.9 ] parser còn a : = [ 1 ; 6.9 ] là sai ? Re : Truy_xuất array nhiều chiều ! hình_như là a [ 1,1 ] ... . ( coi array access trong bảng expression ) Re : Nhờ anh HÙ ng chỉ giúp Mình đã gặp lỗi này , do ubuntu cài phiên_bản cũ scala . Bạn update scala lên 2.9.1 mới nhất_là ok .
