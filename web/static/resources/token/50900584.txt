Re : Scope của biến global ? ? ? nhan nguyen van wrote : var x : real ; function demo ( a : real ) : real ; begin return 0 ; end ; procedure main ( ) ; begin var demo : real ; x : = demo ( demo ) ; end ; Cái này sao mấy bác ? ? biến demo có che hàm demo không ? Nếu_không che thì có_thể gọi demo ( demo ) Function demo ( biến demo ) ko ? không báo lỗi gì cả . Theo lý_giải của Nhan bên dưới nhưng_mà 1 cái là biến , 1 cái là hàm thì không liên_quan gì nhau ( nên sẽ không bị che ) . Vd : bạn gọi hàm demo ngay dưới biến demo vẫn OK vì hàm sẽ có cả tham_số nữa mà ( demo ( ) khác với demo ) . @ Dung : Quan trong là cái typeof mình lookup như_thế_nào . Đâu fai cứ lookup cái name vậy rồi nói nó che được Re : GradeBook Mid_Term_Re : Element of array ! Nhất_Tiếu nại Hà wrote : line 3 : 3 : unexpected token : ] Rõ_ràng đặc_tả đã nói hết rồi còn gì k rõ nữa . Try cập phần_tử mảng thì theo cấu_trúc ident [ <expression> , . . ] Mà expression không rỗng thì làm_sao có kiểu a [ ] : = được . Phải hiểu đề theo đệ qui xíu chứ Điểm thi cuối kì TAM_NGOC wrote : Theo em thì nên để tỷ_lệ điểm stage 1 và stage 2 trong Assignment 1 như anh Hùng đã nói , rất hợp_lý . Ngay từ đầu anh Hùng đã nói như_vậy rồi , mọi người đều đã biết và không phản_đối . Vậy nên không nên thay_đổi . Sao màmọi người phức_tạp vậy . Thầy_Tân đưa ra vậy cũng được rồi . Cách nào cũng không chênh lệnh nhiều , thầy đã đưa ra từ đầu năm_học sao phải bàn_cãi Re : Xem_lại bài thi cuối kì . Thầy xem_lại bài thi giúp em với : Tên : Nguyễn_Văn_Định MSSV : 50900584Phân biệt SUB và NOT Mọi người cho hỏi làm_sao phân_biệt xuất ra sub và not như_thế nào_là đúng . Hôm trước có bạn hỏi rồi nhưng vẫn không rõ , mong thầy giải_đáp . ví_dụ : procedure f ( ) ; begin var x : real ; x : = 1 - - - 2 ; end ; Output sẽ như_thế_nào ? Dấu trừ đầu_tiên luôn hiểu là sub thì các dấu còn lại sẽ thế_nào ? Re : Phân_biệt SUB và NOT Hoa_Vô_Khuyết wrote : Kết_quả sau : [ proc ( a , [ ] , [ assign ( ele ( x , [ i ] ) , sub ( bnot ( 4 ) ) ) ] ) ] Tương_tự mấy cái còn lại . Sao lại ra sub rồi not được ? Đặc_tả : <expr> ( + | - ) <expr> Của mình : [ proc ( a , [ ] , [ assign ( ele ( x , [ i ] ) , bnot ( bnot ( 4 ) ) ) ] ) ] ... ... ... ... ... ... . . còn cái test trên của mình phải hiểu đặc_tả như_thế_nào để ra được sub hết ? vì output có_thể xét dấu - đầu_tiên là sub sau đó là not ( vì sau sub là 1 expression , 1 expression lại có_thể là not <expr> ... . ) Re : Testcase cho stage 2 Cho mình hỏi test case này các bạn ra_gì ( thấy nó lại báo lỗi khác với cái test mẫu trong đặc_tả ) : var a : integer ; procedure proc ( ) ; begin s ; end ; Tổng_hợp lại các trường_hợp của bonus H . T . P ( ^ _ ^ ) wrote : Mình xin tổng_hợp lại tất_cả các trường_hợp như sau . Nếu có j sai thì thầy và các bạn nóiđể mình sửa lại . Nếu_không thì chắc là nóđúng . 5.if ( unknown ) Coi như_không có coi như_không có là sao ban ? unknown là không cần kiểm_tra các câu_lệnh sau nó ak ( đag nói ktra bonus ) ? vd : function foo ( ) : real ; begin var x : integer ; var y : integer ; y : = 3 ; if ( y > 0 ) then x : = x +1 ; / / y > 0 là unknown vậy có kiểm_tra cái x ở sau là not defined không ? end ; Re : Testcase cái này ra thế_nào mọi người : procedure f ( a : real ) ; begin var f : real ; end ; Re : Testcase_Manchester_United wrote : test 76 , cái biến f ( hàm ) coi như_là toàn_cục , nhưng biến f trong hàmđó thì_là biến cục_bộ , như_vậy vẫnđúng chứ , sao lại Redeclare dc nhỉ cùng ý_kiến với bạn . Huống_chi là Tên hàm có_thể trùng tên biến còn tên biến sao lại k thể trùng mà declare dc Re : Những ký_tự sử_dụng trong String_Trong_Slide bài giảng có một kí_tự chấp_nhận mọi kí_tự ( kể_cả dấu xuống dòng ) . Ngĩa là thay_vì khi định_nghĩa string các bạn liệt_kê ra các trường_hợp hợp_lệ ( trong regex ) thì hãy liệt_kê những trường_hợp không hợp_lệ ( vd : endline character , . . ) rồi dùng kí_tự kia ^ điRe : Hỏi về Array_Constant_Tan_Phat wrote : cùng ý_kiến với bạn . output : [ func ( a , [ ] , float , [ assign ( b , ele ( a , [ add ( 4,5 ) , 3 , add ( i , j ) ] ) ) ] ) ] loop do statement vàwhile do statement ko biết trường_hợp này có đc nhiều expression ko nhỉ ? hay chỉ có 1 expression sau loop thôi ? chẳng_hạn như ở c + + while ( a < 10 & & b < 10 ) có 2 expr . Cái này cứ hiểu theo đệ quy đi . Đề đã nói rất rõ_ràng cấu_trúc là while ... . . thì cứ cái expression mà đi_sâu vào ... ... Cái topic ass 1 này ngày_càng rối lên rồi , ai mà zô tìm gì giờ này chắc đuối BooleanLiteral 1 . Giờ mới phát_hiện cái boolean Literal chưa hiện_thực và hiện_thực thì gặp lỗi . hix . Vì giá_trị boolean chỉ có true hoặc false ( cái này token mình đâu có kiểm_tra trong regex ) . def bool Literal : Parser [ BooleanLiteralPT ] = elem ( " boolean " , _ . isInstanceOf [ lexical.BooleanLit ] ) ^ ^ { a = > new BooleanLiteralPT ( a.chars ) } 2 . cái tring Literal của thầy viết trả về kiểu string = > như_vậy giả_sử mình đặt 1 kiểu LiteralPT thì nó báo lỗi vì string k thuộc kiểu này : def literal : Parser [ LiteralPT ] = intLiteral | stringLiteral ... . ( cái này dùng để nhận dữ_liệu cho array chẳng_hạn ) Không thật_sự hiểu rõ lắm định_nghĩa các kiểu dữ_liệu này có từ_khóa như real , int , string đâu có ảnh_hưởng . Mong mọi người giúp_đỡ BooleanLiteral Thanh_Pham_Minh wrote : 1 . Bạn làm một_cách đơn_giản . booleanLiteral có 2 trường_hợp là true và false . Vậy hãy parse 2 trường_hợp đó thôi . Đừng để code mẫu của những literal kia làm ảnh_hưởng . 2 . Bạn sửa sao cho string Literal thuộc kiểu StringLiteralPT hoặc một_cách nào_đó khác ! Thanks ban nhieu . Cai string Literal của thầy viết vậy_là hợp_lý rồi tại cái const còn xử_lý mà , mình sửa khi đưa về literal = IntLiteral | StringLiteral ^ ^ { new ... ( ) } không biết bản_chất có đúng không nhưng tạm ok Re : một trường_hợp về hằng chuỗi Uh câu_hỏi rất hay . Mà giờ ai giải_đáp dùm đây ah mà mình nghĩ thế_này . Từ state 1 cũng đã nói rõ là string nhập vào nếu là 1 dấu ' thì_phải double nó lên thành ' ' . Do_đó chuỗi đầu_tiên của bạn gồm 3 dấu ' là chuỗi nhập vào không hợp_lệ rồi ( đây là yêu_cầu input từ người dùng chứ không phải yêu_cầu mình xử_lý ) Hỏi về số 0 Anh Hùng cho e hỏi về phần token 1 . số 0 mà hiểu theo số_thực thì_có phải là 0.0 ( tại đặc_tả : followed by a non - empty sequence of digits that never ends with 0 unless it is 0 . ) Nghĩa_là nếu input là : var a = 0.0 thì kết_quả thế_nào ? 2 . Không hiểu sao khi em dùng scala interpreter thì trường_hợp sau là đúng còn chạy vào file Crazy2011 thì lại sai : giả_sử phần số_thực đơn_giản là : regex ( " [ 1-9 ] * \ \ . [ 1-9 ] * " . r ) ^ ^ { FloatLit ( _ ) } thì khi thử với input : var x = 1.2 thì chỗ số_thực nó lại báo : 1 . 2 ( không hiểu sao nó lại tự thêm thành kí_hiệu xuống dòng ) Hỏi về số 0 Chắc là do trong file Crazy2011 bạn để cái regex của NumericLit trước nên nó nhận số 1 là Numeric rồi mới đến . 2 là Float à lại lỗi này . Cảm_ơn bạn Re : Hỏi về số 0 Trần_Gia_Lạc wrote : Nhân_tiện đây cho mình hỏi , nếu viết 0.2 , 0.2e - 4 , 0e3 , 0.0e3 thì_có phải là những số_thực hợp_lệ không ? Mong thầy và các bạn giải_đáp giúp . ủa số 0e3 làm_sao hợp_lệ vì một_số bắt_đầu bằng 0 thì_sao được ? Mà không biết giá_trị của nó bằng bao_nhiêu vậy ? Re : Hỏi về số 0 c . ronaldo wrote : An integer is a sequence of digits that always starts with a nonzero digit unless it is 0 . Số 0 đó của phần nguyên đó Thì như_vậy làm_sao hợp_lệ được ? ( ngĩa là chỉ chấp_nhận số 0 ( nếu số_nguyên ) hoặc 0.0 nếu số_thực , còn ở đây là 0e3 !
