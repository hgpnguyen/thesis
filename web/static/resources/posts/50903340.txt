GradeBook Mid Term Tên: Lê Anh Vũ MSSV: 50903340GradeBook Mid Term Đợi thầy sửa bài xem sao! =]]Re:cac bạn Test cái này xem. Nhất Tiếu nại Hà  wrote: Trần Gia Lạc wrote: Scala ^^  wrote: cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k? cái này mình lại parse thành công [proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[true]),ele(a,[i]))]),const(a,[a])] bộ arrayLiteral không nhận string sao các bạn kết quả....: line 1:10: unexpected token: 'a' sao mình ra còn có dấu " " nữa??? line 1:10: unexpected token: " 'a' "Thắc mắc về output của String Lenh Ho Xung wrote: Thầy cho em hỏi là lúc output chuỗi String có cần phải bỏ 2 dấu ' ở 2 đầu String không ạ. Ví dụ như: const a='a'; thì output là [(const,a)] hay là [(const,'a')] ạ Em không thấy trong đặc tả có nói về phần output này ạ. Sửa lại nha bạn: [const(a,'a')] chứ ko phải [(const,'a')]4 Testcase! 1/ procedure main(); begin const b = 3; b[1] := 6; end; cái này ra cái gì vậy bạn ? ---------------------------------------------- 2/ procedure main(); begin const b = [3; 4; 5]; b[1] := 6; end; còn cái này? -------------------------------------------- 3/procedure c(); begin var a : array[1] of integer; var b : integer; a := 3; end; ------------------------------------------- 4/procedure c(); begin var a : array[1] of integer; var b : integer; b[1] := 3; //a := 3; end;Re:4 Testcase! Nguyen Nha wrote: test 1 : Type Mismatch In Expression: ele(b,[1]) mình nghĩ cái này ra cannot assign...... chứ !!!Re:4 Testcase! tran ngoc duc wrote: 1/Type Mismatch In Expression: ele(b,[1]) 2/Cannot Assign To Constant: assign(ele(b,[1]),6) 3/Type Mismatch In Statement: assign(a,3) 4/Type Mismatch In Expression: ele(b,[1]) cái 1/ mình nghĩ cannot assign ......... chứthem test cho may pro thu suc ! [proc(main,[],[call(kingoff,[call(foo,[call(fal,[call(li,[ele(lee,[add(1,ele(f,[a]))])])])])]),assign(a,ele(b,[call(f,[ele(c,[i])])]))])]Unary expression! Thầy cho em hỏi, cái unary expression có type rule làPrimitiveType("boolean") giống NOT phải không thầy. Trong Ass1 Spec thầy chỉ ghi chú cho dấu trừ thôi, còn unary em không thấy! Cảm ơn thầy!Array làm thông số hàm!  Mình thấy trong đề ghi: "The element type of the argument array must be either the same as or coercible to the element type of the parameter array." vậy theo mình hiểu nếu theo dòng này thì ví dụ dưới đây sẽ đúng phải ko? var s1: real; procedure main(a: real); begin var v1: array[1] of integer; main1(v1); end; procedure main1(a : array[1] of real); begin end; *** v1 là array kiểu integer gán vào thông số của main1 là array kiểu real !Thắc mắc 1 testcase real const Theo các bạn, trường hợp này được chấp nhận hay ko? 1e .9e Kết quả là gì? 1e .9e hay 1 identifier e .9 identifier eRe:Mot truong hop trong chuoi string _vQ wrote: Ip: ' ' ' ' ' abc'abc abc' 'abc\nabc' Op: "' '" "' '" `'' identifier abc `'' identifier abc identifier abc `'' "'abc\nabc'" EOF có đúng ko ta? Mình ra như thế lun đấyMột số câu hỏi về array Theo mình nghĩ nó ra cái trên đó. Khi ông khai báo gộp hay riêng rẽ thì khi phân tích lúc nào cũng phải phân tích riêng từng biến ra, bao gồm tên biến, loại j trong dấu ngoặc. Vì vậy var x, y, z: integer sẽ ra là [var(x,int),var(y,int),var(z,int)]Test dùm nha!  Các bạn thử test xem: a := asdf[a + b, a * b]; đúng hay trường hợpa := asdf[(a + b), (a * b)]; Hay cả 2 đều đúng và ra cùng 1 kết quả ???Test dùm nha!  bạn có bỏ vào blockStmt ko? chứ bạn copy y nguyên mà bỏ vào nó báo lỗi đó. Mình thấy cái này là assignment Statement ok mà!Test dùm nha!  Cao Đại wrote: LAV  wrote: Các bạn thử test xem: a := asdf[a + b, a * b]; đúng hay trường hợpa := asdf[(a + b), (a * b)]; Hay cả 2 đều đúng và ra cùng 1 kết quả ??? theo mình nghĩ làa := asdf[(a + b), (a * b)]; đúng a := asdf[a + b, a * b]; thì test k ra :D Mình ra giống bạn này nè ! =]Re:Testcase testsol của bạn Hòa thiếu ký hiệu EOF!Re:Testcase mình nghĩ single quote ' là non-token delimiter!