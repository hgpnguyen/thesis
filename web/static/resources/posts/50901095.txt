Cách biên dịch Prolog trong Eclipse Bước 1: Cài SWI-Prolog. 1. Vô trang http://www.swi-prolog.org/download/stable , download file SWI - Prolog 5.10.5. 2. Chạy file tải về để cài. 3. Set biến PATH: 3.1 Windows 7: Nhấp phải Computer -> Properties -> Advanced system settings -> Tab Advance -> Enviroment Variables... Windows XP: Nhấp phải Computer -> Properties -> Tab Advance -> Enviroment Variables... 3.2 Chọn biến PATH trong System variables -> Edit... -> thêm dòng %prolog%\bin (%prolog% là thư mục cài đăt SWI-Prolog nha). 3.3 Khởi động lại máy. Bước 2: Cài đặt tool Prolog cho Eclipse 1. Chạy Eclipse -> Help -> Install New Software... -> Add. 2. Mục Name để tên nào cũng được ^^ (mình để là Prolog >"<), mục Location thì copy đường link sauhttp://sewiki.iai.uni-bonn.de/public-downloads/update-site/ 3. Nhấp OK 4. Mở rộng 2 nhánh "Program Analysis and Transformation" với "Prolog Development Tool (PDT)" 5. Chọn 2 mục "JTransformer" và "Prolog Development Tools". 6. Nhấp Next và cài thôi :D Cách sử dụng: 1. Tạo 1 empty project: File -> New -> Project... -> General -> Project -> Next -> Đặt tên project -> Finish 2. Nhấp phải tên project -> New -> File -> đặt tên file có phần mở rộng là .pl (vd: Demo.pl) 3. Viết code trong file vừa tạo -> save file (phải save trước nha) 4. Từ menu Prolog -> Prolog Console 5. Để build file Prolog, chọn Prolog -> (re)consult -> xuất hiện mấy cái predicate trong cửa sổ Outline (nếu nó không xuất hiện là bị lỗi đó) 6. Trong cửa sổ Project Console, mình viết mấy câu query thôi ^^ 7. còn để debug thì gõ "noguitracer.", rồi gõ theo cú pháp "trace, p(X, Y, Z)." Link: http://sewiki.iai.uni-bonn.de/research/pdt/start P/S: Cái này mình mới tìm ra, chia sẻ cho anh em ^^Re:Element of array ! Parse thành công [proc(a,[par(x,float)],[assign(a,b)])]Một số vấn đề trong Lab4 Có một sô đoạn code mà mình không hiểu cho lắm, mong thầy với các bạn giải đáp, cụ thể: 1. assert() 2. Toán tử ::: 3. scala.Function.tupled { ... }" trong hàm typeof()Re:Lab4 Bạn phải tạo 1 package có tên là sl2, trong package đó bạn tạo 1 file Scala Object, rồi copy code lab4 vào file Scala Object là xong.Re:lab 5 mấy bạn biết câu 5 làm gì không?? Mình chép nguyên code của thầy vô chạy ok luôn mà, không biết làm gì với cái hàm min hết >"<Re:Hỏi về nhận dạng array ở stage 1 trong phần Failure(msg, next) trong hàm show(), bạn thay chuỗi "" thành result.toString để xem lỗi trong quá trình viết parse sau này xử lí chỗ Failure(msg, next) sau.Giá trị của biến toàn cục Nếu biến x là biến toàn cục thì x có được xem là được gán giá trị ban đầu hay x không có giá trị ?? vd: //1 var x: real; procedure main(); begin writeReal(x); end; //2 var x: real; procedure main(); begin x := 1.0; writeReal(x); end; Trường hợp 1: 1 Not Defined Before Used, 2 None Trường hợp 2: 1 None, 2 NoneRe:Lỗi utf ??? Bạn thử copy code rồi paste vào Notepad, lưu lại file khác. Trong hộp thoại Save As..., mục Encoding chọn ANSI --> Save. Mở lại file đó rồi copy code vào trình biên dịch coi còn lỗi không?Re:ai cứu với hix hix... xóa cái code đi bạn, lỡ ai chép lại bi gian lận nữaRe:Hỏi về Array Constant vd: const a = ['123']; Trường hợp này parse thành công hay sẽ thông báo lỗi. 1. Parse thành công:Cú pháp chấp nhận, còn kiểu của phần tử array constant có thể được kiểm tra ở bước kiểm tra kiểu. 2. Bị lỗi ở '123'Hỏi về Array Constant T.D.N  wrote: Mình thấy đặc tả nói các phần tử của array constant đâu có kiểu string đâu bạn Mình cũng làm theo ý bạn, nhưng hỏi lại cho chắc ^^Re:Hỏi về Array Constant Mình cũng nghĩ là trường hợp trên mới đúng. Theo đặc tả: The elements may be integer, real, boolean or array constant. Nghĩa là phần tử trong array constant [(3)] không chứa có phần tử (3) vì (3) là 1 biểu thứcThắc mắc về các toán tử Có 2 chỗ trong ngôn ngữ Crazy mà mình không rõ, mong thầy với mấy bạn giải thích giùm: :( 1. Nếubiểu thức là: 1 < 2 >= 3 thì có được chấp nhận bởi ngôn ngữ Crazy không? 2. toán tử trừ ( - ) được dùng trong kiểu nguyên với kiểu thực thì khi nào toán tử - là unary -, khi nào là binary - ??function call??? Thầy có thể cho em biết định dạng lời gọi hàm (function call) là sao không? + độ ưu tiên, em thấy có khai báo định nghĩa hàm mà không thấy có chỗ nào nói về lời gọi hàm hết.Re:function call??? mình thấy rùi ^^. Thanks mấy bạn nhaRe:một trường hợp về hằng chuỗi /* delete */Giúp mình khai báo BooleanLiteral với !!!!! Lions wrote: Mình khai báo boolean thế này def booleanLiteral : Parser[BooleanLiteralPT] =elem("boolean", _.isInstanceOf[lexical.BooleanLit]) ^^ { a => new BooleanLiteralPT(a.chars)} và chỗ regex mình thêm vào regex("""true|false""".r) ^^ { BooleanLit(_) } nó không báo lỗi nhưng vẫn không hỉu hàm def booleanLiteral mấy bạn giúp mình với ^^ Cách 2: cho regex("""true|false""".r) ^^ { BooleanLit(_) } lên trướcregex("[a-z][a-zA-Z]*".r) ^^ { processIdent(_) } => hết lỗi :)Re:IF ESLE  Ban đọc kĩ đặc tả một chút: if <expr> then <statement> nếu theo bạn thì "<expr> ;<expr> " sẽ là <expr> => ";" là 1 toán tử ? nên không có trường hợp if <expr> ;<expr> then <statement>Vài Question mong mọi người giúp đỡ( rất gấp) DoomAce  wrote: Mình chỉ còn đêm nay để hoàn tất ass1 thôi, sáng mai phải về quê sớm rồi, có vài câu hỏi thôi, mong ai biết giúp mình nhé: 1.  Trong hàm def show, mình hiểu hướng để làm nhưng ko hiểu cách thức trình bày cái unexpected token sao ko đc chấp nhận: "line "+< >+":"+< >":"+" unexpected token: " + if(.....) {.....} else { .....} Có bạn nào biết sai ở đâu nhắc mình tí với, dấu + dùng ở đây có phù hợp ko? Bạn thử dùng () đối với biểu thức if, như thế này nè: "line "+< >+":"+< >":"+" unexpected token: " +(if(.....) {.....} else { .....})Re:hỏi thông số vào của call procedure CallStmtPT không chấp nhận list = null đâu, lớp CallStmtPT chỉ nhận kiểu list và list này có thể rỗng (list.isEmpty == true). Do đó, bạn chỉ cần xử lí trường hợp case a ~ lst là đủ rồiRe:hỏi thông số vào của call procedure Phần class CallStmtPT trong file PT nè bạn: class CallStmtPT(val ident: IdPT, val exprs: List[ExprPT]) extends StmtPT { override def toString = "call(" + ident + "," + "[" + (if (! exprs.isEmpty ) (exprs.head.toString /: exprs.tail)(_ + "," + _.toString) else "") + "])" } exprs luôn có, nhưng exprs có thể rỗng. P/s: Nil có khác null không ??Re:access Array Element???? Cho mình hỏi trường hợp này xuất ra cái gì: procedure main(); begin a := true[2]; end;Re:access Array Element???? Đỗ Sỹ Hưng  wrote: Cho mình hỏi trường hợp này xuất ra cái gì: procedure main(); begin a := true[2]; end; Theo tình hình mình hỏi mấy bạn thì có 2 kết quả cho trường hợp này: 1. Xuất ra error: "[" 2. Xuất ra error: "true" Mấy bạn cho ý kiến nha, mình đã chỉnh code và cũng đã parse ra 2 trường hợp trên