Re:Return String, Array mình nghĩ làđượcđó. Trong specass1 có ghi "Return type and parameter type can be primitive type or array type." mà. xem para như LHS vàarg như RHS ý thầy là giữa para vàarg phải có sự tương thích (comform) về kiểu thôi.Re:mong anh Hùng trả lời: thay da tra loi roi bạn. câu lệnh gán m:=1 ko được tính. nhưng câu x:=m+n vẫn check nên sẽ báo lỗi m not difinedFile PT vẫn chưa tương thích trong file Util của thầy kiểu int là PrimitiveType("integer"), kiểu real là PrimitiveType("real") còn file PT là class IntTypePT extends PrimitiveTypePT { override def toString = "int" } class RealTypePT extends PrimitiveTypePT { override def toString = "float" } VD: procedure c(); begin var a: real; var b:real; b:=9.0; end; b:=9.0 bị lỗi vì b kiểu real còn 9.0 kiểu float. Mong thầy xem lại chỗ nàyRe:Scope của biến global??? _Trung_Than_Thong  wrote: nhan nguyen van wrote: var x :real; function demo(a: real): real; begin return 0; end; procedure main(); begin var demo: real; x := demo(demo); end; Cái này sao mấy bác?? biến demo có che hàm demo không? Nếu không che thì có thể gọi demo(demo) Function demo( biến demo) ko? không báo lỗi gì cả. Theo lý giải của Nhan bên dưới nhưng mà 1 cái là biến, 1 cái là hàm thì không liên quan gì nhau (nên sẽ không bị che). Vd: bạn gọi hàm demo ngay dưới biến demo vẫn OK vì hàm sẽ có cả tham số nữa mà (demo() khác với demo). @Dung: Quan trong là cái typeof mình lookup như thế nào. Đâu fai cứ lookup cái name vậy rồi nói nó che được Trongass của mìnhđề chỉ nói chung tên biến, hằng, hàm là identifier chứ có phân biệt = tên và kindđâu bạn  Most closed nested rule: For every applied occurrence (i.e., use) of an identifier I in a block A, there must be a corresponding declaration of I. The declaration is in a block that is smallest enclosing the applied occurrence of I.  Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block. Chỉ cần trùng tên là bị che ở block bên trong rồi. đúng là theo logic bình thường thì sẽ phân biệt hàm demo() và biến demo. nhưngởđâyđặc tảđãđơn giảnđi thì mình làm vậyđi ( thầy làm vậy làđểđơn giản cho mìnhđó)Scope của biến global??? các bạn cho mình hỏi biến global có tầm vực như thế nào? kể từ dòng khai báo biếnđó hay toàn bộ chương trình. Tương tự, 1 hàm cóđược sử dụng dụng phía trướcđịnh nghĩa hàmđó không? VD: procedure main(); begin y := 1; (1)//ngay cho nay co bị lỗi không writeRealLn(foo(y)); (2)//giả sử dòng trênđúng thì dòng này có báo lỗi không end; const x = 1.2e3; function foo(p:integer):real; begin return p * x; end; var y,z:integer;Re:Scope của biến global??? vậy cả 2 VD của mình làđúng hết cả 2 à. (Chỗ này không hiểu cho lắm nên hỏi lại cho chắc.)Re:Scope của biến global??? Spec ass1 wrote: 2.5. Example of a Crazy program var y,z: integer; procedure main(); begin y := 1; writeRealLn(foo(y)); end; const x = 1.2e3; function foo(p:integer):real; begin return p * x; end; đã giải quyếtđược thắc mắc. Hàm dùng trước khai báo sauđược thì biến cũng thế. :)Thầy cho em hỏi thêm về Access Array Element.  nhiều bạn cũng thắc mắc như em. Định dạng khi truy xuất 1 phần tử của array trong Spec là thế này. [ ,…, ].Nhưng không biết có trường hợp ko có expr giữa 2 dấu [ ] hay không? VD: procedure main(); begin a [ ] :=3; end; input như thế này thì có parse thành công hay không. Mong thầy giải đáp chỗ này vì nhiều bạn cũng thắc mắc như em và chưa được thống nhất.Re:Thầy cho em hỏi thêm về Access Array Element.  nhiều bạn cũng thắc mắc như em. Em cám ơn thầy.Re:Các bạn cho mình hỏi về cái def Show tý nhé ! tran danh hung wrote: nguyen dung wrote: @ tran danh hung: Của mình raline 2:1: unexpected token: bc mình thì nghĩ là ra: line 2:1: unexpected token: b mới đúng @_@ nguyên cái bc là 1 token đó bạn.cac bạn Test cái này xem. Nhất Tiếu nại Hà  wrote: Nhat Nguyen wrote: [proc(main,[],[assign(ele(a,[1.2,1]),1)])] zay laf trong kai lefhandside cua minh nhan toan bo lun ha.....sao kai mang gi ky the cungx nhan ko bik dat ta thi chang noi gi????hic.....dien lun mat thoi sao lại Spec ko có nói bạn.nó nè: <id>[<expr>,…,<expr>] expr là những cái nào thì bạn xem lại. đúng là a[1.2 , 1] nhìn hơi kì nhưng ass1 chỉ làm tới đây. phần kiểm tra chỗ đó nằm ở ass2.Re:cac bạn Test cái này xem. Test này mấy bạn output là gì vậy: const a=b[3];Re:Xem lại bài thi cuối kì. Xin thầy xem lại bài thi cuối kì giúp em. Tên: Huỳnh Phúc Trí MSSV: 50902923. Em xin cảm ơn.tut1 tran danh hung wrote: mấy bạn cho mình hỏi b|a+ có độ ưu tiên ko? tức là (b|a)+ hay b|(a+) ? b|a+ thì + chỉáp dụng cho a,b|a+ = b|(a+). (b|a)+ thì ap dung cho ca (b|a)vấn đề thầy nói hơi mâu thuẫn...??? Nhất Tiếu nại Hà  wrote: theo thầy nói: const a='a'; procedure main(); begin x := 'test'''' prog""ram '; end; Cấu trúc PT sinh ra là: [const(a,'a'),proc(main,[],[assign(x, 'test'''' prog""ram' )])] nhưng trong testsol thứ hai: const d = 1.23e-1; const e = 12; const f = 'qeqwe''qwrqwr' ; const g = true; const h = [23;45;2]; thầy lại cho kết quả: [const(d,1.23e-1),const(e,12),const(f, qeqwe'qwrqwr ),const(g,true),const(h,[23;45;2])] vậy quá mâu thuẫn...thầy giải thik zum tụi em vs....????????? thầy đã đính chính trong phần Noticed, cứ thế mà làmđịnh nghĩa path of the execution of the function? đãđọc mấy topic khác mà vẫn chưa hiểuđượcpath of the execution of the function trong Crazy nàyđượcđịnh nghĩa như thế nào? Mỗi ngôn ngữ có 1đặc tả, cách hiện thực khác nhau, vậy mà thầy cũng chẳngđịnh nghĩa 1 câu.Chẳng biếtđâu mà làm.Biểu thức hằng?? Em có 1 vài thắc mắc xin thầy giải đáp. 1. Thầy cho em hỏi là biểu thức hằng nghĩa là trong biểu thức chỉ có const và giá trị trực tiếp. hay biểu thức hằng là biêu thức có giá trị không bao giờ thay đổi. VD var x:Boolean; x:=false; while( x or true ).. thì lúc đó (x or true) , có được coi là biểu thức hằng đúng hay ko? 2. Về vấn đề các điều kiện loop, while, if, nếu giá các biểu thức trong đó chắc chắn đúng hoặc chắc chắn sai (với điều kiện biểu thức hằng, không có những trường hợp x <= x hay x < x + 1) thì vẫn xem xét. x có thể là const hay không? 3. Nêu trong biểu thứcđiều kiện mà có biến var thì nóđược xem là khôngđúng không sai phải khôngạ? 4. Nếu có while điều kiện luôn luôn đúng và trong body có lệnh Ruturn thì mình có cần xem xét phần dưới while có return hay không? VD: function foo():integer; begin while(true) begin return 9; end end; hàm foo trên có bị báo lỗi ko có Return hay ko? 5. Câu lệnh Return có cần có điều kiện nằm trước break,continue mới được tính như phần h hay không? Em cám ơn thầy.Tầm ảnh hưởng của câu lệnh Return. Mong thầy giải đáp giúp. 1.Thầy cho e hỏi là tầmảnh hưởng của câu lệnh returnđến phép gán tương tự như break và continue phải không? (hy vọng là sẽ như nhau cho tụi emđỡ khổ) 2. procedure pro(); begin var a,x:integer; while(true) begin while(true) begin return 0; a:=0;// câu lệnh gán này chắc chắn sẽ khôngđược tính end a:=9;// câu lệnh gán này cóđược tính hay không? end x:=a+1; end;Re:Tầm ảnh hưởng của câu lệnh Return. Mong thầy giải đáp giúp. thầy không thấy câu hỏi này của mình rồi. có ai giúp mình khôngRe:Testcase cho stage 2 trường hợp này có thành công ko thế function afunc( ; ):real; begin end; và function fun(x:real; :real):real; begin end;Re:Biểu thức hằng?? Thầy cho em hỏi lại về vấnđề 4. trong phần Notice thầyđã nói là vẫn check các câu lệnh nằm phía sau vòng lặpwhile. Nhưngý em muốn hỏi là trongđiều kiện luôn luônđúng thì chương trình chỉ có 1 luồng thực thi làđi vàowhile rồi ra khỏiwhile và tiếp phần còn lại, vậy thì functionđã có return. Tại sao bắt buột ngoàiwhile phải có lệnh return nữa? ( hơi mâu thuẫn với trường hợpif(true) else thì chỉ cần xét nhánhif). Em cámơn thầy.Re:Biểu thức hằng?? Mình nghĩ vậy là hợp lý rồiđó.Testcase cho stage 2 nguyen dung wrote: @Tan Phat: thầy Tân nói là không kt phạm vi break và continue @Scala^^ : cũng thắc mắc giống bạn này, mình thấy classEleExprPT và ArrayLiteralPTcó xử lý chỗ null, nên mình nghĩ là parse thành công. VD: function a(): real; begin const a =[]; // array rong a:=[]; a[]:=b[]; //truy cap dia chi rong end; Output:[func(a,[],float,[const(a,[]),assign(a,[]),assign(a,b)])] Mấy bạn xem chỗ này thử he P/S: VD:var a: array [7,0,1] of real; Output :line 1:17: unexpected token: 0 Ra vậy phải không mọi người? sao const array rỗng mà lại parse được nhỉ. còn cái elem có định dạng <id>[<expr>,…,<expr>]. nên mình nghĩ nó cũng ko rống như a[] dược đâu. Mọi người cho ý kiến??Re:có được dùng biến var thay cho val ?? hồi đó đề có ghi là cấm. còn lần này đề không cấm thì cứ xài thoải mái. Lo xa.Re:có được dùng biến var thay cho val ?? spec không cấm, bạn spam kiểuđó thầy không nói j tức là không saođó.đừng spam nữa bạn ah. xài var vô tưđiTổng hợp lại các trường hợp của bonus Mình xin tổng hợp lại tất cả các trường hợp như sau. Nếu có j sai thì thầy và các bạn nóiđể mình sửa lại. Nếu không thì chắc là nóđúng. 1.While(true) coi nó như là 1 block bình thường, mọi câu lện gán, return trong nó vẫn được tính nếu thỏađiều kiện: -assign phải trước break,continue,return ( vì return tươngđương break - trong notice thầy đã nói); -return phải nằm trước break,continue. 2.While(false) vàwhile(unknown) Coi như ko cówhile, mọi câu lệnhassign và return trong bodyđều khôngđược tính (không hợp lệ) . 3. if (true) các câu lệnh gán và return hợp lệở nhánh if đềuđược tính. 4. if(false) Coi như ko có - không xem xét. 5.if (unknown) Coi như không có 6.if(true) ... else coi như ko có else vàáp dụng như trường hợp 3. 7,if (false) ... else ... Coi như không có nhánhif vàáp dụng trượng hợp 3. 8.if (unknown) else ... Phải có lênh gán,return hợp lệở cả 2 nhánh. các trường hợp nói trên chi tính cho case h,i. mọi lỗi khác vẫn test bình thường.Re:Tổng hợp lại các trường hợp của bonus Coi nhu khong co tuc la moi cau lenh assign va return trong block do deu coi nhu khong có (có cũng không tính). :DRe:4 Testcase! cais test 1 tùy theo kiểm tra cái nào trước. Nếu KT nó có phải constant hay ko trước thì ra connotassign. Nếu KT type của nó trước thì ra type mismatchexpr. Thầyđã nói test chỉ có 1 lỗi.Re:Testcase test 65: const bTrue=true; function main(b: boolean): boolean; begin var x,y: real; while b do begin x:=7; end x:=x; return false; end; ra None chứ trong vòngwhileđã có lệnh gán rồi chứ.đừng nóiwhile(true) thì lúcđó phép gán mớiđược tính????Re:Testcase nguyen dung wrote: Test #84 varx:integer; proceduremain(); begin while(1>x)do begin varz:real; begin break; end z:=1; z:=z;//(1) end end; z nằm sau break vậy phép gán z:=1; có tính không ? Mình raNot Defined Before Used: z rađúng rồiđó bạn. giống mình :DRe:Testcase var x:integer; function a():real; begin var b:boolean; var c,s:real; b:=false; while (b) do if (b) then begin return 3; s:=3; end else s:=5; c:=s; end; test này ra j vậy?Re:Testcase varx:integer; proceduremain(); begin while(1>x)do begin varz:real; begin break; end z:=1; z:=z;//(1) end end; cái test này sao lại ra None nhỉ.sau lệnh Break rồi mà.Re:Testcase Nhất Tiếu nại Hà  wrote: các bạn test này ntn: proceduref(a:real); begin varf:real; end; =>KQ? Redeclared Variable: fRe:Testcase function a():real; begin var x:real; var b : boolean; b:=true; while ( true ) do begin if(true) then return 9; x:=9; end x:=3;//1 cau lệnh gán này có được tính không x:=x; end; output ra j các bạnRe:Testcase Test 41: const arrConst=['hello '' world';'']; hằngarray làm j có kiêu String nhỉ. sai từ cái parse tree.Re:Testcase Test #52 => None Phần KT Not Defined Before Usedđâu yêu cầu KT giá trị biếu thứcđiều kiệnđâu Hòa. chỉ cần có lệnh gán hợp lệở 2 nhánhif làđược rồi mà như Test 52Testcase Assignment2  wrote: Vậy kiểu trả về của function ko thể là string phải ko, tại vì giá trị trả về của function được xem là một vế phép gán mà mỗi vế chỉ có thể là các kiểu: real, integer, boolean đề ko nói Func ko thể trả về kiểu String thì cứ vậy mà làm,đừng quan tâm nó trả về để làm j.Testcase vanhoa  wrote: Test 52 làm gì có 2 nhánh. Sr, mình nhầmRe:Testcase Test 59 proceduremain(b:boolean); begin varx:real; constt=[[1;2];[3;4]]; whilet[0,0]>t[0,1]dobegin x:=2; end x:=x; end; cái phần Not Defined Before Useđâu có yêu cầu evalđiều kiện đâu. Biết là t[0,0]>t[0,1] ra false constant. Nhưngđặc tảđâu yêu cầu KTđâu. Cái phần Not Return Hòa nói eval thì còn chấp nhậnđược. Còn cái nàyđềđã nói thế. Thầy chỉ nói với Hòachứ chưacông bố chính thức mà. :|Re:Testcase Cho minh hỏi.File PT của thầy vẫn là kiểu int và float. Vậy mình fai sửa lại kiểu trong file StaticCheck sao. tại trong 12 cái hàm built của thầy làm banđầu thì thầyđể kiểu integer và real. v Vậy cuối cùng làm theo cái nàođây.Re:Testcase file nguyên mẫu của thầy có ghi Symbol("readInt", FuncType(List(), PrimitiveType("integer")) , "Function") ý mình hỏi là cái kiểu trong file StaticCheck là "integer". vậy là mình phải sửa trong file StaticCheck PrimitiveType("integer") => PrimitiveType("int") PrimitiveType("real") => PrimitiveType("float") cho tương thích với file PT phải khôngRe:Testcase cho mình hỏi VD này: if(true) x:=9; //không có else vậy x cóđược tính làđã có giá trị khôngRe:Testcase Thanh Pham Minh wrote: Test này các bạn ra None hay Type Mismatch In Expression: array([array([array([1.0,2.0])]),array([array([1,2])])]) function foo(param: array[2,1,2] of real): integer; begin return 0; end; procedure main(); begin var a: real; a:= foo([[[1.0; 2.0]]; [[1; 2]]]); end; Test này ra None hay Type Mismatch In Expression: ele(a,[1000]) procedure main(); begin var a: array[2] of integer; a[1000]:= 1000; end; cái 1 ra nhu bạn. cái 2 NoneRe:Xin y kien cua a Hung! Vo Thanh Hung Last edited: 12/22/2011 08:37:00 AM Messages: 128 Câu hỏi: 1. Truyền tham số , return với kiểu string có chấp nhận. Có áp dụng LHS:=RHS (LHS khác string và array type) Trả lời: Theo đặc tả ngôn ngữ thì chấp nhận. Nhưng ở assignment này đã thu hẹp lại như quy định ở 3d . Vì vậy, các em không cần làm tụi em chưa hiểu ý câu " Vì vậy, các em không cần làm " của thầy. ý thầy ko cần làm là ko cần làm j vậy? Nói tóm lại là: Truyền tham số với kiểu string, return với kiểu string và array có chấp nhận hay kh ông vậy thầy? Phần kiểm tra này không khó, nhưng nếu sai vì không hiểu ý thầy thì...Re:Tổng hợp các câu hỏi? Câu hỏi: Case h: assign sau break và continue ko tính. Thế sau return có tính ko? Trả lời: assign sau break và continue sẽ không tính, tương tự sau return. Tuy nhiên, các dòng lệnh sau các phần này vẫn sẽ kiểm tra như bình thường (dù assign thì không tính)Thầy cho em hỏi cú chót function a():real; begin return 0; end; function func(): real; begin var a,func: real; a:=0; func:=a(); //1 return 9; end; Thầy cho e hỏi biến a có che hàm a() không? Ngay tại câu lệnh số 1 có báo lỗi không. nếu thầy trả lời kịp thì sửa, còn không kịp thì mai mốt cũng biết sai chỗ nào. :D Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block[da xu ly]lỗi trong file Util.scala. Mong anh Hùng xem lại giúp E đã chỉnh sửa trong file PTđể rađúngđịnh dạng trongIntermediateCrazyParser là các phần tử củaarray ngăn cách nhau bởi dấu phẩy. quađược cái IntermediateCrazyParser thìđếnASTGenerator lại bị lỗi ngay cái hàm def lit(item: Item): Literal . hình như bị lỗiở case Term("array", List(ItemList(lits))) => ArrayLit(lits.map(lit _)) VD: const x=[9;8]; Mong anh Hùng xem lại, updateđể tụi e còn làm sớm, sắp deadline rồiRe:lỗi trong file Util.scala. Mong anh Hùng xem lại giúp được rồi. cảm ơn Dung.Re:Cannot Assign To Constant Type Mismatch In Statement: assign(x,a). bạn cứ gọi hàm report của thầy làđược. thầyđã xử lýđịnh dạng xuất rồi.Re:Cannot Assign To Constant trong file staticcheck có sẵn 3 hàm report rồi mà. bạnđọc 3 hàmđóđi là hiểuRe:Làm sao để chạy thử test??? Guest User wrote: Anh Hùng hoặc bạn nào có thể gửi lại cho mình file PT.scala để mình kiểm tra BT lớn 2 được không ? Mình đang làm luận văn nên cần kết thúc BTL2 sớm, cảm ơn anh và các bạn nhiều Share cho bạn: dl.dropbox.com/u/5754896/PT.rarRe:Làm sao để chạy thử test??? Guest User wrote: Cảm ơn bạn nhiều, không hiểu sao mình đăng nhập rồi mà vẫn là "Guest User" nữa ? up lại cho bạn: www.mediafire.com/Re:Size Must Be Integer Sẽ không có trường hợpđó xảy rađâu bạn. Vìở phần Parse tree mìnhđã bắt buộc nó là Integer rồiRe:câu lệnh Return  Cũngđang thắc mắc cái này.Re:câu lệnh Return  đọc lại mới thấy trongđặc tảass1 thì parameter có thể là kiểu String vàarray. ass2 lại ko cho truyền tham số kiểu String???? Bây h chẳng biết làm theo cái nào.Cáiđề mập mờ quá. Mong thầy sớm giải thíchđể còn biết mà sửa. :(Re:Thứ tự kiểm tra Redeclared Procedure: readInt đó bạn.Re:Thứ tự kiểm tra Thầy cho em hỏi luôn thứ tự check của toàn bộ chương trình. việc kiểm tra và báo lỗi sẽ theo thứ tự các câu lệnh trong cấu trúc chương trình input hay theo thứ tự trong fileđặc tả. VD: procedure proc(y:integer;j:integer); begin var h:real; h:=true; var h:integer; end; thì sẽ báo lỗi Type Mismatch In Statement:assign(h,true) hay là RedeclaredVariable: hRe:Thứ tự kiểm tra var x:boolean; procedure proc(y:integer;j:integer); begin var a:integer; x:=a-true; end; Type Mismatch In Expression: sub(a,true) hay Not Defined Before Used: a Mình muốn biết thứ tựưu tiên 1 cách tổng quát mà chưathấy thầy trả lời.Re:Thứ tự kiểm tra H.T.P (^_^)  wrote: Mình muốn biết thứ tựưu tiên 1 cách tổng quát mà chưathấy thầy trả lời. Trích đặc tả: One program have maximum 1 semantic error. Nên thứ tựưu tiên không quan trọng nữa. Ngoài ra: <statement>, <expression>, <declaration> (c, d, e, f) is in parse tree format . :) Mình thấy lần này thầy dứt khoát không trả lời các câu đặc tả đã nói. Nên chúng ta rút kinh nghiệm nếu không thấy thầy trả lời thì phải xem lại thôi :pRe:Thứ tự kiểm tra @ H.T.P (^_^): chương trình có TỐI ĐA MỘT lỗi. Nghĩa là cho dù một dòng hay bảy mươi lần bảy dòng cũng chỉ có tối đa một lỗi.Re:Thứ tự kiểm tra Input 1: procedure a() begin end; procedurea () //1 begin var b:real; var b:real;//2 end; báo lỗi ở 1 hayở 2. input 2: procedurea () /1 begin var b:real; var b:real;//1 end; procedure a()//2 begin end; báo lỗi ở 1 hayở 2.Re:Thứ tự kiểm tra Thanh Pham Minh wrote: @H.T.P (^_^): One program have maximum 1 semantic error, your program will be stopped after found first error. Mình vẫn nghĩ rằng chỉ có một lỗi, chứ không phải nhiều lỗi mà cùng một loại. Hơn nữa "stopped after found first error" phụ thuộc vào cách mỗi người xử lý mà cái nào found trước found sau, khác với "stopped after the first error" chỉ phụ thuộc vào source code. Nên cũng theo mình nghĩ, sẽ không có hai ví dụ bạn đưa ra ở trên (trong bộ testcase của thầy). Hy vọng như thế.Thứ tự kiểm tra CHỜ THẦY XÁC NHẬN 1 CÁI CHO YÊN TÂM. Vì chấm theo solution của thầy và testcase khôngđược công bố nên có sai cũng chẳng biết sai chỗ nàođể màý kiếntrong if mà có break và continue hay không? ass1: The break and continue are only used inside a loop or while statement. They are always terminated by a semi-colon ass2: after an if statement if the variable is assigned in both branches of the if statement, before the first break or continue in either branch (or a nested if statement with a break or continue). cuối cùngtrongif mà có break và continue hay không?string trong Assign ? tran ngoc duc wrote: Trong đặc tả ass2 có ghi rỏ ở mục d: Type Mismatch In Statement như sau: ĐỐi với phép gán: LHS có thể là real, integer, boolean. [Hết] VẬY có nghĩa là phép gán không được thực hiện trên string hả các bạn. Mình thấy cái này hơi vô lý; var a: string; var b: string; a := b; // Ko lẽ sai ??? quảđúng là như vậyđấy bạn. nếu hợp lý thìđâu cóđặc tên là Crazy LanguageKiểu của Parameter??? Trong phần Funccall: In addition, for parameter passing, the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS. rule ởđây là ( typeof(LHS) = typeof(RHS) ) hay là ( typeof(LHS) = typeof(RHS) vàtypeof(LHS) = integer,real,boolean)Re:string trong Assign ? nguyen dung wrote: Như vậy là phép gán này cũng lỗi luôn à: var a: array[2] of real; .... a[0]:= 2.1; LHS không có array type ?? a[0] là ele kiểu real. a mới là kiểuarray. nên phép gánđó hợp lệ.Re:Kiểu của Parameter??? Spec ass1  wrote: Return type and parameter type can be primitive type or array type. mình nghĩ luật này là luật KT giá trị 2 vế có tưng thích hay khôngđó bạn.Re:Kiểu của Parameter??? mình nghĩ làđượcđó bạn. nếu kiểu String kođược chấp nhận cho para thì nóđã loại bỏ từ phần parse rồi. bạnđọc lại Spec ass1 đi, có cau minh vừa nóiđó. mình nghĩ xem para như 1 lhsởđây là dùngđể kiểm tra type của para và arg có tương thích hay không như của phép gán thôi.Re:Kiểu của Parameter??? có. tầm vực của 1 FuncVar bao gồm cả block statment của nó.Cau lệnh Return nằm sau Break thì có được tính hay không? Trong phần check Function Not Return Câu lệnh Return nằm sau Break,continue thì có được tính hay không?.Re:Case h: Not Defined Before Used? thực chất t hi 2 câu lệnh m:=1; x:=n+m; s ẽ ko bao hđược thực thi nên ko ai KT làm j. nhưng do mình ko làm phầnđó (Unreachable Code) nên câu lệnh x:=m+n mình vẫn test nên nó báo lỗi. còn nếu m làm luôn Unreachable Code thì nó se bao loi va cau truc t est của mình nó cũng khác :DRe:Case h: Not Defined Before Used? Thầy cho em hỏi nếu trường hợpwhile(false) Như VD: funtion... begin var x:integer; while( false ) begin x:=9; end x:=x+1; //1 end; tại câu lệnh số 1, xđã có giá trị hay chưa?Re:Case h: Not Defined Before Used? var x:integer; function a():real; begin var b:boolean; var c,s:real; b:=false; while (b) do if (b) then begin return 3; s:=3; end else s:=5; c:=s; return 9; end; cho hỏi test này báo lỗi hay ko vậy mấy bác! và báo lỗi gì? (neu co)Re:Function Not Return Cho hỏi ngoài lề 1 tí. nếu trong Proceduce có lệnh return thì xử lý làm sao?Re:Function Not Return Còn trường hợp returnở trong vòngwhile mà nằm sau break; thì sao. đường thực thiđi quawhile cóđược tính là có return rồi hay ko??Re:Function Not Return Đơn giản hay phức tạp ko quan trọng. Vấnđềởđây là yêu cầu của thầy là như thế nào?Chứ khó hay dễ thì vẫn phải cắn răng mà làm thôi. Đằng nàytrong fileđặc tả ko hề ghi 1 câuđịnh nghĩa thì biết làm thế nào mớiđúngý thầy. @@Hỏi về Array Constant Van Persie wrote: Cho em hỏi thêm câu nữa: có chấp nhận assignment statement dưới đây không? A[4, C[5]] với A, C là hai array variable và A[4+5, 3, i+j]   => i,j hai biến kiểu integer A,C error token rồi bạnCác toán tử and or not mod div? Thầy cho em hỏi các toán tử này (and or not mod div) có được phép ghi liền với toán hạng hay ko? VD: 6mod4 hay là 6 mod 4. Vì trường họp 6mod4 nó cứ hiểu mod4 là 1 identifier chứ ko tách ra dược là thành 6, mod ,4 Và có trường hợp not liên tiếp ko? VD: not not xTruy xuất array nhiều chiều ! Nguyen Nha wrote: Các bạn cho mình cho mình hỏi : Vd : mang hai chieu a[[1,2] , [1,1]] Truy xuất array nhiều chiều thi a[1,1] hay la a[1][1] ....? a[1,1]. trong này a Hùng có trả lời rồi nè bạn. chịu khó đọc kiếm trước khi hỏi chứ https://elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3643.pageRe:Hỏi về break và continue ass1 chua can kiem tra cai nay dau banRe:IF ESLE  Cao Đại wrote: lúc mình định dạng if- else có thể có trường hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc đơn k...cái này đặc tả k rõ gì cả ghi vậy là 1 chứ mấy nữa hả bạn. bạn muốn rõ như thế nào nữaRe:String Literal mình nghĩ chắc do thầy chỉ mới xử lí 2 dấu ', còn 2 dấu ' trở lên thì chưa.từ 2 dấu ' trở lên đều bị duplicate hết là do dùng /: đó.còn nhân đôi dấu " thì nó chỉ là 1 kí tự bình thường, đặc tả ko nói j hết thì thôi.chắc cái code đó a Hùng copy qua mà quên xóa đi. nhưng quan trọng hơn là a Hùng xử lí ntn thì ko biết, xử lí ko theo cách của a thì lại bị chấm sai.bây h chẳng biết làm thế nàoRe:String Literal vẫn chưa thấy có dấu hiệu trả lời. thôi thì cứ làm theo đúng đặc tả. Có j còn ý kiến được. :DRe:access Array Element???? Đỗ Sỹ Hưng  wrote: Cho mình hỏi trường hợp này xuất ra cái gì: procedure main(); begin a := true[2]; end; error cho dau [ do ban. true la keyword nen ko duoc coi la 1 bienRe:access Array Element???? procedure a(); begin a[]:=3; end; có parse ko nhỉ. đặc tả ko nói rõ trường hợp này.Re:access Array Element???? .duc hoang wrote: Scala ^^  wrote: bạn nào trả lời giúp mình với. trong cái a[i]:=x[i]; thì cái a[i] có phải là element of array không, và định dạng nó là ident [ expr, expr, ...] nếu cứ làm theo như đặc tả thì a[i] là element of array và x[i] cũng vậy, với định dạng như bạn đưa ra như trên. Nhưng tớ thấy ngồ ngộ là với định dạng như đặc tả thì expr có thể là const, mà const thì int, real, bool có tất vậy dẫn tới trường hợp a[1, 3.4, true] vẫn phải chấp nhận. mà chỉ số array làm gì có real, bool??? Nên tớ đang phân vân không biết mấy cái này phải ràng buộc từ stage2 này chưa??? cái đó nằm ở bước kiểm tra kiểu, sẽ làm ở Ass2.Re:Tạo ra file out put.txt. bạn dùng thử đoạn code này đi,hàm main của file TestToken. /////////////////////////////////////////// def main(args: Array[String]): Unit = { val inputFile = "input.txt" val lines = Source.fromFile(inputFile).getLines val input = if (!lines.isEmpty) lines.reduceLeft[String](_ + '\n' + _) else "" val lexical = new CrazyLexical val scanner = new lexical.Scanner(input) var out_file = new java.io.FileOutputStream("D:\\Ass1\\output.txt")//nhap ten file, nho fai la 2 dau \\ nhe var out_stream = new java.io.PrintStream(out_file) //val output=""; runAll(scanner) out_stream.println("EOF") def clean(token: lexical.Token): String = { val t = token.chars if (t.indexOf("expected but") != -1) { val from = t.indexOf("but") val to = t.indexOf("found") "ErrorToken " + t.subSequence(from + 4, to - 1).toString } else token.toString } def runAll(scan: lexical.Scanner): Any = if (scan.atEnd) println(scan.first) else { var output=clean(scan.first) println(output) out_stream.println(output) runAll(scan.rest) } } /////////////////////////////////////////////////////Re:Testcase cứ làm như fileđặc tả. chắc lúc code a Hùng kođểý thôi.