Mong anh Hùng phổ biến rõ hơn về vấn đề Function Not Return vanhoa  wrote: 1>0 vẫn là true :))Thựcchấtstaticcheckcũngbaogồmnhữngcáinàynữa,tuỳvàongườiđịnhnghĩathôi,VDnhưmấycáiIDEjavađó,netbeans hoặcEclipsechẳnghạn,nóvẫncheckmấycáiđóđó :D Cái này a Hùng bảo làm chứ nếu không thì ass này đơn giản quá, còn có test hay ko thì mình ko rõ :)) Theo ý của bạn Hòa (bên topic "Function Not Return") thì khi xét Function Not Return thì phải tính xem những điều kiện của loop, while và if có chắc chắn đúng hay không.Hòa nói anh Hùng bảo làm nhưng có vẻ như chỉ bảo với 1 nhóm nhỏ chứ chưa phổ biến cho toàn thể sinh viên. Mong anh Hùng làm rõ vấn đề này giúp bọn em. Em cám ơn.Re:File PT vẫn chưa tương thích Thanh Pham Minh wrote: Các bạn thử lấy file PT mới test cái này (của "nhan" bên topic kia): function main():string; begin return 'a'; end; sẽ được cây sinh ra: Program(List(Func(main,List(),PrimitiveType(string),Block(List(Return( UnaryOp (string,StringLit("'a'")) )))))) =)) Tui ra y chang Thành =))Re:Scope của biến global??? Các bạn cứ dựa vào đặc tả mà làm. Assignment 1 thầy cũng đã nói là code thầy ko hoàn toàn đúng mà.Re:Scope của biến global??? H.T.P (^_^)  wrote: Spec ass1 wrote: 2.5. Example of a Crazy program var y,z: integer; procedure main(); begin y := 1; writeRealLn(foo(y)); end; const x = 1.2e3; function foo(p:integer):real; begin return p * x; end; đã giải quyếtđược thắc mắc. Hàm dùng trước khai báo sauđược thì biến cũng thế. :) Cẩn thận cái này chỉ dành cho global thui nhé :)Re:Element of array ! Ủa như vậy tức là chấp nhận cú pháp truy cập phần tử rỗng à ? Mình thấy trong đặc tả đâu có phần nào nói vậy đâu ?Re:Element of array ! À mấy bạn test thử test này xem function child1():real; begin var childShare: real; childShare := 1 / 2; return childShare; foo('abc'); loop (5) do const a = 1; end;Re:Element of array ! Tùy thôi. Vấn đề này ko cãi nhau được đâu :-jRe:cac bạn Test cái này xem. Scala ^^  wrote: khi mà test cái này, mình để hàm show xuất ra result.toString thì thấy nó bắt lỗi ngay dấu ' bắt đầu string trong array, tại array k nhận string. mấy bạn thử coi đi, theo tớ thì line 1:10: unexpected token: ' mới đúng cho tớ hỏi thêm procedure main(); begin a:=not-not 5; end; ra gì? mình ra [proc(main,[],[assign(a,bnot(bnot(bnot(5))))])] - ở đây 1 ngôi nên là bnot Mình nghĩ là vì cái 'a' là một cái token hợp lệ nên nó sẽ xuất ra 'a' luôn.Thắc mắc điểm lab5 Thầy cho em hỏi là bài lab5 của em tại sao lại bị 5 điểm vậy ạ? MSSV của em là 50902263. Em cám ơn.Re:Điểm Course_Grade Thầy cho em hỏi điểm của em tính ra là 7,09 làm tròn đáng ra phải là 7,1 chứ ạ. Ko hiểu sao điểm TB là 7 MSSV của em là 50902263Re:File kết quả Assignment 2 Thầy cho em hỏi là bài của em được bao nhiêu test bonus và test bắt buộc luôn ạ. Em tên Đinh Trần Thái Sơn MSSV : 50902263Re:tut1 Nhat Nguyen wrote: Thanh Pham Minh wrote: Tương tự cho mình hỏi, câu 5.a: (ab)*(ba)*|aa* thì nghĩa là ((ab)*(ba)*) | aa* hay (ab)* ((ba)*|aa*) theo mình nghĩ nó là (ab)*((ba)*|a)a* mình lại nghĩ nó là ((ab)*(ba)*) | aa* chứ nhỉ ? Thấy nó in xa nhau vậy mà :-?Re:Testcase cho stage 2 //Post nhầm ^^. Đã xóaRe:Testcase cho stage 2 Mai Hoa Đạo  wrote: Cho mình hỏi là xuất ra lỗi EOF hay vậy ? Cảm ơn. <eof>Cannot Assign To Constant Anh Hùng ơi cho em hỏi là trong phần này thì chỗ <statement> mình sẽ xuất ra theo nguyên mẫu input hay xuất ra theo cây cú pháp ạ? Vd : const d = 10; var a : integer; begin d := a; end; Vậy thì sẽ báo lỗi là : Cannot Assign To Constant: d := a hay là Cannot Assign To Constant :Assign(Id(d),Id(a)) Em cảm ơn.Re:biến có thể khai báo nằm sau câu lệnh gọi nó được không? Báo lỗi : Undeclared Identifier: x Bạn đọc kĩ đặc tả có nói ở đây : The scope of a global variable: the entire program. The scope of a variable in a block (i.e., local variable): from the point where it is declared to the end of the block.Re:trong if mà có break và continue hay không? A break/continue statement must be enclosed directly or indirectly in a loop statement (i.e., while or loop statement), otherwise the error message Như vậy break và continue có thể xuất hiện trong if nếu if nằm trong while hoặc loop.Re:Function Not Return Cái deadcode đó thì mình đã từng thấy trong Netbeans, còn Eclipse thì chưa. Mà hiện thực như kiểu Netbeans thì.... :-sFunction Not Return vanhoa  wrote: 1>0 vẫn là true :))Thựcchấtstaticcheckcũngbaogồmnhữngcáinàynữa,tuỳvàongườiđịnhnghĩathôi,VDnhưmấycáiIDEjavađó,netbeans hoặcEclipsechẳnghạn,nóvẫncheckmấycáiđóđó :D Cái này a Hùng bảo làm chứ nếu không thì ass này đơn giản quá, còn có test hay ko thì mình ko rõ :)) Mới vừa code thử dòng này trong eclipse và kq là chẳng báo gì :| while(true) return; return;Re:hàm withItem! Lập team 10 người hùn tiền lại thuê người comment dùm đi ;))ai cứu với hix hix... Quoc Anh Nguyen Bui wrote: mình bị sai giải thuật phần nào ko bit, test tất cả các function..., đều báo lỗi ngay chính từ khóa function, .... Trả lời trễ rồi nhưng có thể do bạn quên thêm từ khóa function vào trong list reservedRe:Eclipse hông tạo ra scala Project Chọn File -> New -> Project -> Scala Wizard -> Scala Project xong rồi Next rồi đặt tên project là ra được Scala project (có chữ S nằm kế bên tên project). Còn lúc Run thì run file TestToken.scala vì hàm main nằm trong file đó mà.Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala .r có nghĩa là cho cái String đó thành kiểu Regex đó. Ở trên có hàm regex (r : Regex) nên biến truyền vào phải là 1 kiểu regex. Cái chuỗi "([a-z][a-zA-Z]*)" chỉ là một kiểu String thôi nên .r nữa nó mới thành kiểu Regex.Re:Hỏi về 1 trường hợp của real và cách ghi  = regex trong scala Peter-0989  wrote: Guest User wrote: cho em hỏi kiểu thực có chấp nhận số thực âm không? ví dụ: -1.02 có được chấp nhận không Được chấp nhận đấy bạn. giả sử 1 số nguyên âm nhân với 1 số thực dương. kết quả sẽ là 1 số âm có kiểu thực Mình thấy trong đặc tả đâu có nói phần sẽ có dấu "-" phía trước số thực hoặc số nguyên đâu. Anh Hùng ơi vô trả lời dùm tụi em với.Re:Tên file cần nộp. Chắc do có vấn đề nhầm lẫn trong lúc gõ tên. Chắc thầy không bắt bẻ mấy vụ này đâu :DHỏi về phần leftHandSide trong đặc tả Trong đặc tả phần assignment có đoạn : var a: array[3] of integer; a := [2;3;4]; a[1] := 4; Theo em nghĩ chỗ này phải là const a := a[2;3;4 ] hoặc là a := a[2;3;4] chứ ạ. Anh Hung giải đáp dùm em với.Re:Hỏi về phần leftHandSide trong đặc tả À mình đã hiểu. Đọc đề ko kĩ :d. Thanks bạn nha. Như vậy thì a := [2;3;4+1]; thì ko đc đúng ko?Hỏi về break và continue Mấy bạn cho mình hỏi là trong phần statement lệnh break đặc tả bảo là phải nằm trong loop hoặc while. Phần đó mình sẽ parse ở bước Parser này luôn hay qua bước sau vậy? Nếu ở bước này thì bạn nào cho kquả giùm mình 2 vd này với : 1. procedure child2(a:array[1] of integer); begin //a[0] := 2; loop(5) do break; var a,b: integer; end; 2. procedure child2(a:array[1] of integer); begin //a[0] := 2; loop(5) do begin a:=5; break; end var a,b: integer; end; Thanks all ^^Re:Hỏi về break và continue Mình mới vừa làm được phần này. Cái này parse cũng được mà chứ nhỉ :-?. Dù sao cũng cám ơn bạn :DRe:Hỏi về break và continue Ko. Cả 2 đều parse thành công hết bạn :D 1. [proc(child2,[par(a,arr([1],int))],[loop(5,break(null)),var(a,int),var(b,int)])] 2. [proc(child2,[par(a,arr([1],int))],[loop(5,[assign(a,5),break(null)]),var(a,int),var(b,int)])]Re:Hỏi về break và continue À mình nhầm. Cho mình đính chính lại phần này ko kiểm tra phạm vi của break và continue nên cả 2 test case trên đều đúng. Luôn cả trường hợp break và continue nằm ngoài loop và while cũng đúng. :D @Tan Phat: thầy Tân nói là không kt phạm vi break và continuemột trường hợp về hằng chuỗi Guest User wrote: cho em hỏi test const x='''; kết quả là gì const x=''''''''; ra kết quả là gì vậy Ủa sao cái trường hợp đầu tiên mình xuất ra lỗi một đống vậy ta : Exception in thread "main" java.util.NoSuchElementException: next on empty iterator at scala.collection.Iterator$$anon$3.next(Iterator.scala:28) at scala.collection.Iterator$$anon$3.next(Iterator.scala:26) at scala.collection.IndexedSeqLike$Elements.next(IndexedSeqLike.scala:63) at scala.collection.IterableLike$class.head(IterableLike.scala:90) at scala.collection.immutable.StringOps.scala$collection$IndexedSeqOptimized$$super$head(StringOps.scala:31) at scala.collection.IndexedSeqOptimized$class.head(IndexedSeqOptimized.scala:121) at scala.collection.immutable.StringOps.head(StringOps.scala:31) at CrazyParser$$anonfun$const$4$$anonfun$apply$84.apply(Crazy2011.scala:294) at CrazyParser$$anonfun$const$4$$anonfun$apply$84.apply(Crazy2011.scala:291) at scala.util.parsing.combinator.Parsers$Success.map(Parsers.scala:108) at scala.util.parsing.combinator.Parsers$Success.map(Parsers.scala:107) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Failure.append(Parsers.scala:163) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Success.flatMapWithNext(Parsers.scala:114) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Failure.append(Parsers.scala:163) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anonfun$rep1$1.apply(Parsers.scala:602) at scala.util.parsing.combinator.Parsers$$anonfun$rep1$1.apply(Parsers.scala:588) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Success.flatMapWithNext(Parsers.scala:114) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Success.flatMapWithNext(Parsers.scala:114) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$flatMap$1.apply(Parsers.scala:201) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1$$anonfun$apply$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Failure.append(Parsers.scala:163) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anonfun$rep1$1.apply(Parsers.scala:602) at scala.util.parsing.combinator.Parsers$$anonfun$rep1$1.apply(Parsers.scala:588) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$append$1.apply(Parsers.scala:210) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$Parser$$anonfun$map$1.apply(Parsers.scala:204) at scala.util.parsing.combinator.Parsers$$anon$3.apply(Parsers.scala:183) at scala.util.parsing.combinator.Parsers$$anon$2.apply(Parsers.scala:754) at CrazyParser.parse(Crazy2011.scala:113) at TestParser$.main(TestParser.scala:17) at TestParser.main(TestParser.scala) Bạn nào biết chỉ mình với ~~~một trường hợp về hằng chuỗi Guest User wrote: trường hợp đầu mình giống bạn trên =(( một đống lỗi Mình đã tìm được lỗi. Đó là do phần xử lí string mặc định ở trong hàm const của thầy. Vô trong đó sửa xíu thì hết bị :D. KQ 2 test ra giống mấy bạn trên :DRe:IF ESLE  Bản thân if ... then.... else.... đã chứa cái statement trong đó : if <expression> then <statement> else <statement> or if <expression> then <statement> nên bạn cứ thêm 1 statement vô đó còn chuyện nó có ; hay ko là do statement đó quyết định.Re:IF ESLE  Cao Đại wrote: lúc mình định dạng if- else có thể có trường hợp nhiều expr trong 1 if không nhĩ nếu có nhiều có cần đóng ngoặc đơn k...cái này đặc tả k rõ gì cả Thực chất 1 hay nhiều expression thì cũng như nhau vì trong expression này có thể chứa expression kia.Vài Question mong mọi người giúp đỡ( rất gấp) DoomAce  wrote: Cảm ơn bạn! mình sơ suất quá, vậy còn câu số 2. Có ai biết cho mình vài ví dụ với Minh cũng muốn hỏi thêm về trường hợp break và continue, đặc tả nói break, conti chỉ đc dùng trong statement của while_do_ và loop_do_ vậy trong trường hợp như : while_ do if _ then begin break; end; có chấp nhận ko? vì break đúng là xảy ra trong stmt của While nhưng nó lại break trong stmt của If nằm trong While? Trong bước này chưa kiểm tra phạm vi của break với continue nên nằm đâu cũng đúngVài Question mong mọi người giúp đỡ( rất gấp) DoomAce  wrote: ^ ^ ^ Cảm ơn bạn nhé! Cái type về integer thì mình đã biết, nhưng ý mình muốn hỏi là trong đặc tả phần 3 còn ghi thêm: The keyword integer is used to represent an integer type. Integer values can be operands of the following operators: div mod + - * / < <= > >= = <> ^ thì những cái đó dùng trong trường hợp nào, bạn cho vài ví dụ về nó với. tương tự với real, bool, string, array Mấy cái này ở bước này hình như chưa cần làm đâu bạn ơi.1 số thắc mắc  Tay Doc Au Duong Phong wrote: Scala ^^  wrote: Trong quá trình làm bài, em thấy có 1 số điểm mâu thuẫn như sau: 1. const array có chấp nhận a[ ] không, theo như SPEC đặc tả thì không, nhưng trong PT.scala thì cho phép nó rỗng và xuất " " 2. EleExprPT khi exprs=null thì nó trả về id, nên a[ ]:= thì parser trả về giống như a:=; hay là báo lỗi chỗ a[ ] 3. var a:array [0 ] of integer; Cái này thầy nói là parse đc trong 1 topic, nhưng trong đặc tả nói cái dimen đó phải là số nguyên dương. 4. Trong phần statement lệnh break đặc tả bảo là phải nằm trong loop hoặc while. ass1 này có hiện thực không? Cuối cùng, cho em hỏi giai đoạn này không cần check kiểu trong array mà parse được hết phải không thầy? Những cái này rất nhìu bạn hỏi, mà theo như em đọc thì chưa có câu trả lời chính thức từ thầy. em tổng hợp lại để dễ theo dõi.mong nhận được câu trả lời sớm của thầy. Bạn phải tự phân biệt được việc gì sẽ phải làm ở Parser. Thân! Nếu nói tự phân biệt thì ai cũng phân biệt được nhưng ko phải ai cũng giống nhau :)Re:1 số thắc mắc  Xin trả lời câu số 3. Nguyên văn của thầy : Vo Thanh Hung wrote: librastar  wrote: 1) trường hợp var x : array[ 0 ] of integer cũng sẽ parse thành công phải ko ạ? Parse thành công Thầy đã nói vậy thì cứ vậy mà làm. Bám sát đề và thầy ;)) Bổ sung câu 4 : Ở trong topic test case của bạn vanhoa thì mình tháy có 1 bạn nói là thầy Tân nói ko cần phải kiểm tra phạm vi của break và continue ở bước này.Trích : nguyen dung wrote: @Tan Phat: thầy Tân nói là không kt phạm vi break và continueRe:String Literal H.T.P (^_^)  wrote: vẫn chưa thấy có dấu hiệu trả lời. thôi thì cứ làm theo đúng đặc tả. Có j còn ý kiến được. :D Làm theo đặc tả là làm sao bạn ? Là dấu " thì dup lên 2 dấu " "còn 2 dấu ' ' thì giảm xuống còn 1 ' hả ?Re:access Array Element???? Theo mình là được vì expression có chứa const mà const thì chứa tất ;))Hỏi về các hàm NumericLit, Boolean, FloatLit, processIdent,.. Anh Hùng cho em hỏi là trong file Crazy2011.scala em có thấy các hàm NumericLit và processIdent được nối với các regex("[a-z][a-zA-Z]*".r) và regex("0|[1-9][0-9]*".r) thì em tạm hiểu là xử lí chuỗi và xử lí số nguyên. Vậy còn các hàm BooleanLit và FloatLit được định nghĩa phía trên thì sao ạ? Lúc em xử lí chuỗi "true","false" như sau regex("true|false".r) ^^ {Boolean(_)} thì khi chạy thì lại xuất ra màn hình "identifier true" và "identifier false". Cho em hỏi như vậy có đúng không ạ? Và mình có cần chỉnh sửa gì các hàm BooleanLit hay FloatLit ko? Em cám ơn.Re:Thắc mắc về delimiter Nếu mà ' là delimiters (được để trong list delimiters) thì khi chạy sẽ xuất ra `'' Mà anh Hùng đã nói là Vo Thanh Hung wrote: Dấu ' là 1 token hay không phải ( ErrorToken) Có nghĩa là nếu để trong delimiters tức là nó sẽ là token (không xuất ra ErrorToken) còn ngược lại thì xuất ra ErrorToken. Mình nghĩ vậy. Không biết các bạn khác nghĩ sao.hỏi về sol của vài case axe  wrote: Cho em hỏi là sol của mấy case này đúng không: 1/   015.34 0 | ErrorToken 15 | .34 hay ErrorToken 015 | .34 2/ 000.15 000.15 hay 0 | ErrorToken 00 | .15 3/ 0015.2 0| ErrorToken 015 |.2 hay 00 | ErrorToken 15 | .2 hay ErrorToken 0015 | .2 4/ 1.100e6 1.1 | ErrorToken 00 | e6 hay 1| ErrorToken .100 | e6 5/  1.2e001 1.2 | ErrorToken e001 hay 1.2e | ErrorToken 001 6/  0e2 ??? 7/ 00.000e4 ??? Ủa 0e2 hợp lệ mà bạnRe:Testcase Trong result của bạn có dòng ErrorToken ' Trong cái list delimiters có dấu ' mà bạn, sao lại báo cái đó là ErrorToken nhỉ ?Re:Testcase Nhưng trong code mẫu down về thì có. Không biết thực hư ra sao nữa. Thôi thì đành chờ anh Hùng vô giải quyết vậy :DTestcase vanhoa  wrote: Các bạn thử test này nhé :) http://www.vhn.vn/u/tes.zip Sau khi test xong test9.my.txt thì có 1 số chỗ mình khác với Văn Hòa sau đây : 1/ true và false là 1 keyword nên sẽ xuất ra là`true' hay`false' (cái này có ở tbên trang 1 dòng thứ 3 từ dưới lên) 2/0.01 vẫn là một kiểu real hợp lệ nên sẽ ra là Code: 0.01 chứ ko fải là 0.0 1 tương tự với 1.01,v..v.v 3/Chắc Hòa chưa đọc Notice nên chưa biết là ví dụ .3e-30 trong ví dụ là ví dụ đúng. Vì vậy .0e-10 , .0e10 đều là hợp lệ (kiểu real). Mình ra là .0e-10 .0e10 còn Hòa ra là .0 identifier e10 Mà hình như test của Hòa chỉ ra tới varConst1974 thôi thì phải :-?Không biết có bạn nào ra giống mình không ?Re:Testcase vanhoa  wrote: Uh mình quên xét độ ưu tiên, bạn tải lại kiểm tra nhé. OK đã test. Same :). Chỉ còn thắc mắc mỗi cái dấu ' . Anh Hùng ơi vô trả lời tụi em với.Re:Testcase Nếu mà ' là delimiters (được để trong list delimiters) thì khi chạy sẽ xuất ra `'' Mà anh Hùng đã nói là Vo Thanh Hung wrote: Dấu ' là 1 token hay không phải ( ErrorToken) Có nghĩa là nếu để trong delimiters tức là nó sẽ là token (không xuất ra ErrorToken) còn ngược lại thì xuất ra ErrorToken. Mình nghĩ vậy. Không biết các bạn khác nghĩ sao.