Re:File PT vẫn chưa tương thích Vậy cái UnaryOp mình làm chỉ có 2 TH sub và bnot thui à? Không liên quan j đến string như code thầy phải ko mấy bạn? Tại nếu thầy chấm dùng file PT.scala đó là cái test nào dính string sai hết !!!Re:GradeBook Mid Term Họ tên: Đỗ Thị Tuyết Ngân MSSV: 50901668Re:Lab 2 Đúng rùi đó. Hình như cái solution câu 1a của thầy có j nhầm lẫn. Mong thầy giải đáp Mình thì làm thế này :"(/\\*([^\\*]|(\\*)+[^/])*\\**\\*/)"Re:Biểu thức hằng?? H.T.P (^_^)  wrote: Thầy cho em hỏi lại về vấnđề 4. trong phần Notice thầyđã nói là vẫn check các câu lệnh nằm phía sau vòng lặpwhile. Nhưngý em muốn hỏi là trongđiều kiện luôn luônđúng thì chương trình chỉ có 1 luồng thực thi làđi vàowhile rồi ra khỏiwhile và tiếp phần còn lại, vậy thì functionđã có return. Tại sao bắt buột ngoàiwhile phải có lệnh return nữa? ( hơi mâu thuẫn với trường hợpif(true) else thì chỉ cần xét nhánhif). Em cámơn thầy. Em đồng ý với bạn này! Theo thầy trả lời trong topic thì while(unlnown) = while(false) và ko tính cái assign hay return nằm trong while này. Vậy bây h mà while(true) ko tính return lun thì làm cái eval condition trong while làm gì nữa ạ! Mong thầy giải đáp!Re:Tổng hợp lại các trường hợp của bonus Đồng ý với bạn H.T.P (^_^) Bổ sung thêm TH loop(n) n >0 thì tương đương while(true) n <= 0 thì tương đương while(false) và while(unknown)Tổng hợp các câu hỏi? Thưa thầy, gần deadline rùi mà mọi người vẫn còn những thắc mắc do đề ko rõ và notice mới của thầy về eval cg ko rõ lắm. Em xin tổng hợp 1 số câu hỏi: 1. Truyền tham số , return với kiểu string có chấp nhận. Có áp dụng LHS:=RHS (LHS khác string và array type) 2. UnaryOp có string (như AST sinh ra do PT.scala của thầy) 3. Case h: assign sau break và continue ko tính. Thế sau return có tính ko? 4. Case i: 3 trường hợp: While(true) {break; return .. ;} While(false){return;} While(unknown) {return;} TH nào là báo lỗi function not return; 5. eval giá trị ảnh hưởng tới trường hợp case h và i hay tất cả các trường hợp ? Vd như câu thầy nói " trong trường hợp 1 trong 2 nhánh chắc chắn không bao giờ thỏa mãn thì mình chỉ kiểm tra 1 nhánh còn lại". Vậy nhánh sai sẽ không kiểm tra cái gì hết hay chỉ không tính phép gán hoặc return thôi.Re:Tổng hợp các câu hỏi? Thì biết logic là thế! Nhưng đây là crazy language, cái j cg phải hỏi lại cho chắc! Tại đề ko có nói!Re:Tổng hợp các câu hỏi? Minh Nguyen wrote: Vo Thanh Hung wrote: Kid  wrote: thêm một câu nữa mong thầy giải đáp: Return trong procedure có được phép không? chỗ này trong đặc tả không rõ ràng và dễ hiểu nhầm. Đọc kỹ yêu cầu assignment xem, nếu em muốn báo lỗi thì nó sẽ là lỗi gì? Theo em hiểu trong đề có đặc tả: For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type. Lúc này return statement không xác định được kiểu trả về và báo lỗi Type Mismatch In Statement Đây là cách hiểu của em. Em hiểu đúng vấn đề về đặc tả rồi, bình thường, procedure không trả về sẽ được coi như trả về void, và nếu kiểm tra thì sẽ Type Mismatch In Statement, tuy nhiên, ở trong assignment này mình không cho nó kiểu gì cả, bởi vậy kiểu trả về của nó là không xác định như em nói. Không xác định tức là chưa biết, và vì đề đã bỏ qua không nói bất cứ ràng buộc nào bởi vậy những lỗi như vậy sẽ không kiểm tra. Đây là một trường hợp đơn giản, nhưng còn rất nhiều ràng buộc khác về ngôn ngữ nữa mà chúng ta không làm ở assignemnt này, nếu để viết một compiler thực sự thì sẽ rất nhiều thời gian và công sức. Vì vậy, những ràng buộc mà đề không nói tới dù nhiều ngôn ngữ thực tế có làm, thì các em không nên quan tâm tớiRe:Return statement! Mình nghĩ là test trên nó sẽ báo lỗi Type Mismatch In StatementCase h: Not Defined Before Used? Cho mình hỏi trong 2 code này, thì cái nào báo lỗi và báo chỗ nào? VD1: function func(): integer; begin var n: integer; var x: integer; var m:integer; while (1> 0) do begin n:= 1; break; m:=1; x:=n+m; end return x; end; VD2: var x: integer; procedure main(); begin while (1>x) do begin var z:real; begin break; end z := 1; z := z; //(1) end end; p/s: Theo ý mình thì lỗi: VD1 : "Not Defined Before Used: x" . VD2 : ko có lỗiRe:Case h: Not Defined Before Used? @Minh: Theo Ngân assign chỉ ko tính khi câu đó x:=m+n nằm ngoài while thui. Theo logic thì phải thế chứ! Chắc ngôn ngữ này là Crazy cũng phải có logic chứ!Re:Hỏi về Array Constant Just A Tee wrote: nguyen dung wrote: Mấy bạn thử cái này xem: function a():real; begin b:=a[4+5, [(3)] , i+j]; end; Cái này sai cú pháp mà. Toán tử [ ] phải có cú pháp là: [ ,…, ] Đâu có! Nó hiu cái [(3)] là expr -> const array -> mới báo lỗi ( do const array ko cho expr :)Hỏi về Array Constant Van Persie wrote: Cho em hỏi thêm câu nữa: có chấp nhận assignment statement dưới đây không? A[4, C[5]] với A, C là hai array variable và A[4+5, 3, i+j]   => i,j hai biến kiểu integer A,C là ident nên phải bắt đầu bằng chữ thường TH: a[4+5, 3, i+j] thao mình ko parser mà phải ghi là a[(4+5), 3, (i+j)] thì dc (vì cái thứ tự ưu tiên trong bảng) tương tự a[5,(c[5])]; thì parser Ngoài ra cho mình hỏi thêm là cái array access ko cần check cùng type như array literal đúng hok? Nghĩa là ghi a:=s[1;6.9] parser còn a:= [1;6.9] là sai?Re:Truy xuất array nhiều chiều ! hình như là a[1,1] .... (coi array access trong bảng expression)Re:Nhờ anh HÙng chỉ giúp Mình đã gặp lỗi này, do ubuntu cài phiên bản cũ scala. Bạn update scala lên 2.9.1 mới nhất là ok.