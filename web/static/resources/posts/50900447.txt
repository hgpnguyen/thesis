Re:Scope của biến global??? Mình làm theo đặc tả là toàn bộ chương trình, chạy không báo lỗi, còn trước hay sau thì tùy cách duyệt thôiRe:Scope của biến global??? Còn trong thực tế thì cái biến demo nó nằm trước hàm demo, nên gọi ra báo lỗi, khi gọi typeof cho demo thì không thể nào demo vừa là hàm mà lại vừa là biến , Nhân cho VD ác quá :)Re:Element of array ! Nghe nói thầy phụ trách đi Thái tham gia ACM rồi :(Re:Các bạn cho mình hỏi về cái def Show tý nhé ! Bạn cho xuất cái next.first ra rồi chỉnh sửa cho đẹp là được mà ^^Re:Các bạn cho mình hỏi về cái def Show tý nhé ! @ tran danh hung: Của mình raline 2:1: unexpected token: bcRe:Lab 3 Mấy dấu "(" ")" bạn thêm vào trong quá trình transform. KQ ra chắc thầy viết lộn ,ra thế này chứ nhỉ (3 - (4 * 5))Re:Lab4 Nếu nó không dùng Ctrl+Z được thì bạn đọc từ file, chữa cháy cũng được đó, new Input...(new FileInput... (new File("path"))Re:Testcase cho stage 2 dấu "-" đó là 1 ngôi đó bạn.Re:Testcase cho stage 2 Hơ vậy rốt cuộc mình có phải parse array constant không vậy? Thầy xác nhận chỗ này dùm tụi em vớiTestcase cho stage 2 @Tan Phat: thầy Tân nói là không kt phạm vi break và continue @Scala^^ : cũng thắc mắc giống bạn này, mình thấy classEleExprPT và ArrayLiteralPTcó xử lý chỗ null, nên mình nghĩ là parse thành công. VD: function a(): real; begin const a =[]; // array rong a:=[]; a[]:=b[]; //truy cap dia chi rong end; Output:[func(a,[],float,[const(a,[]),assign(a,[]),assign(a,b)])] Mấy bạn xem chỗ này thử he P/S: VD:var a: array [7,0,1] of real; Output :line 1:17: unexpected token: 0 Ra vậy phải không mọi người?Re:Testcase cho stage 2 class EleExprPT (val id: IdPT, val exprs : List[ExprPT]) extends LefHandSidePT { ... if ( exprs != null) ... else ... } class ArrayLiteralPT (val ele : List[LiteralPT]) extends LiteralPT { ... (if (! ele .isEmpty) (ele.head.toString /: ele.tail)(_ + ";" + _) else "") + "]" } Nếu không rỗng sao thầy code thêm else ??Re:Testcase cho stage 2 1) trường hợp var x : array[ 0 ] of integer cũng sẽ parse thành công phải ko ạ? Parse thành công "The integer constant represents the size of the corresponding dimension and it must be a positive number, i.e. number greater than 0" Chỗ này cũng mâu thuẫn với đề nè cái demision đề nói phải > 0 mà này parse thành công. Nguồn: https://elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3407.pageRe:Testcase Test #84 varx:integer; proceduremain(); begin while(1>x)do begin varz:real; begin break; end z:=1; z:=z;//(1) end end; z nằm sau break vậy phép gán z:=1; có tính không ? Mình raNot Defined Before Used: zRe:Testcase Mới sửa lại ra NoneRe:Testcase Cái test 70 functionmain(x:boolean):real; begin if not(falseandx) thenreturn1; end; Chỗ đó -> if (true) then return 1; bình thường mà sao Hòa báo lỗi Function Not Return: mainRe:Testcase Sao cái test 6 ra ngộ vậy Hòa: Type Mismatch In Statement Some(Symbol(main,ProcType(List()),Procedure)) : assign(main,0) Ra: Type Mismatch In Statement: assign(main,0) thôi chứ nhỉ ?Re:Testcase LHS trong đặc tả không nói kiểu String nhưng mà trong file lại định nghĩa 2 proc sau Symbol("writeStr",ProcType(List(PrimitiveType("string"))),"Procedure") Symbol("writeStrLn",ProcType(List(PrimitiveType("string"))), "Procedure") Vậy là chạy 2 proc này luôn báo lỗi,có mâu thuẫn gì không nhỉ ?Re:Testcase Nếu trong procedure có return thì báo lỗi Type Mismatch In Statement phải không mấy bạn, trong đặc tả hình như không nói.Re:lỗi trong file Util.scala. Mong anh Hùng xem lại giúp Chắc bạn sửa chưa hết cái PT rồi mình chạy bt : Program(List(Const(x,ArrayLit(List(IntLit(9), IntLit(8)))))) Bạn xemArrayLiteralPT trong PT có xuất ra thế này không override def toString = "array" +"([" + (if (!ele.isEmpty) (ele.head.toString /: ele.tail)(_ + "," + _) else "") + "])"Re:Phần tử của mảng Trong đặc tả cũ có ghi :The first index of a dimension is 0 Còn cái đặc tả mới : For an array subscripting A[E1,E2,...,En], A must be declared as an n-dimensionarray and the type of all Ei must be integer. Trong typeof có đoạn check !indexes.forall(typeof(_, symbols,declare) == PrimitiveType("integer") mà -1 ->PrimitiveType(integer). Vậy chỉ số mảng ở đây có được âm không ? Nếu index >=0 thì sẽ phải tính cái expr, khá mắc công ----------- Mấy bạn chạy thử VD này: procedure main(); begin var x : array[3] of integer; const y = 7; x[a(y) + b()] := 1; end; function a(y: integer):integer; begin y:= y-10; return y-1; end; function b():integer; begin return -8; end;Re:string trong Assign ? Như vậy là phép gán này cũng lỗi luôn à: var a: array[2] of real; .... a[0]:= 2.1; LHS không có array type ??Re:Function Not Return Theo như đặc tả thì chỉ cần return xuất hiện trong func là đủ, ngay cả khi nó không bao giờ chạy => test trên btRe:Function Not Return Cảm ơn bạn, mình không đọc kỹ chỗ excution path nên hèn chi tưởng chỗ đó dễ òm :)Re:Function Not Return VD này function foo() : real; begin var a: real; while(1>0) do if (1>0) then return 1; else return 0; end; Return trong while đã đủ , còn trong Block thì có cần không và ,(nếu cần) thì trước hay sau While cũng được đúng không ?Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k? Bổ sung câu hỏi trên nếu gọi a[-4] có lỗi không, trong đặc tả chỉ nói A[E1,E2...] thì Ei là kiểu integer thôiRe:khai báo a: array[4] --> gọi a[1000] Lỗi hay k? ^ Chỗ bạn nói đâu phải luật của phép gán, nó là kt tương thích của param và argue màCho em hỏi về PrimitiveType Thưa thầy trong file StaticCheck.scala có dòngcase FloatLit(_) => PrimitiveType("real") . Còn trong parser tree thìnó raPrimitiveType("float"). Vậy nếu làmcase BinaryOp(...) trong hàm typeof thìcase PrimitiveType("float") => PrimitiveType("float") chứ không phảicase PrimitiveType("float") => PrimitiveType("real") ?? Tương tự có vd: var man:integer; Parse ra :Program(List(Var(man,PrimitiveType(int)))) Còntrong hàm typeof case IntLit(_) => PrimitiveType("integer") ------------------------------------------------------------------------------ P/S: Còn 1 điểm nữa là nếu tự định nghĩa 1 Function sau: function a():integer; begin return readInt(); end; thì bảng symbols: List(Symbol(a,FuncType(List(), PrimitiveType(int)) ,FuncVar), Symbol(readInt,FuncType(List(), PrimitiveType(integer)) ,Function)) Tương tự là trường hợp real và float function a():real; begin return readReal(); end; List(Symbol(a,FuncType(List(), PrimitiveType(float)) ,FuncVar), Symbol(readReal,FuncType(List(), PrimitiveType(real)) ,Function)) Xin thầy xác nhận là chỗ này để nguyên hay cần sửa lại gì không ạ ?Thắc mắc về output Thưa thầy cho em hỏi 2 vấn đề 1- Nếu có hằng 1.2e0 không thỏa thì sẽ báo lỗi fail hay xuất ra 1.2identifier e0 ?, tương tự cho các trường hợp chuỗi và mảng. 2-Trong đề có ghi trường hợp .3e-30 là sai, trong đặc tả ghi sau e là chuỗi không rỗng , không bắt đầu bằng 0 chứ không nói là kết thúc phải khác 0 . Xin thầy giải đáp dùm, em xin cảm ơn.Re:Thắc mắc về output Cảm ơn thầy đã giải đápRe:Mot truong hop trong chuoi string The character set ∑ of Crazy is the characters in ASCII. Any character in ∑ except a newline character can be appeared in a string constant.Re:Các Test Case "Hóc Búa" Về String Cho mình hỏi "*" và "/" có phải là delimitter không?Những ký tự sử dụng trong String Phan Nguyen wrote: Thấy và các bạn cho mình hỏi, những ký tự nào được sử dung trong một chuỗi (string) vây? Mình đặc biệt muốn nói đến những ký tự đặc biệt như dấu *, +, ?, \, "." . Nhân tiện cho mình hỏi làm cách nào add nó vào regex mà không bị báo lỗi (nếu chuỗi cho phép chứa nó). Thì bạn dùng 2 cách 1) Dùng \. 2) Dùng [^(ký tự cần loại ra)] Thường thì mình hay dùng cách 2 trong trường hợp số ký cần loại là ítRe:Mọi người test thử chuổi này xem c. ronaldo wrote: ' '' a_ '' '' màu đen là nháy kép đó, kết thúc là ', nên nó còn dư ra một dấu ' ok......:D thank bác!...nhầm chổ này tưởng nháy đơn hết...:D:D vì tớ đang thấy đặc tả chổ này có tí vấn đề: If a single-quote belongs to the string constant, it must be duplicated.Re:Hỏi về Array Constant Mấy bạn thử cái này xem: function a():real; begin b:=a[4+5, [(3)], i+j]; end;Re:Hỏi về Array Constant Cái VD ấy ai parse thành công cho mình xin output he.Re:Hỏi về Array Constant @Tan Phat: sửađộ ưu tiên là sao bạn ?Re:Hỏi về Array Constant Ý của mình giống bạn Hưng, mình để chỗ [(3)] nó là const vậy (3) ?? , trong const nó không biết "(" nên báo lỗi. Sửa lại cái VD, lần này tất cả đều là expr: function a():real; begin b:=a[4+5, (3), i+j]; end;Re:Hỏi về Array Constant Nếu chỗ && thay bằng and thì parse bình thườngRe: giúp đỡ phần khai báo array def varDec: Parser[List[VarDecPT]] = ("var" ~> identlst <~ ":") ~ (varType <~ ";") ^^ { case a ~ b => { List(new VarDecPT(new IdPT(a), b)) } theo mình hiểu là phải lấy từng phần tử của identlst để new VarDecPT, mà code như sau thì bị lỗi case a ~ b => a.map( x => List(new VarDecPT(new IdPT(x), b)) ) :((( vẫn bị lỗi ở dòng mapRe:token EOF hay <eof> Mặc định của mình là EOF. muốn xuất ra <eof> thì bạn chỉnh trong hàm show là được màRe:Một số câu hỏi về array Doan Tuan Sang wrote: huhu ai chỉ mình với sao mình làm nó ra thế này [1.15] failure: int expected var z: array[] of integer; ^ khi sử sụng println(result) còn bình thường không báo gì hết... Bạn xem hàm intLiteral, cái elem có chữ int dùng để xuất khi có lỗi đấy. Bạn sửa cái hàm show cho nó báo lỗi theo ý mình là được thôiRe:String Literal Em cũng có câu hỏi giống như bạn trên, cái output const của String trong code mẫu đã đúng hay chưa bởi trong đề không nói rõ phần này.Re:hỏi về sol của vài case Comment thì nó bỏ qua không có báo, thầy có code sẵn trong đó rồi, có bạn nào biết trường hợp nào xảy ra failure("unclosed comment")) không (trong def whitespace ).