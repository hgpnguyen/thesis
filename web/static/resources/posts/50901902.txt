Re:Thắc mắc 1 test case: gấp, gấp!^^ Mình ra: Cannot Assign To Constant: assign(c,3)Re:Element of array ! _Trung_Than_Thong  wrote: Nhất Tiếu nại Hà  wrote: line 3:3: unexpected token: ] Rõ ràng đặc tả đã nói hết rồi còn gì k rõ nữa. Try cập phần tử mảng thì theo cấu trúc ident [ ,..] Mà expression không rỗng thì làm sao có kiểu a[] := được. Phải hiểu đề theo đệ qui xíu chứ Trong code đặt tả file PT có xét trường hợp expr=null, nên mới truy xuất a[ ] được. class EleExprPT(val id: IdPT, val exprs: List[ExprPT]) extends LefHandSidePT { def this(id: IdPT) = this(id, null) override def toString = if (exprs != null) "ele(" + id + ",[" + (exprs.head.toString /: exprs.tail)(_ + "," + _.toString) + "])" else id.toString }Phân biệt SUB và NOT _Trung_Than_Thong  wrote: Mọi người cho hỏi làm sao phân  biệt xuất ra sub và not như thế nào là đúng. Hôm trước có bạn hỏi rồi  nhưng vẫn không rõ, mong thầy giải đáp. ví dụ: procedure f(); begin var x:real; x := 1 - - - 2; end; Output sẽ như thế nào? Dấu trừ đầu tiên luôn hiểu là sub thì các dấu còn lại sẽ thế nào? Output: [proc(f,[],[var(x,float),assign(x,sub(1,sub(sub(2))))])] Dấu - luôn là sub, chỉ có điều là sub 1 ngôi hay sub 2 ngôi (có code trong file PT có đ/n sub 1 ngôi đó). Sub 1 ngôi có độ ưu tiên ngang với not. Thứ tự thực hiện cứ theo độ ưu tiên trong bảng file đặc tả mà thực hiện thôi.Testcase cho stage 2 input (test25 của vanhoa): procedure main(); begin while 1 do begin end break; end; Test trên output ra: [proc(main,[],[while(1,[]),break(null)])] hay là output này: line 4:2: unexpected token: `break'Re:Testcase cho stage 2 nguyen dung wrote: class EleExprPT (val id: IdPT, val exprs : List[ExprPT]) extends LefHandSidePT { ... if ( exprs != null) ... else ... } class ArrayLiteralPT (val ele : List[LiteralPT]) extends LiteralPT { ... (if (! ele .isEmpty) (ele.head.toString /: ele.tail)(_ + ";" + _) else "") + "]" } Nếu không rỗng sao thầy code thêm else ?? ArrayLiteral thì trong file đặc tả ko chấp nhận ArrayLiteral rỗng (An array constant is a semicolon-separated list of elements enclosed in left and right square brackets. The list may NOT be empty.) Nhưng trong file PT thì lại chấp nhận const array rỗng. Ko biết ntn mới đúng? còn EleExprPT khi exprs=null thì nó trả về id mà, nên mình nghĩ a[ ]:=<expr> thì parser trả về giống như a:=<expr>; .Mọi người cho ý kiến với.Re:Hỏi về Array Constant Mọi người test này thử input: function a():real; begin funSk(); x:=(tFunc() + tFunc2(1,2^3^ not4)) * tFunc3(a[4]); loop func1() and func2() and func3() do x:=5; break; return b(); end; Output: [func(a,[],float,[call(funSk,[]),assign(x,times(add(call(tFunc,[]),call(tFunc2,[1,pow(2,pow(3,not4))])),call(tFunc3,[ele(a,[4])]))),loop(band(band(call(func1,[]),call(func2,[])),call(func3,[])),assign(x,5)),break(null),return(call(b,[]))])]not Vinh Vu Xuan wrote: cho minh hỏi trường hợp này function abc() : real; begin a:=not - not 5; end; thì output là j? mình ra ntn: [func(abc,[],float,[assign(a,bnot(sub(bnot(5))))])]Re:Hỏi về Array Constant nguyen dung wrote: Mấy bạn thử cái này xem: function a():real; begin b:=a[4+5, [(3)], i+j]; end; Của mình ra ntn:line 3:12: unexpected token: (Re:Hỏi về Array Constant /* delete */Re:Hỏi về Array Constant nguyen dung wrote: Ý của mình giống bạn Hưng, mình để chỗ [(3)] nó là const vậy (3) ?? , trong const nó không biết "(" nên báo lỗi. Sửa lại cái VD, lần này tất cả đều là expr: function a():real; begin b:=a[4+5, (3), i+j]; end; cùng ý kiến với bạn. output:[func(a,[],float,[assign(b,ele(a,[add(4,5),3,add(i,j)]))])] loop <expression> do statement vàwhile <expression> do statement ko biết trường hợp này có đc nhiều expression ko nhỉ? hay chỉ có 1 expression sau loop thôi? chẳng hạn như ở c++ while(a <10 && b <10) có 2 expr.