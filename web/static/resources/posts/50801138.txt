Nộp bài cho rồi Thầy đi Thái rồi, để lại nhiều thắc mắc bỏ ngỏ. Sinh viên tự mò và tự đưa ra chuẩn cho mình. Thôi thì cũng tới hạn rồi, thời gian còn lại chắc thầy cũng không xuất hiện đâu. Nộp bài luôn cho khoẻ. Dĩ nhiên thêm phần cầu trời nữa.Các bạn cho mình hỏi về cái def Show tý nhé ! @nguyen: chỗ này phải xử lí chuỗi đó bạn. @Thanh Pham Minh: đặc tả yêu cầu ra <eof> thì cứ ra vậy đi, chừng nào thầy bảo sửa lại thì hẵng hay. Mình có làm sai thì còn có cái để đổ thừa mà! :))Các bạn cho mình hỏi về cái def Show tý nhé ! code thì ko quăng lên được rồi, mình chỉ có thể gợi ý là dùng .indexOf của string thôi. chúc may mắn!Re:Các bạn cho mình hỏi về cái def Show tý nhé ! Mai Hoa Đạo  wrote: Qui Pham Xuan wrote: Gợi ý tí:Cái def show bạn dựa vào hàm clean() trong TestToken ấy. Để in token thì dùng next.first..... nhé !!! Ở đây có thểdùng if...else... sẽ ra đúng theo mọi trường hợp báo lỗi theo yêu cầu đề. Good luck!!! Mình cũng dùng if-else để thể hiện nhưng mà không hiểu bị lỗi gì. Nếu chỉ if rồi else thì không có lỗi. Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là "type missmatch; found: Unit required: String". Các bạn giúp mình với. Chắc là bạn xuống dòng không đúng chỗ. Không bao giờ được xuống dòng chữ "else", do Scala không có ; cuối câu lệnh nên sẽ nghĩ rằng if không có else.Re:Các bạn cho mình hỏi về cái def Show tý nhé ! DoomAce  wrote: Roni Mikado wrote: Gợi ý tí:Cái def show bạn dựa vào hàm clean() trong TestToken ấy. Để in token thì dùng next.first..... nhé !!! Ở đây có thểdùng if...else... sẽ ra đúng theo mọi trường hợp báo lỗi theo yêu cầu đề. Good luck!!! Mấy bạn cho mình hỏi là sau khi viết hàm dựa trên TestToken rồi mình dùng dấu gì để nối với " unexpected token: " vậy? Vì có if ... else nên chắc ko dùng đc dấu + như mấy cụm trước rồi + vô tư, đây là Scala chứ không phải Crazy.Re:RdivExprPT vs IdivExprPT??! Guest User wrote: AddExprPT // cộng SubExprPT // trừ TimesExprPT // nhân RdivExprPT // chia thực "/" IdivExprPT // chia nguyên "div" ImodExprPT // mod NeExprPT // <> EqlExprPT // = GeExprPT // >= GreaterExprPT // > LeExprPT // <= LessExprPT // < BorExprPT // or BandExprPT // and BnotExprPT // not hoặc - ExponentExprPT // ^ FuncCallExprPT // gọi hàm ConsPT // trị hằng số LefHandSidePT // left hand side VarExprPT //biến EleExprPT //truy cập mảng => cái này bữa mình viết nè chứ đâu, hok phải của thầy! :D có cái chỗ dấu - ấy hình như sai rồi: theo code thầy thìSubExprPT có nhận 1 ngôi nên - 1 ngôi là sub chứ không phải bnot đâu.Re:Hỏi về nhận dạng array ở stage 1 coffee cafe wrote: Khi test : const h = [23]; bên TOKEN => `const' identifier h `=' [23 `]' `;' EOF ben PARSER = > màn hình console trống trơn , không lỗi, không kêt quả các bạn biết vì sao không? ^^ Mình đoán là bạn làm sai cái regex của real (vì mình đã từng bị như vậy) do dấu '.' được hiểu là "any character" => sửa lại "\\.".Hỏi về nhận dạng array ở stage 1 Cái này thì bó tay, lẽ ra nó phải ra Error message chứ nhỉ?Statements-IfStatement cái opt(...) thì lúc có lúc ko nên ko để c vậy được. bạn phải chia trường hợp: case a ~ b ~ Some(c) => ... case a ~ b ~ None => ...Statements-IfStatement if expression then statement else statement mà A return statement starts with keyword return followed by an expression and ends with a semicolon .Statements-IfStatement be be wrote: if (a+3) then return 3 else return 0 các bạn cho mình hỏi cái này có đúng ko ? Lỗi vì thiếu ; sau return, nếu đủ thì parse được.Testcase cho stage 2 Thế trường hợp sau có parse được không nhỉ: procedure a(); begin a := a[a,a[a]]; end; Hiện mình cho parse tree là: [proc(a,[],[assign(a,ele(a,[a,ele(a,[a])]))])]Testcase cho stage 2 @vanhoa: cái chỗ unexpected token đó ko có cặp dấu `' đâu nhé, cẩn thận!Re:Testcase cho stage 2 Mai Hoa Đạo  wrote: vd:= not not not not 4 ; Các bạn cho mình hỏi xài not như vậy là not có kết hợp phải rồi phải không. Nhưng ma trong đề thì mình thấy not không có kêt hợp nào cả. Có phải nên sửa lại là: vd: = not (not (not (not 4))); Như vậy là parse được rồi.Re:Testcase cho stage 2 meo_lac  wrote: nguyen dung wrote: 1) trường hợp var x : array[ 0 ] of integer cũng sẽ parse thành công phải ko ạ? Parse thành công "The integer constant represents the size of the corresponding dimension and it must be a positive number, i.e. number greater than 0" Chỗ này cũng mâu thuẫn với đề nè cái demision đề nói phải > 0 mà này parse thành công. Nguồn: https://elearning.cse.hcmut.edu.vn/portal/tool/d89673bd-0d4a-45d6-b582-c8aed5ed184e/posts/list/3407.page Thầy trả lời đúng rồi đó bạn, k có j mâu thuẫn đâu. Tại vì giai đoạn này chỉ kiểm tra cú pháp thôi (tức là mặt chữ đó), còn những cái liên quan đến ngữ nghĩa, tầm vực, kiểu thì k quan tâm. Còn trong file PT thầy thêm trường hợp list null cho ArrayLiteral và EleExpr là để tránh xảy ra exception trong quá trình chạy test (giả sử quá trình test bài của bạn bị exception thì sẽ bị exit => k test tiếp cho bạn những test sau) ^^. Trường hợp array const thì đề đã ghi rõ là ''An array constant is a semicolon-separated list of elements enclosed in left and right square brackets. The list may NOT be empty '' , còn trường hợp element thì mình nghĩ cũng tương tự. Có j sai mọi người chỉ bảo. ^^ Phần trước thì mình đồng ý với bạn, còn phần để tránh xảy ra exception thì chắc là không có đâu.Testcase cho stage 2 @vanhoa: test nào có lỗi đều có hết đó bạn, ví dụ test 14 hay 15. còn cái - 1 ngôi là bnot, 2 ngôi mới là sub.Testcase cho stage 2 line 1:17: unexpected token: ; và line 1:22: unexpected token: :TO DO trong Utils.scala Đề yêu cầu chỉ nộp file StaticChecker.scala, nhưng trong file Utils.scala lại có mấy dòng //TO DO... Vậy mấy dòng này chỉ để chơi vậy thôi chứ tụi em đâu cần làm gì phải không thầy?chỉnh sửa program trong code mẫu Đúng mà, đâu cần sửa gì đâu.chỉnh sửa program trong code mẫu Code mẫu đã chạy được input mẫu mà, vậy có khi bạn sửa đâu đó rồi.not Lúc đầu mình cũng làm bnot cho - 1 ngôi, nhưng sau có bạn nhắc là hàm sub thầy có xử lí cho 1 ngôi => dùng hàm sub.Re:Hỏi về phần leftHandSide trong đặc tả Em yêu Scala ♥♥♥ wrote: À mình đã hiểu. Đọc đề ko kĩ :d. Thanks bạn nha. Như vậy thì a := [2;3;4+1]; thì ko đc đúng ko? Parse không được :DHỏi về 12 hàm built-in ở cuối đặc tả Giờ chưa cần đụng tới mà.Re:wholeNumber Hình như không có wholeNumber đâu em. Dùng intLiteral đi.Re:hỏi ý nghĩa về các hàm cho sẵn AddExprPT // cộng SubExprPT // trừ TimesExprPT // nhân RdivExprPT // chia thực "/" IdivExprPT // chia nguyên "div" ImodExprPT // mod NeExprPT // <> EqlExprPT // = GeExprPT // >= GreaterExprPT // > LeExprPT // <= LessExprPT // < BorExprPT // or BandExprPT // and BnotExprPT // not hoặc - ExponentExprPT // ^ FuncCallExprPT // gọi hàm ConsPT // trị hằng số LefHandSidePT // left hand side VarExprPT //biến EleExprPT //truy cập mảngRe:Thắc mắc về các toán tử Theo mình thì: 1. Trong Parser này thì chấp nhận bình thường. 2. Khi nào có đủ 2 toán hạng thì - là 2 ngôi, còn không thì là 1 ngôi. VD: 1 - 2 //2 ngôi 1 - - 2 //- trước là 2 ngôi, - sau là 1 ngôitrường hợp này có đc nhận hay k Không nhận đâu! . . . . . Vì x := mới nhận :)) Theo đặc tả<id>[<expr>,…,<expr>], mà 1+2 là expr nên nhận thoải mái!Token? Có đó cưng. Xem dòng cuối cùng trong đặc tả ass1: line 5:4: unexpected token: "token EOF hay <eof> Thì bạn làm sao cho nó trả về <eof> là được.Const Array này nhận được ko vậy mọi người kiểm tra kiểu là kiểm tra ngữ nghĩa rồi, thuộc về ass2.Const Array này nhận được ko vậy mọi người nhan nguyen van wrote: Just A Tee wrote: Vậy [1;false;3.5] với [[2; 4];3;true] parse thành công không mọi người? mình nghỉ [1;false;3.5] không được, cái này mình có thể kiểm tra token được mà: a[ ListInteger token | Listboolean token ... ] => cac phan tu tron array phai cung kieu thi co the kiem tra duoc. chi co truong hop a [ [2;3] ; [ true ;false]] la khong kiem tra duoc thoi... vi 2 phan tu trong mang a deu la mang ca => chap nhan, con kiem tra kieu tiep nua thi ko duoc. (ass2) Em có thể check kiểu đó, tuy nhiên parse vẫn thành công đơn giản vì nó đúng cú pháp.Một số câu hỏi về array Các thầy cho em hỏi 1 chút về array: 1. Truy cập mảng nhiều chiều như thế nào? VD: a[1][1] := 1; hay: a[1,1] := 1; 2. Mảng rỗng có báo lỗi ở phần Parser này không? Báo như thế nào? VD:var z: array [] of integer; thì ra: [var(z,arr([],int))] hay:line 1:15: unexpected token: `]'Re:Một số câu hỏi về array [var(x,int),var(y,int),var(z,int)] Trong đặc tả có nói rồi đấy.Một số câu hỏi về array Đâu có cần phân biệt input làm gì đâu bạn.1.1 mod 1.2 Ý bạn hỏi là gì? Nếu hỏi nó có phải là expression không thì đúng. Còn là chương trình parse được thì không.1.1 mod 1.2 be be wrote: vậy bạn cho mình hỏi thêm, thí dụ a:= 1 mod fun(1); mình có cần phải kiểm tra kiểu của fun(1) ko? Có, nhưng trong ass 2 :Dmột trường hợp về hằng chuỗi Guest User wrote: const x='''; line 1:11: unexpected token: ' Guest User wrote: const x=''''''''; [const(x,''')]một trường hợp về hằng chuỗi Just A Tee wrote: const a = ''; // 2 dấu nháy đơn thì ra cái gì mọi người [const(c,)]Re:Một số câu hỏi về array walk alone wrote: cho em hỏi: khi khai báo constan  là array, thì các phần tử trong array mình có phải kiểm tra nó có tương đồng nhau không hả anh?? Kiểm tra kiểu trong ass2 lận.1.1 mod 1.2 vì nó không phải là chương trình, có chương trình nào chỉ cụt ngủn vậy đâu!Re:Một số câu hỏi về array Scala ^^  wrote: cho mình hỏi const a=[]; thì output là: [const(a,[])] phải k mấy bạn? hay la báo lỗi line 1:10: unexpected token: ] [const(a,[])]Re:Một số câu hỏi về array T.D.N  wrote: Long Potter wrote: Scala ^^  wrote: cho mình hỏi const a=[]; thì output là: [const(a,[])] phải k mấy bạn? hay la báo lỗi line 1:10: unexpected token: ] [const(a,[])] Array constant đâu có dc rỗng Cái này cũng không chắc lắm nhưng code xử lí được thì cho xử lí luôn.Một số câu hỏi về array Just A Tee wrote: Cho mình hỏi luôn: a := b[2, 3, [3]]; c := d[3, [4;5], 2]; e := f[5, [], 2]; ra kết quả ntn vậy mọi người? [proc(a,[],[assign(a,ele(b,[2,3,[3]])),assign(c,ele(d,[3,[4;5],2])),assign(e,ele(f,[5,[],2]))])] Test với procedure a()1 số thắc mắc  T.D.N  wrote: Vậy là xuất ra lỗi thì xuất EOF hay vậy mọi người <eof>, theo file đặc tả ass 1.String Literal Mình nghĩ là mọi người không nên dựa vào code của thầy quá. Đoạn này tự xử lí được mà.Re:String Literal Thanh Pham Minh wrote: Trường hợp 3: Input: const c = ''; Output: ??? [const(c,)]Re:Testcase ' không phải là token nên phải ra ErrorToken ' chứ nhỉ.