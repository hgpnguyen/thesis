Return String, Array Thấy cho em hỏi. Trong đặc tả có đoạn như thế này: For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . For an assignment statement, the LHS can be in real, integer or boolean type . The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. In Crazy, just the integer can coerce to the real. Vậy nếu xem kiểu trả về như là một LHS thì kiểu trả về chỉ có thể là real, integer hoặc boolean. Không được trả về kiểu string hay array đúng không ạ? For a call statement, the callee must be in procedure type and the number of arguments must be equal to that of callee parameters. In addition, for parameter passing, the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS. Tương tự, parameter có thể là kiểu string không?Re:Scope của biến global??? procedure demo(); begin y := true; var y: integer; y := 0; end; var y : boolean; => None Test case này test tầm vực nè, ra None là okRe:Scope của biến global??? var x :real; function demo(a: real): real; begin return 0; end; procedure main(); begin var demo: real; x := demo(demo); end; Cái này sao mấy bác?? biến demo có che hàm demo không? Nếu không che thì có thể gọi demo(demo) Function demo( biến demo) ko?Re:Scope của biến global??? Most closed nested rule: For every applied occurrence (i.e., use) of an identifier I in a block A, there must be a corresponding declaration of I. The declaration is in a block that is smallest enclosing the applied occurrence of I. Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block. = Tầm vực của một định nghĩa không bao gồm tầm vực của định nghĩa khác cùng tên bên trong một block. Ví dụ: function demo():real; begin return 0; end; procedure main(); begin var demo: real; => Chổ này không thấy hàm demo nữa. end;Re:Thi cuối kỳ Vote cho đề đóngLab4 Bai 1:cho minh hoi Trong ubuntu Ctrl + z thi khong co hien tuong gi xay ra het, minh hoi mot so nguoi dung windows thi ok. Vay la sao nhi?Re:Lab4 nguyen dung wrote: Nếu nó không dùng Ctrl+Z được thì bạn đọc từ file, chữa cháy cũng được đó, new Input...(new FileInput... (new File("path")) Thanks ban... chay OKRe:định nghĩa path of the execution of the function? Vậy chương trình sau có bao nhiểu đường thực thi. var a: boolean; function func(): real; begin if a then return 1; end;Re:định nghĩa path of the execution of the function? Vậy nếu trong chương trình có một câu lệnh return ở ngoài thì trong if else, while , loop không cần xét nữa đúng ko? Vì đường thực thi luôn đi qua câu lệnh return này Ví du 1: var a: boolean; function main():real; begin if a then a := true; return 0; end; Ví du 2: var a: boolean; function main():real; begin return 0; if a then a := true; end; 2 trường hợp trên có báo lỗi khôngRe:Testcase cho stage 2 procedure main(); begin a := [1;true]; end; vậy nếu có testcase như vậy thì kết quả là gì? line 3:10: unexpected token: true hay[proc(main,[],[assign(a,[1;true])])]Re:Biểu thức hằng?? Const array có tính không? Nếu tính thì chỉ số của Array được đánh bắt đầu là 0 hay là 1 ? function main(): real; begin const a = [1;2;3]; const b = [[1;0];[4;3]]; var c : real; if(a[1] <> b [1,1]) then c:= 0; return 0; end; Nếu đánh là 1 thì ra thế này a[1] = 1 b[1,1] = 1 =>if(a[1] <> b [1,1]) then c:= 0;   =if(false) then c:= 0; => None Còn đánh là 0 thì a[1] = 2 b[1,1] = 3 Function Not Return: mainTestcase vanhoa  wrote: Vẫn None bạn. đâu có đúng đâu? Ngoài câu lện if else, while, loop, block thì các câu lệnh còn lại vẫn phải tính là 1 đường thực thi chứ. vidu: function main(): real; begin var a: real; end; với function main(): real; begin if false return 0; var a: real; end; thì sao?Re:Testcase Test case Vui procedure demo(); begin y := true; var y: integer; y := 0; end; var y : boolean; => NoneRe:Testcase var x :real; function demo(a: real): real; begin return 0; end; procedure main(); begin var demo: real; x := demo(demo); end; Ra gi cac bac?Re:Testcase function main():string; begin return 'a'; end; Ra gi ?Re:Testcase Test này: Test #7 Program proceduremain(); begin constv=0; v:=0; end; INPUT [proc(main,[],[const(v,0),assign(v,0)])] OUTPUT Cannot Assign To Constant: v Hình như chưa đúng: Ouput là " Cannot Assign To Constant: <satement>" chứ đâu có phải là Cannot Assign To Constant: <identifier> đâu Hòa?Re:Testcase procedure main(); begin const a = [1;2;3]; a := [1;3;4]; end; Test thu.Testcase vanhoa  wrote: Cannot Assign To Constant Văn Hòa có sửa lại PT đúng không? Theo mặc định thì Parser xuất ra constant array ở dạng  [1;2;3] nhưng ass 2 yêu cầu dạng array([1,2,3])Re:Testcase function readInt(d: real): real; begin var d : real; return 0; end; => Redeclared Variable: d hayRedeclared Function: readInt? Phải kiểm tra hàm trước rồi mới kiểm tra biến chứ nhỉ?Re:Testcase Testcase 1: function func(): integer; begin var a : integer; if true then a := 0; return 0; end; Testcase 2: function func(): integer; begin while true do begin end return 0; end; Trường hợp function not return Kết quả là gì mọi người?Re:Testcase Hòa coi lại Test #13 nha Type Mismatch In Statement: <statement> is released. The type rules for statements are as follows: - The type of a conditional expression in an if, or while statement must be boolean. - The type of the expression in a loop statement must be integer. - For an assignment statement, the LHS can be in real, integer or boolean type. The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. In Crazy, just the integer can coerce to the real. Cái này thì chỉ có thể là Variable real, integer hoặc boolean thôi. test 13 gán cho function thì báo lỗi Type Mismatch In Statement: assign(f,add(add(sub(a),times(b,d)),call(f,[1]))) Ko cần check vế phải nữa.Re:Testcase Test 15: proceduretest(a:string);begin end; proceduremain();begin test(1); end; Output phải là chứ Type Mismatch In Statement: call(test,[1]) test(1); là câu lệnh màRe:Testcase Test 35 functionmain():real; begin while1=1do return1; loop1do return1; if1=1thenreturn1; end; => None vay bay gio them 1 dong lenh vao functionmain():real; begin while1=1do return1; loop1do return1; if1=1thenreturn1; var a: real; end; => Ket qua la : "Function Not Return: main" hay la None?câu lệnh Return  Thấy cho em hỏi. Trong đặc tả có đoạn như thế này: For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type . For an assignment statement, the LHS can be in real, integer or boolean type . The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. In Crazy, just the integer can coerce to the real. Vậy nếu xem kiểu trả về như là một LHS thì kiểu trả về chỉ có thể là real, integer hoặc boolean. Không được trả về kiểu string hay array đúng không ạ? For a call statement, the callee must be in procedure type and the number of arguments must be equal to that of callee parameters. In addition, for parameter passing, the rule for an assignment is applied to parameter passing where a parameter is considered as the LHS and the corresponding argument is the RHS. Tương tự, parameter có thể là kiểu string không?Re:file PT.scala Tình hình là thầy chưa up đâu, hỏi quá trời mà thấy chưa trả lời, bạn chỉ cần fix lại PT.scala của Ass1 một chút là okFunction Not Return Thưa thầy cho em hỏi: function test() : integer; begin var a : integer; if true then a := 0; return 0; end Vậy có báo lỗi "Function Not Return: test" không? Trong đặc tả có đoạn :In each path of the execution of the function, there is at least a return statement, otherwise, the error message. Nhưng chương trình trên chắc chắn chạy câu lện return cuối cùng?Re:Function Not Return Thanh Pham Minh wrote: H.T.P (^_^)  wrote: Cho hỏi ngoài lề 1 tí. nếu trong Proceduce có lệnh return thì sử lý làm sao? * For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type. * The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. Procedure có return type là gì nhỉ :p Nên mình nghĩ sẽ xuất lỗi Type Mismatch In Statement:. Type Mismatch In Statement: Có nghĩa là câu lệnh này bị sai kiểu, còn return trong procedure là sai câu lệnh, nếu có kiểm tra thì parser phải kiểm tra chứ, theo mình nghỉ là StaticChecker không kiểm tra cái này.Re:Function Not Return Vậy như thế nào là một đường thực thi? function main():real; begin var a: real; end; trong begin...end; có tính là 1 đường ko? Nếu có => yêu cầu phải có return => Ví dụ: function foo(a: integer): integer; begin if (a > 0) then return 0; else return 1; writeLn('this line never runs'); end cũng phải cần 1 câu lệnh return sau dòng WriteLnThầy cho em hỏi vê hàm Typeof  Trong hàm typeof có đoạn: case IntLit(_) => PrimitiveType("integer") case FloatLit(_) => PrimitiveType("real") case BoolLit(_) => PrimitiveType("boolean") khi gọi typeof cho một số nguyên (ví dụ là số 3) thì sẽ ra kiểu là : integer còn khi khai báo một biến kiểu nguyên thì do parser của Assignment 1 quy đinh thì sẽ có kiểu là : int => khi so kiểu sẽ không trùng. Vậy PT của Assignment 1 sẽ được sửa lại hay là em có thể sửa trong hàm typeof : case IntLit(_) => PrimitiveType("integer") thànhcase IntLit(_) => PrimitiveType("int")Lỗi array constant procedure main(); begin var c:array[0] of real; c := [1.2]; end; sử dụng array constant bất kỳ chổ nào đều bị báo lỗi: Exception in thread "main" scala.MatchError: [1.2] (of class ItemList) do class ItemList không hiểu [1.2]. Thầy cho em hỏi: Vậy trong chương trình có sử dụng array constant như trên không ạ?Token? '' có phải là một token không vậy mọi người ?Re:Const Array này nhận được ko vậy mọi người nguyen duc thien wrote: array kieu gi cung duoc ma Note that the elements of an array must be in the same type. For example [1;3;2] [3.2;.2E-2] [[1;2];[3;4]] [] [[1;2];3;4] [1;2;true] Các phần tử trong mảng phải cùng kiểu chứ... Vậy [[1;2]; [1]],  [[true;false]; [1;2]] được không vây?Const Array này nhận được ko vậy mọi người Just A Tee wrote: Vậy [1;false;3.5] với [[2; 4];3;true] parse thành công không mọi người? mình nghỉ [1;false;3.5] không được, cái này mình có thể kiểm tra token được mà: a[ ListInteger token | Listboolean token ... ] => cac phan tu tron array phai cung kieu thi co the kiem tra duoc. chi co truong hop a [ [2;3] ; [ true ;false]] la khong kiem tra duoc thoi... vi 2 phan tu trong mang a deu la mang ca => chap nhan, con kiem tra kieu tiep nua thi ko duoc. (ass2)Test case la: const a = ''''''; // 6 dau ' const a = '"'  // dau ' , dau '' , dau ' May ban chay thu ra ket qua j? hinh nhu ham thay viet co van de.Test case la: Nhat Nguyen wrote: line 2:44: unexpected token: const a = ''''''; chi co cai do thoi... sau dau // la minh viet chu thich cho ba thoiRe:Test case la: Nguyễn Thanh Linh wrote: với input của @Nhan , ra như trên . Còn với input là const a = ''''''; // 6 dau ' const a = '"' ; // dau ' , dau '' , dau ' của tui đây : [const(a,'),const(a,")] vay la sai roi do ban. ham cua thay la: neu co hai dau ' thi bo di mot dau, co dau '' thi nhan doi thanh ''''; ban thu chay 2 cai nay lai coi const a = '''a'''; const a = 'a"';Re:String Literal Nguyễn Thanh Linh wrote: Code mẫu cho thấy : khi 1 token là StringLit rồi thì xử lí là : - các dấu nháy đơn liên tiếp nhau được cắt giảm thành 1 dấu nháy đơn. - các dấu nháy kép đều được nhân đôi, trừ dấu nháy kép ở vị trí đầu string (nếu có ) thì giữ nguyên không nhân đôi. Theo mình đây là cách xử lí có chủ ý của anh ấy. các output đều ra theo quy luật này. sao lai ''trừ dấu nháy kép ở vị trí đầu string (nếu có ) thì giữ nguyên không nhân đôi.'' vay? co the la do thay viet sai cho nay.