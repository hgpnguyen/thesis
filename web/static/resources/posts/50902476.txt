Mong anh Hùng phổ biến rõ hơn về vấn đề Function Not Return Ngôn ngữ Crazy có tính kiểu short-circuit không thầy? Với x là biến thì biểu thức (true or x) được xem là true luôn hay vẫn phải xét tiếp x?Re:File PT vẫn chưa tương thích Các bạn thử lấy file PT mới test cái này (của "nhan" bên topic kia): function main():string; begin return 'a'; end; sẽ được cây sinh ra: Program(List(Func(main,List(),PrimitiveType(string),Block(List(Return( UnaryOp (string,StringLit("'a'")) )))))) =))Scope của biến global??? H.T.P (^_^)  wrote: các bạn cho mình hỏi biến global có tầm vực như thế nào? Tương tự, 1 hàm cóđược sử dụng dụng phía trướcđịnh nghĩa hàmđó không? - The scope of a global variable: the entire program => Biến global có tầm vực toàn chương trình :) - The scope of a function/procedure: the entire program. Một hàm dùng được trong tầm vực (scope) của nó => ... - Có xét thêm: the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block.Scope của biến global??? @H.T.P (^_^): hai ví dụ của bạn mình chưa chạy thử được nhưng xét về scope của biến và hàm thôi thì đều không có lỗi. Giải thích thì như bạn chicken _ đã nói: "1 hàm được dùng trong scope của nó. Chứ không có nói là phải khai báo trươc hay ko." Rõ hơn là không cần phải khai báo trước theo thứ tự từ trên xuống trong file source. @tran ngoc duc: bạn có thể giữ nguyên code mẫu, hoặc chỉnh sửa code mẫu miễn là thỏa được đặc tả.Re:Scope của biến global??? chicken _ wrote: Tóm lại là báo lỗi hay không. Mỗi người một ý vây. * Báo lỗi: Đã làm được. * Không báo lỗi: Sẽ phải sửa lại nhiều. Cái này còn liên quan tới nhiều vấn đề khác nữa => Sửa lại hàm tìm kiếm. Không báo lỗi ;))Re:GradeBook Mid Term Tân Trần Vĩnh wrote: Và như thông báo mới, chúng tôi sẽ chấm chặt tay, trước mặt các em, với những bài được thắc mắc. Mong thầy công bố chi tiết cách tính điểm. Ví dụ: trong một câu sai ý này, đúng ý kia thì được bao nhiêu; đúng nhưng chưa đủ thì được bao nhiêu; chữ xấu có trừ điểm không; một câu đúng ý nhưng trình bày khó hiểu thì thế nào;... Như vậy sinh viên dễ dàng hơn để xác định bài của mình có bị nhầm lẫn gì khi chấm không. Đây là bài thi tự luận nên ít nhiều sẽ có yếu tố chủ quan của người chấm (có năm người chấm) và khả năng diễn đạt của người làm. Theo em, nếu quyết định chấm gắt hơn ở những bài xin chấm lại thì cũng nên có bonus cho những bài xin chấm lại mà chính xác.Re:Các bạn cho mình hỏi về cái def Show tý nhé ! Với trong đề yêu cầu xuất line<blank><line>:<column>:<blank>unexpected token:<blank> <token> nhưng trong ví dụ lại có trường hợp xuất <eof> mà <eof> đâu phải token. Trong Stage 1 đã làm, EOF mới là token!Danh sách cấm thi và quy định 5 con 0. Em nhớ có lần thầy cho làm bài trong giờ lý thuyết và có nói thêm là để thầy xem các em tiếp thu được đến đâu để điều chỉnh việc giảng dạy cho phù hợp. Lần đó em lên bảng làm nên lúc xuống không nộp lại giấy (không kịp làm vô giấy). Thầy cho em hỏi em có bị tính là vắng buổi đó không ạ? Mã số sinh viên của em là 50902476. Em cảm ơn ạ.Điểm Course_Grade Mình tưởng điểm trong course_grade là đã làm tròn 0.5 rồi. Thầy kiểm tra giúp em với. Em tự tính được 9.1 (9.125) nhưng trong course_grade chỉ ghi 9. Nếu đó là điểm đã làm tròn 0.5 thì sao điểm của bạn Việt lại là 7.2 mà không phải là 7.0 hoặc 7.5 ạ? Tên: Phạm Minh Thành MSSV: 50902476File kết quả Assignment 2 Thưa thầy, Trong Gradebook đã có điểm Assignment 2 nhưng trong mục Assignment vẫn chưa có file chấm bài. Mong thầy upload file chấm bài Assignment 2 trước khi nộp điểm tới phòng đào tạo. Em cảm ơn.File kết quả Assignment 2 Thầy cho em hỏi bài của em được bao nhiêu test bắt buộc và bao nhiêu test bonus ạ? Em cảm ơn! Tên: Phạm Minh Thành MSSV: 50902476Re:tut1 Tương tự cho mình hỏi, câu 5.a: (ab)*(ba)*|aa* thì nghĩa là ((ab)*(ba)*) | aa* hay (ab)* ((ba)*|aa*)Re:tut1 Nhat Nguyen wrote: Thanh Pham Minh wrote: Tương tự cho mình hỏi, câu 5.a: (ab)*(ba)*|aa* thì nghĩa là ((ab)*(ba)*) | aa* hay (ab)* ((ba)*|aa*) theo mình nghĩ nó là (ab)*((ba)*|a)a* Oh, cảm ơn bạn nhiều nhé. Mấy khoảng trắng dễ gây nhầm lẫn quá!tut1 Bài giảng không nói gì về thứ tự ưu tiên cả. Giả sử thứ tự ưu tiên là Kleene Star>Union>Concatenation thì rõ ràng cách hiểu của bạn Nhat Nguyen (ab)*((ba)*|a)a* là chính xác. Còn nếu Kleene Star>Concatenation>Union thì kết quả là ((ab)*(ba)*)|(aa*). Nhưng thứ tự ưu tiên này có vẻ không hợp lý như thứ tự ở trên.Re:Lab 2 Ngan Tuyet wrote: Đúng rùi đó. Hình như cái solution câu 1a của thầy có j nhầm lẫn. Mong thầy giải đáp Mình thì làm thế này :"(/\\*([^\\*]|(\\*)+[^/])*\\**\\*/)" Cách của bạn có xót một trường hợp: val comment1 = new Regex("(/\\*([^\\*]|(\\*)+[^/])*\\**\\*/)") comment1.findAllIn(" /**** * 1st comment. ****/ code1(); /* * 2nd comment */ code2(); ").toList Kết quả: List[String] = List(/**** * 1st comment. ****/ code1(); /* * 2nd comment */) Lẽ ra kết quả phải là: List[String] = List(/**** * 1st comment. ****/, /* * 2nd comment */) Mình nghĩ đáp án này chính xác hơn :) val comment = new Regex("""/\*([^*]|(\*+[^*/]))*\*+/""")Ý kiến về câu 2 kì thi giữa kì... Rec4rx  wrote: Thưa thầy, em có chút ý kiến về câu số 2 đề thì giữa kì như sau. Theo em được biết thì, một văn phạm được coi là nhập nhằng khi tồn tại một phát biểu mà theo phát biểu đó tồn tại hai hoặc nhiều hơn hai cây cú pháp. Vậy điều kiện đầu tiên để một văn phạm có thể coi là nhập nhằng phải là "tồn tại một phát biểu"... Nhưng theo như văn phạm trong câu 2 đề thi, thì rõ ràng chẳng tồn tại một phát biểu nào cho văn phạm đó hết, vậy nên việc chứng minh văn phạm đó nhập nhằng là không thể.. Ý kiến của em là vậy, mong thầy góp ý nếu em hiểu sai gì đó. Cám ơn thầy. Đồng ý với ý kiến của bạn :D Đề thi nên rõ ràng, chặt chẽ chứ không nên có những chỗ "tự hiểu là phải bỏ qua".Tut 3 Thưa thầy, Question 4, Tut 3 yêu cầu chuyển đổi giữa số thập phân và chuỗi nhị phân theo chuẩn IEEE 754. Tuy nhiên em không tìm thấy tài liệu nào về biểu diễn số với 9 bits theo chuẩn trên cả. Mong thầy nói rõ hơn: Với một số 1.abc * 2^d Phần exponent 3 bit lưu d hay d+bias. Nếu là d+bias thì bias là 3 phải không ạ? Phần value 5 bit cuối lưu value hay fraction: 1.abc hay là abc? Em cảm ơn.Re:Tut 3 Cảm ơn bạn Long Hoang Ngoc . Ý mình là tài liệu nói về chuẩn IEEE 754 với 9 bits . Có hai khả năng: Một là IEEE 754 chỉ quy định các dạng: binary16, binary32, binary64, binary128, decimal32, decimal64, decimal128. Nếu vậy không có chuẩn 9bits ở đây. Hai là IEEE 754 quy định luật chung và từ đó chỉ rõ phương pháp tính ra cách biểu diễn được cho mọi số lượng bit cần thiết. Nếu vậy tại sao những tài liệu (mình tìm được và cả của bạn) không nói về cách tính đó? Tại sao bias bằng 3 :) Mình không thấy có tài liệu nào nói bias = 2^ExponentBitsCount-1 -1. Mình thì đoán mò dựa trên hai dạng chuẩn binary32, binary64. Thậm chí chuẩn còn quy định số bit dành cho phần exponent là [4*log2(k)]-13. Nếu thay k = 9 thì exponent bằng 3? Chính vì không tìm thấy tài liệu nên mình nghi ngờ về bias và chữ "value" (chiếm 5 bits cuối). Nếu đã theo chuẩn thì phải triệt để, nếu không, phải đặc tả rõ!Re:Testcase cho stage 2 // hỏi nhầm, đã xóaRe:Testcase cho stage 2 Nếu đọc kỹ đặc tả sẽ thấy arrayLiteral chỉ yêu cầu là có các phần tử của chính nó cùng kiểu (integer, real, boolean hoặc array) chứ không yêu cầu xét một cách đệ quy . Nghĩa là: const b = [true;false];[1;2;3];[1;2;3;4];[[1];[2; 3]]]; sẽ parse thành công vì đối với array mẹ (array ngoài cùng) các phần tử của chính nó có cùng kiểu array (array luôn là array không cần phân biệt số chiều, kiểu, mức độ lồng nhau ). Tương tự, array con thứ nhất, thứ hai, thứ ba lần lượt có các phần tử cùng kiểu boolean, integer, integer. array con thứ tư có các phần tử là các array. Nhưng: const c = [1;2;[3;4]]; sẽ không parse thành công vì có phần tử thứ nhất và thứ hai kiểu integer nhưng phần tử thứ ba có kiểu array. Tương tự: const d = [true;1]; cũng không parse thành công. Có gì sai thầy và các bạn sửa giúpRe:Testcase cho stage 2 Ờ, thank ông đã nhắc. Nhưng nếu muốn kiểm tra ở mức độ tui đã nói thì cũng làm được mà :) Chưa có thống nhất! Phần arrayLiteral thì nói phần tử của mảng có thể là array, không thể là string. Nhưng phần arrayType thì ngược lại: không thể declare một array có phần tử là array vì sau "of" chỉ có thể là primitive type. Primitive type có bao gồm string nên trong phần này array có thể có kiểu phần tử là string. Dù sao đây cũng là Crazy Language nên.. thôi :))Re:Testcase cho stage 2 @Scala ^^: rep1sepRe:Testcase @chicken _: Test này bạn ra gì: const b = [[[1.0; 2.0]]; [[1; 2]]];Re:Testcase Thêm một test về Not Defined Before Used :) var u: integer; var v: integer; procedure main(); begin var x, y: integer; while (u > 0) do begin var u: integer; while ( 1 > 0) do begin u:= 1; y:= 2; if ( 0 > 1 ) then continue; x:= 1; y:= x; v:= 2; end // x:= y; y:= x; end u:= u; v:= v; end; Output: //noneRe:Testcase @vanhoa: mình post test này lên cũng là muốn thắc mắc chỗ đó. Luật 4 phần i không nhắc đến expr trước do phải chắc chắn đúng (hoặc > 0), thậm chí không loại trừ cả trường hợp expr đó chắc chắn sai. Nếu xét expr thì lại không thống nhất với luật 3. Luật 3 lại luôn yêu cầu biến phải được gán trong "...both branches..." . Thấy kiểu nào thỏa đặc tả cũng không được hợp lý, mà kiểu hợp lý thì không còn đúng với đặc tả! Edit: trong notice thầy có bổ sung ý rồi. Kết hợp đặc tả với Notice thì không còn bất hợp lý nữa =)) Sửa lại test phía trên luôn cho hợp :DRe:Testcase Test này các bạn ra None hay Type Mismatch In Expression: array([array([array([1.0,2.0])]),array([array([1,2])])]) function foo(param: array[2,1,2] of real): integer; begin return 0; end; procedure main(); begin var a: real; a:= foo([[[1.0; 2.0]]; [[1; 2]]]); end; Test này ra None hay Type Mismatch In Expression: ele(a,[1000]) procedure main(); begin var a: array[2] of integer; a[1000]:= 1000; end;Re:Tổng hợp các câu hỏi? Câu 3: lệnh gán sau return có tính không. (case h) Câu này nếu xét kỹ sẽ thấy nó không phải vấn đề. Lệnh return đặc biệt hơn lệnh break ở chỗ: sau break sẽ tiếp tục các lệnh ngoài loop, còn sau return sẽ thoat ra hẳn function. :)Re:Tổng hợp các câu hỏi? _Tieu_ Doan_Du wrote: Đó là tư duy thông thường, nếu thế thì chả cần phải nói khái niệm biến phải được gán trước break làm gì, vì theo lẽ thường thì sau break có thực thi đâu. OK, mình sẽ nói kỹ hơn một xíu. Tạm thời chúng ta có 3 lệnh cần quan tâm: lệnh return, lệnh gán, lệnh sử dụng (biến). Giờ xem như chưa có lệnh return: trong function chỉ có lệnh gán và lệnh sử dụng. Chúng ta sẽ đưa lệnh return vào sau để thấy được sự logic thông thường. Trường hợp 1: không thể chắc chắn lệnh gán xảy ra, lúc này ở lệnh sử dụng sẽ bị lỗi Not Defined Before Use. Giờ dù ta có đưa return vào chỗ nào đi nữa cũng không thay đổi được vấn đề (lệnh gán vẫn không thể chắc chắn xảy ra hay không => ở lệnh sử dụng vẫn lỗi). Trường hợp 2: lệnh gán chắc chắn xảy ra, lúc này ở lệnh sử dụng không có lỗi. 2a) Giờ nếu ta đưa return vào sau cả hai lệnh trên thì vẫn không có lỗi. 2b) Nếu ta đưa return vào giữa 2 lệnh trên. Chia ra: i) Nếu return xảy ra => lệnh sử dụng (nằm sau lệnh return) không thể xảy ra => không thể có lỗi (vẫn giống lúc không có return). ii)) Nếu return không xảy ra: trước lệnh sử dụng vẫn chắc chắn có lệnh gán (nếu không chắc chắn có lệnh gán thì rơi vào trường hợp 1 rồi nhé) => vẫn không thể có lỗi. iii) Return không chắc có xảy ra không: dù thế nào cũng là 1 trong 2 cái (i, ii) đã nói ở trên. 2c) Nếu ta đưa lệnh return vào trước 2 lệnh trên. Chia ra: i) Nếu return xảy ra => lệnh sử dụng (nằm sau lệnh return) không thể  xảy ra => không thể có lỗi (vẫn giống lúc không có return). ii)) Nếu return không xảy ra: trước lệnh sử dụng vẫn chắc chắn có lệnh  gán (nếu không chắc chắn có lệnh gán thì rơi vào trường hợp 1 rồi nhé)  => vẫn không thể có lỗi. iii) Return không chắc có xảy ra không: dù thế nào cũng là 1 trong 2 cái (i, ii) đã nói ở trên. Ok, rất là dài dòng, nhưng nếu bạn suy nghĩ được một cách thông thường thì không khó hiểu lắm đâu. Giờ đơn giản nhất là bạn hãy lấy một ví dụ để thấy rằng khi có và không có return thì kết quả (lỗi hay không lỗi Not Define...) thay đổi (theo ý mà bạn đầu topic đã nói). Nếu tìm được, tức là mình sai (& vice versa). Edit: à, mình hiểu rồi, thực ra bạn nhầm ở chỗ này. Sau break các lệnh nằm ngoài loop (vẫn trong function) CÓ thực thi bạn nhé => biến local của function vẫn còn. Còn sau return thì thoát khỏi function mất rồi, biến global thì mặc định được coi là đã define (theo đặc tả).Re:Tổng hợp các câu hỏi? Vo Thanh Hung wrote: Câu hỏi: Case h: assign sau break và continue ko tính. Thế sau return có tính ko? Trả lời: assign sau break và continue sẽ không tính, tương tự sau return. Tuy nhiên, các dòng lệnh sau các phần này vẫn sẽ kiểm tra như bình thường (dù assign thì không tính) Em không đồng ý ở điểm này. Nếu assign sau return không tính thì nó đã mâu thuẫn với luật tổng quát hơn và hiển nhiên đúng là: khi dùng một biến, nếu chắc chắn biến đó đã được gán thì không báo Not Defined Before Used nữa. Lấy ví dụ sau: if (true) then begin if (x) then return 0; //(1) a:= 5; //(2) end a:= a;   //(3) Áp dụng luật: "An local variable must be initialized (by an assignment) before used ". Để cho a được use thì execution path phải đi qua (3), mà đã tới được (3) thì khi đó nó chắc chắn execution path đã đi qua (2). Nếu execution path không đi qua (2) thì chắc chắn nó đã đi qua (1). Và như vậy (3) không xảy ra, nghĩa là a đã không được use, mà không use thì không thể nói Not Defined Before Used. Đây có vẻ (chỉ là có vẻ) là kiểm tra ở mức run-time nhưng thực sự thì ở mức static check hoàn toàn có thể (một cách logic) kiểm tra được việc này rồi. //Eclipse:Tổng hợp các câu hỏi? đừng phức tạp hóa vấnđề nữa Thànhơi. Thầyđã nói cái phầnđó thuộc checkunreachable code. Mình không cần làm rồi mà. :)Testcase cuối cùng. Input: procedure theLastTest(henxui: boolean); begin 'full_string expected but but_only_part_found // /* found */'; end; Output: line 3:1: unexpected token: 'full_string expected but but_only_part_found // /* found */'Testcase cuối cùng. Test này không thuộc trọng tâm của bài tập nên cũng có thể thầy sẽ không test. :DRe:Testcase cuối cùng. Phan Nguyen wrote: Trong thời điểm hiện tại, đừng ai chơi dại bấm nút resubmit thêm cái nữa, nếu không thì ...( tự biết hậu quả đê), mà nếu lõ tay kiểu đó thì bị trự bi nhiêu vậy các bác? Đúng 4:00:00pm mình kiểm tra thì đã khóa submit rồi mà bạn. Hay bạn load trang đó trước rồi đến sau deadline mới bấm submit?Re:Thứ tự kiểm tra Cannot Assign To Constant: Assign(Id(a),Id(b)) đâu nhé, cẩn thận đó bạn :DRe:Thứ tự kiểm tra mình check 1 cách tuần tự trên xuống dưới à. nếu 1 dòng có 2 lỗi thì báo lỗi nào.như VD này: var x:boolean; procedure proc(y:integer;j:integer); begin var a:integer; x:=a-true; end; Type Mismatch In Expression: sub(a,true) hay Not Defined Before Used: aRe:Thứ tự kiểm tra H.T.P (^_^)  wrote: Vậy câu " One program have maximum 1 semantic error, your program will be stopped after found first error." có nghĩa là 1 chương trình có thể có nhiều dòng có lỗi, nhưng tất cảđều cùng 1 loại (về ngữ nghĩa). Nên gặp dòngđầu tiên là báo lỗi ngay dòngđó vàexit. Mình hiểu vậy cóđúng chưa nhỉ? Tùy theo cách đếm "semantic error". Mình không chắc lắm nhưng mình nghĩ là có hơi thừa chữ "first". Nhưng nếu không thừa thì cách hiểu có bạn khá hợp lý :DRe:Thứ tự kiểm tra @H.T.P (^_^): One program have maximum 1 semantic error, your program will be stopped after found first error. Mình vẫn nghĩ rằng chỉ có một lỗi, chứ không phải nhiều lỗi mà cùng một loại. Hơn nữa "stopped after found first error" phụ thuộc vào cách mỗi người xử lý mà cái nào found trước found sau, khác với "stopped after the first error" chỉ phụ thuộc vào source code. Nên cũng theo mình nghĩ, sẽ không có hai ví dụ bạn đưa ra ở trên (trong bộ testcase của thầy).Function Not Return @nhan: Theo bạn ví dụ này thì sao :) function foo(a: integer): integer; begin if (a > 0) then return 0; else return 1; writeLn('this line never runs'); end và ví dụ này :D function bar(): integer; begin if true then return 0; else writeLn('this line never runs'); endRe:Function Not Return nguyen dung wrote: Theo như đặc tả thì chỉ cần return xuất hiện trong func là đủ, ngay cả khi nó không bao giờ chạy => test trên bt Có lẽ bạn hiểu sai đặc tả. Trong mỗi đường thực thi của một function, cần có ít nhất một lệnh return. Hai ví dụ mình đưa ra là để làm rõ thế nào là "đường thực thi" (execution path). Theo mình thì đường thực thi sẽ được xác định ở mức độ cấu trúc chương trình, chứ không phải ở mức độ chạy chương trình. Nghĩa là cho dù có một đường thực thi về mặt ngữ nghĩa/ logic không bao giờ được thực hiện, nó vẫn phải có ít nhất một lệnh return. Nên ví dụ thứ 2 cần có thêm một lệnh return cho đường thực thi đi qua nhánh else (return trong else; hoặc sau else và trước end) Ở ví dụ thứ nhất, cho dù xét ở mức cấu trúc chương trình, trên mỗi đường thực thi đều đã có một lệnh return, nên mình nghĩ sẽ không báo lỗi ở đây. Tuy nhiên mình chưa bắt đầu làm nên không chắc lắm vấn đề này.Re:Function Not Return H.T.P (^_^)  wrote: Cho hỏi ngoài lề 1 tí. nếu trong Proceduce có lệnh return thì sử lý làm sao? * For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type. * The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. Procedure có return type là gì nhỉ :p Nên mình nghĩ sẽ xuất lỗi Type Mismatch In Statement:.Re:Function Not Return nhan nguyen van wrote: Thanh Pham Minh wrote: H.T.P (^_^)  wrote: Cho hỏi ngoài lề 1 tí. nếu trong Proceduce có lệnh return thì sử lý làm sao? * For a return statement, the return expression can be considered as RHS of an implicit assignment whose LHS is the return type. * The right-hand side (RHS) is either in the same type as that of the LHS or in the type that can coerce to the LHS type. Procedure có return type là gì nhỉ :p Nên mình nghĩ sẽ xuất lỗi Type Mismatch In Statement:. Type Mismatch In Statement: Có nghĩa là câu lệnh này bị sai kiểu, còn return trong procedure là sai câu lệnh, nếu có kiểm tra thì parser phải kiểm tra chứ, theo mình nghỉ là StaticChecker không kiểm tra cái này. Bạn đã đọc kỹ đặc tả và hai dòng có dấu * mình trích dẫn chưa :)Re:Function Not Return //lăn chuột hơi mỏi tayRe:Function Not Return ass2  wrote: quá dài dòng! nhìn là không muốn đọc rồi Oh, xin lỗi bạn nhé, mình cũng không cố ý để bạn nhìn thấy ;))Re:Function Not Return H.T.P (^_^)  wrote: Còn trường hợp returnở trong vòngwhile mà nằm sau break; thì sao. đường thực thiđi quawhile cóđược tính là có return rồi hay ko?? 01. Nhưng bạn vẫn phải có return cho execution path không đi qua while. 02. Execution path đi qua while chứa execution path không đi qua while. => có hay không có return trong while không thay đổi được gì cả :)Function Not Return vanhoa  wrote: Có 2 loại while: 1. while chắc chắn được thực hiện (while có mệnh đề điều kiện luôn đúng): mình xem thân nó như một block bình thường. 2. while không chắc đúng hoặc while luôn sai: không cần xem xét. Tương tự cho loop. var a: integer; function foo(a: integer): integer; begin if (a >= 1) then a:= 0; while(a < 1) do return 0; a:= 1; end; procedure main(); begin var b: integer; a:= 100; b:= foo(a); end; Theo cách chia đó thì ví dụ trên thuộc loại 1 hay 2? Nếu thuộc loại 1 nghĩa là bạn đã chạy chương trình? Nếu thuộc loại 2 thì có nên chia giữa "chắc chắn" và "không chắc". Loại 2 đã một phần chứa loại 1 (tùy việc bạn hiện thực tới mức nào). Logic thì phải là "chắc chắn có" và "chắc chắn không" mới không bị overlap.Function Not Return vanhoa  wrote: Đây là static check :) Đó chính là cái mình muốn nói. Static check thì bạn không thể xét expression trong while có luôn đúng hay không.Function Not Return vanhoa  wrote: có chứ, vd while true. vậy đâu còn là s tatic check nữa :) cứ cho là "true" ok vì không phải eval gì cả, "1 > 0" thì sao :)Tên file cần nộp. Mong thầy xác nhận lại là tên file nộp có cần phân biệt chữ hoa, chữ thường không. Trong đặc tả và trên Sakai ghi là nộp file " crazy2011.scala " còn trong thư mục src thì có file " Crazy2011.scala" . Em cảm ơn.Tên file cần nộp. Nhưng mình sai thì sẽ có bắt bẻ đấy :pBooleanLiteral _Trung_Than_Thong  wrote: 1. Giờ mới phát hiện cái booleanLiteral chưa hiện thực và hiện thực thì gặp lỗi.hix. Vì giá trị boolean chỉ có true hoặc false (cái này token mình đâu có kiểm tra trong regex). def boolLiteral: Parser[BooleanLiteralPT] = elem("boolean", _.isInstanceOf[lexical.BooleanLit]) ^^ { a => new BooleanLiteralPT(a.chars) } 2. cái tringLiteral của thầy viết trả về kiểu string => như vậy giả sử mình đặt 1 kiểu LiteralPT thì nó báo lỗi vì string k thuộc kiểu này: def literal: Parser[LiteralPT] = intLiteral | stringLiteral .... (cái này dùng để nhận dữ liệu cho array chẳng hạn) Không thật sự hiểu rõ lắm định nghĩa các kiểu dữ liệu này có từ khóa như real, int, string đâu có ảnh hưởng. Mong mọi người giúp đỡ 1. Bạn làm một cách đơn giản. booleanLiteral có 2 trường hợp là true và false . Vậy hãy parse 2 trường hợp đó thôi. Đừng để code mẫu của những literal kia làm ảnh hưởng. 2. Bạn sửa sao cho stringLiteral thuộc kiểu StringLiteralPT hoặc một cách nào đó khác!Re: giúp đỡ phần khai báo array @Scala ^^: bạn thử xóa dòng màu đỏ đi xem sao! Edit: xóa thêm dấu { và } nữa :D Edit: xóa thêm dấu ^^ luôn :pRe: giúp đỡ phần khai báo array Mình không có code phần def arrayLiteral của bạn nên cũng không chắc. Có thể input bạn ghi thiếu "const b =...Re: giúp đỡ phần khai báo array Chắc do phần constDec bạn chưa bổ sung thêm trường hợp arrayLiteral. Hoặc phần oneDec bạn chưa bổ sung constDec. Hoặc bạn chưa hiện thực BooleanLiteral thành công. ... Test: const b = [1];Re: giúp đỡ phần khai báo array Không có chi ^^Re: giúp đỡ phần khai báo array chỗ varDec, minh có thể khai báo là var a,b,c: real; nhưng trong code thì def varDec: Parser[List[VarDecPT]] = ("var" ~> ident <~ ":") ~ (varType <~ ";") tức là chỉ cho 1 variable mình sửa lai ident thành identlst như thế này def varDec: Parser[List[VarDecPT]] = ("var" ~> identlst <~ ":") ~ (varType <~ ";") ^^ { case a ~ b => { List(new VarDecPT(new IdPT(a), b)) } } def identlst: Parser[IdPT] = repsep(ident,",") thì bị lỗi dòng màu đỏ.Re: giúp đỡ phần khai báo array def varDec: Parser[List[VarDecPT]] = ("var" ~> identlst <~ ":") ~ (varType <~ ";") ^^ { case a ~ b => { List(new VarDecPT(new IdPT(a), b)) } } def identlst: Parser[List[IdPT]] = repsep(ident,",") //loi: type mismatch; found : CrazyParser.this.Parser[String] required: CrazyParser.this.Parser[IdPT] mình sửa lại thế thì nó báo lỗi 2 dòng kia lun hixRe: giúp đỡ phần khai báo array def identlst: Parser[List[IdPT]] = repsep(ident,",")Một số câu hỏi về array Re:1 số thắc mắc  A program in Crazy consists of many declarations which are variable, constant, procedure and function declarations. Nếu không có hoặc chỉ có một declaration thì sao? :D Trường hợp chỉ có một declaration: có test mẫu và đáp án mẫu rồi => không cần lo. Trường hợp không có gì cả (file input trống trơn): theo mình nên để parse được. Output là []. Vì nếu đáp án là không parse được thì đáp án đó mâu thuẫn với test mẫu rồi.String Literal Nếu giữ nguyên chỗ def const thì sẽ có một số trường hợp đáng chú ý sau: Trường hợp 1: Input: const f = '"'; // dấu nháy đơn ' rồi đến dấu nháy kép " rồi đến dấu nháy đơn '. const g = 'a"'; //dấu nháy đơn ' rồi đến a rồi đến dấu nháy kép " rồi đến dấu nháy đơn. Output: [const(f,"),const(g,a"")] hằng string ở biến g đã bị nhân đôi dấu nháy kép trong khi hằng string ở biến f thì không. Các dấu nháy kép đều bị nhân đôi trừ dấu đứng ở đầu string. => không thống nhất. Ví dụ tương tự: const h = '"a"'; => [const(h,"a"")] Đồng ý là có những chỗ trong source mẫu cần phải sửa, nhưng đặc tả không nói về trường hợp trên. Mong thầy nói rõ: Dấu nháy kép " trong hằng String có phải nhân đôi không, nhân đôi ở những vị trí nào? Em cảm ơn.Re:String Literal Trường hợp 2: Input: const c = '''''a'''''; //mỗi bên a có 5 dấu nháy đơn ' Output: [const(c,'a')] Lẽ ra nên là [const(c,''a'')] Những vấn đề trên không nằm ở thiết kết ngôn ngữ (không phụ thuộc mức độ Crazy) mà nằm ở phần hiện thực ngôn ngữ (parseTree). Nếu giữ nguyên như bây giờ thì sau khi parse xong: const c = '''''a'''''; const d = '''a'''; const x = '"a'; const y = 'a"'; dựa vào parseTree để xử lý tiếp các phần sau ta sẽ có: assert(c == d) => ok assert(length(x) == length(y)) => NOT ok Trường hợp 3: Input: const c = ''; Output: ???Re:String Literal Vo Thanh Hung wrote: 2. Rất nhiều câu hỏi do các em không đọc kỹ đặc tả 3. Các em phụ thuộc vào code mẫu quá nhiều 4. Lab là lab còn asignment là assignment, tôi không nhớ có lần nào nói rằng phải thay ' ' thành ' và " thành "", đặc tả không có cái đó Thưa thầy, Em còn thắc mắc về phần sau: nếu đọc kỹ đặc tả ta sẽ thấy " A program in Crazy consists of many declarations which are variable, constant, procedure and function declarations." Em không biết phần gạch chân nên hiểu theo nghĩa nào? Nếu hiểu thông thường sẽ không parse thành công trường hợp input rỗng. Vì input rỗng sẽ không có declaration nào cả, như vậy là sai ngay từ chữ consists . Mong thầy tránh testcase như vậy ạ! Và dĩ nhiên chúng em sẽ không có thắc mắc, cứ theo đặc tả mà làm, nếu như từ trước giờ đặc tả chưa từng có ý nào phải chỉnh sửa lại!