Re:Nộp bài cho rồi OK đồng ý. Mình cũng nộp bài luôn đây. Ngày mai con đi GSC nữa.Re:Scope của biến global??? nhan nguyen van wrote: Most closed nested rule: For every applied occurrence (i.e., use) of an identifier I in a block A, there must be a corresponding declaration of I. The declaration is in a block that is smallest enclosing the applied occurrence of I. Due to the above rule, the scope of a declaration excludes the scope of another declaration using the same name that is inside an inner block. = Tầm vực của một định nghĩa không bao gồm tầm vực của định nghĩa khác cùng tên bên trong một block. Ví dụ: function demo():real; begin return 0; end; procedure main(); begin var demo: real; => Chổ này không thấy hàm demo nữa. end; Chỗ này bạn giải thích rất đúng, mình cũng có cùng cách hiểu như vậy là hàm demo sẽ bị che => báo lỗiRe:GradeBook Mid Term Họ tên:Phạm Quốc Việt MSSV : 50903277Re:Element of array ! line 7:14: unexpected token: `const' Cac ban oi vay la van chua xac dinh duoc la truy xuat phan tu mang rong hay khong rong a`.Re:Element of array ! T.D.N  wrote: Mai Hoa Đạo  wrote: line 7:14: unexpected token: `const' Cac ban oi vay la van chua xac dinh duoc la truy xuat phan tu mang rong hay khong rong a`. Bạn phải bỏ 2 cái dấu ở 2 đầu chứ. Trong phần notice có ví dụ tương tự cho kí tự ] mà (`]' bỏ 2 dấu ở 2 đầu thành ]) Mai Hoa Đạo  wrote: Mình cũng dùng if-else để thể hiện nhưng mà không hiểu bị lỗi gì. Nếu chỉ if rồi else thì không có lỗi. Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là "type missmatch; found: Unit required: String". Các bạn giúp mình với. Hix. Mình vẫn chưa sửa được lỗi này. Hiện tại mình chỉ xài dc có 1 cặp if-else nên chưa thể hiện dc hết lỗi.Re:Element of array ! line 7:14: unexpected token: const Mừng quá! Mình làm được rồi. Cảm ơn bạn @T.N.D nhiều lắm. Thì ra Scala cũng crazy không kém. ^^Re:Các bạn cho mình hỏi về cái def Show tý nhé ! Qui Pham Xuan wrote: Gợi ý tí:Cái def show bạn dựa vào hàm clean() trong TestToken ấy. Để in token thì dùng next.first..... nhé !!! Ở đây có thểdùng if...else... sẽ ra đúng theo mọi trường hợp báo lỗi theo yêu cầu đề. Good luck!!! Mình cũng dùng if-else để thể hiện nhưng mà không hiểu bị lỗi gì. Nếu chỉ if rồi else thì không có lỗi. Còn nếu if - else if - else thì nó báo lỗi ở dòng else if là "type missmatch; found: Unit required: String". Các bạn giúp mình với.Re:1 thắc mắc cần đính chính! [proc(a,[],[assign(a,ele(b,[add(1,2),ele(c,[2])]))])]Re:cac bạn Test cái này xem. [var(y,int),var(z,int),proc(main,[],[assign(y,1),call(writeRealLn,[call(foo,[y])])]),const(x,1.2e3),func(foo,[par(p,int)],float,[return(times(p,x))])]Re:cac bạn Test cái này xem. theo mình hiểu là: writeRealLn(foo(y)); là một procedure. Và chỗ này là một lời gọi hàm ( CallStmtPT)Re:cac bạn Test cái này xem. thêm 1 test nữa các cậu ra ntn vậy? var a: array[5] of integer; // global variable procedure fill(x:array[5] of integer); begin var a:real; var x:real; a:=5.9; init(x); end; procedure init(x:array[5] of integer); begin var i:integer; //block variable i:=0; x[i]:=a[i]; // a is global var. end; procedure main(); begin fill(a); end; của tớ nó ra line 13:3: unexpected token: i trong kai ass này mình có làm cái golbal vs kai block ko mấy cậu???? còn chổ where <lefthandside> is a variable or an element of an array vậy an element of an array nó cho kiểu INT thôi đúng ko? hay còn chấp nhận kiểu String nữa???Re:cac bạn Test cái này xem. [var(a,arr([5],int)),proc(fill,[par(x,arr([5],int))],[var(a,float),var(x,float),assign(a,5.9),call(init,[x])]),proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[i]),ele(a,[i]))]),proc(main,[],[call(fill,[a])])] cái i đó là 1 expr( variable) đó bạn, ko phải String đâu. x[i] và a[i] là element nên ko lỗi j cả. cái element nó định nghĩa chỗ toán tử [ ] đó bạnRe:cac bạn Test cái này xem. [var(a,arr([5],int)),proc(fill,[par(x,arr([5],int))],[var(a,float),var(x,float),assign(a,5.9),call(init,[x])]),proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[i]),ele(a,[i]))]),proc(main,[],[call(fill,[a])])]Re:cac bạn Test cái này xem. uh.đúng rồi...mìh mới check lại :D...cho phép NullRe:cac bạn Test cái này xem. thêm 1 test nào:D:D: procedure init(x:array[5] of integer); begin var i:integer; //block variable i:=0; x[true]:=a[i]; // a is global var. end;Điểm Course_Grade Thưa thầy Tân Em là Phạm Quốc Việt MSSV: 50903277 Sau khi em tự tính điểm từ các thành phần của em xong thì được 7.29. Nhưng mà trong Course_Grade của thầy em chỉ được 7.2. Vậy có phải điểm trên AAO của em sẽ bị giảm xuống còn 7.0 không vậy thầy. Nếu thật như vậy thì em hơi buồn vì 7.29 rất gần với 7.3. Mong thầy xem xét. Em cảm ơn thầy.Trường hợp break và continue Thầy Hưng ơi tuy thầy nói trong assignment 1 này chưa xét đến break và continue không dc nằm ngoài loop và while. Nhưng nếu em đã hiện thực luôn thì có tính là bị sai không vậy thầy. Trong trường hợp này em mong là testcase sẽ né đc mâu thuẫn này. input: procedure main(); begin while 1 do begin end break; end; output [proc(main,[],[while(1,[]),break(null)])] hoặc line 4:2: unexpected token: breakRe:Trường hợp break và continue Còn một trường hợp chưa thống nhất nữa là truy xuất mảng rỗng Khi khai báo mãng rỗng thì chắc chắn là sai, nhưng khi truy xuất mảng rỗng thì có một số bạn truy xuất dc va một số bạn không truy xuất dc. input procedure main(); begin a[]:=0; end; output [proc(main,[],[assign(a,0)])] hoặc line 3:4: unexpected token: ]Re:Trường hợp break và continue Mong thầy thống nhất lại hoặc testcase sẽ không rơi vào các trường hợp trên. Cảm ơn thầy.Re:định nghĩa path of the execution of the function? Mình có một cách hiểu về execution path như thế này muốn chia sẻ cùng bạn: - execution path là đường thực thi của chương trình mà từ lúc chương trình bắt đầu đi vào và cho đến khi đi hết đường thực thi đó thì cũng là lúc kết thúc chương trình. Trong một chương trình thì có thể có một hoặc nhiều execution path. vd: -Các execution path này đôi khi chồng lấn lẫn nhau ở một số bộ phận. function example(a:integer) : real; begin var x: integer; x:= 3; if ((a+x) > 10) then a:=0; else a:=1; loop(a) do begin a:=0; return a; end return a; end; - Đôi khi phân định rõ ràng function example(a:real):real; begin if (a > 3) then return 0; else return 1 end;Re:định nghĩa path of the execution of the function? có 1 đường bạn. Đường vào là if .... , sau khi hết đường đó thì cũng là lúc kết thúc hàm func.Re:Testcase cho stage 2 vd:= not not not not 4 ; Các bạn cho mình hỏi xài not như vậy là not có kết hợp phải rồi phải không. Nhưng ma trong đề thì mình thấy not không có kêt hợp nào cả. Có phải nên sửa lại là: vd: = not (not (not (not 4)));Re:Testcase cho stage 2 Bạn @vanhoa ơi cho mình hỏi link ở đầu topic là testcase + testsolution mới nhất phải không bạnRe:Testcase cho stage 2 Mình làm theo trường hợp truy xuất mãng rỗng dc vì trong EleExprPT thì exprs: List[ExprPT] có thể null dc. Và các phần tử trong List[ExprPT] thì không thể null dc, nhưng mà List[ExprPT] thì có thể null dc.Re:Testcase cho stage 2 Các bạn ơi cho mình hỏi input: const g = true; thì kết quả là: const(g,true) hay const(g, ' true ' ) Cảm ơnRe:Testcase cho stage 2 Tran Quoc Anh wrote: Mai Hoa Đạo  wrote: Các bạn ơi cho mình hỏi input: const g = true; thì kết quả là: const(g,true) hay const(g, ' true ' ) Cảm ơn Theo test case của thầy thì là const(g,true) Cam on banRe:Testcase cho stage 2 Cho mình hỏi là xuất ra lỗi EOF hay <eof> vậy ? Cảm ơn.Re:Testcase cho stage 2 procedure main(); begin a[]:=0; end; Testcase 31. Hòa ơi bạn làm theo trường hợp ko truy xuất mãng rỗng dc hả. Trường hợp này mình parse dc vì mình thấy trong EleExprPT cho phép List[ExprPT] null. Và mình xem như a[] là a vậy. Result của mình: [proc(main,[],[assign(a,0)])] Trong notice thầy chỉ nói ra trường hợp ko dc khai báo mảng rỗng thôi. var a: array [] of real; => line 1:15: unexpected token: ]Re:Testcase Kid  wrote: Mai Hoa Đạo  wrote: Test 27: mình nghĩ (1<1.0) vẫn so sánh được mà. Luật cùng kiểu chỉ có tác dụng trong phép gán thôi mà, sao lại báo lỗi nhỉ ? integer và real đúng là dc phép sử dụng phép < , tuy nhiên chúng phải cùng kiểu. ví dụ 1<2 hoặc 1.2< 2.1 However, for + - * /, their operands can be in mixed types: integer and real. ( trích đặc tả ass1) Cảm ơn bạn nhưng sau khi tui xem lại Crazy spec thì phát hiện ra rằng không có sự so sánh bằng "=" cho kiểu real. Nghĩa là kiểu real sẽ không bao giờ được đem đi so sánh "=".Re:Testcase //sorry deletedHội những người Crazy. Sau Assignment 2 kì này, bạn nào bị assignment làm cho crazy thì vào đây bùng nổ tâm sự cùng với mọi người nhé. Bản thân mình thì thật sự bị crazy rồi, làm xong rồi sửa, sửa xong rồi làm lại, làm lại rồi lại sửa, cứ thế như một vòng lạp while(true) do sửa vậy. Quả thật đúng như tên gọi của nó. Chỉ còn vài tiếng nữa thôi là chúng ta đc giải thoát rồi. Cuối cùng chúc các bạn sẽ gặt hái được thật nhiều testcase nhé.Hội những người Crazy. M.U.  wrote: vậy bạn có file main.scala để test trên cywin ko, chia sẻ mình với, mình đã đánh liều nộp đại luôn, chua test dc thế nào trên cywin nữa... sorry bạn, mình cũng không có test tren cygwin nên không có. Chắc không sao đâu, bạn yên tâm đi.Re:Testcase cuối cùng. zz Chỗ này cố tình bẫy cái def show đây mà. procedure theLastTest(henxui: boolean); begin 'identifier ab'; end;Re:Testcase cuối cùng. assignment kì này sôi nổi quá nhỉ. Số lượng topic đến hơn 1000. Bây giờ thì mọi người dc nghỉ ngơi rồi.Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!! M.U.  wrote: function testStruct(): boolean; begin loop 1 do begin a:=1; b:=2; break; end ; end; procedure main(); begin fill(a); end; line 7:4: unexpected token: ; M.U.  wrote: var a:integer ;; line 1:15: unexpected token: ;Re:Testcase cuối cùng. Sao mình resubmit quá trời mà cái này ko có gì thay đổi nhỉ. Number of resubmissions allowed: 10Khai báo đè Các bạn ơi trong cái block thứ 2 có phải là x đã bị đè rồi không ? procedure main(); begin var x: integer; begin const x = 3; end; end;Re:Khai báo đè Cảm ơn bạnRe:Type!!!! line 9:8: unexpected token: =Size Must Be Integer Các bạn ơi trong đặc tả không có nói đến thông báo lỗi này: Size Must Be Integer Mà lỗi này mình nghĩ nó nằm trong phần Expression vậy mình có nên sửa lại thành: Type Missmatch In Expression hay vẫn giữ nguyên như của thầy.Re:Size Must Be Integer àh thì ra là vậy. Cảm ơn bạnRe:câu lệnh Return  Đúng thật là assignment 2 spec ko có nói gì đến string hay array. Mình cũng có một lỗi không biết là do PT.scala hay code của mình nữa, có ai gặp lỗi này như mình chưa? procedure main(a:string); begin a:='maihoadao'; end Cứ mỗi lần mình gán một biến string thì chương trình hoàn toàn không chạy được. Ngay cả AST cũng chưa được sinh ra.Re:câu lệnh Return  Mình có một cách hiểu câu lệnh return như thế này: Cũng giống như break và continue phải nằm loop và while vậy, return phải nằm trong một function nào đó. Tuy đặc tả không nói, nhưng mình thấy return cũng có họ hàng bà con xa với break và continue vậy. ^^Re:câu lệnh Return  Kid  wrote: @mai hoa dao: bạn dùng ass1 để parser hả? sửa lại chỗ string thêm dấu " vào đầu và cuối chuỗi thử . mình sửa lại vậy và chạy dc Cảm ơn bạn @Kid. Cuối cùng nó đã chạy được.Re:Thứ tự kiểm tra procedure pleaseTellMeWhy(); // (1) begin h:=true; var h:boolean; end; -------------------------------------------------------- procedure pleaseTellMeWhy(); // (2) begin var h:real; h:=true; var h:boolean; end; Type Mismatch In Statement:assign(h,true) hay là RedeclaredVariable: h Mình có một mâu thuẫn là: (1) thì chắc chắn không báo lỗi. Vì trước khi kiểm tra phép gán StaticCheck sẽ tìm xem biến h đã được khai báo hay chưa. Nếu chưa thì báo lỗi: Undeclared Identifier: h (2) Nếu theo như cách StaticCheck kiểm tra trong đoạn chương trình (1) của mình ở trên. Thì (2) sẽ báo lỗi: Redeclared Variable: h Cuối cùng ý mình muốn nói là khi vào kiểm tra một block thì điều đầu tiên là StaticCheck sẽ làm là kiểm tra các khai báo rồi xem chúng có bị Redeclared hay không, sau đó mới kiểm tra các statement. Hay là StaticCheck kiểm tra lỗi từ trên xuống, thấy chỗ nào là bụp chỗ đó liền.Re:Thứ tự kiểm tra Còn trường hợp này thì sao? procedure why(); begin var a: array[3,3,3] of integer; a[1,8,1]:= c end; => Undeclared Identifier:<> hay Type Missmatch In Statement: <>Re:Thứ tự kiểm tra Mình hiều nhầm biến h là local var chứ không phải global var. ^^Re:Thứ tự kiểm tra Assignment này nhiều mâu thuẫn quá. Ngay cả trong gin code của thầy cũng đã có mâu thuẫn. Cách thầy checkUnique trong Program thì đi từ trên xuống, chỗ nào Redeclared thì bụp chỗ đó liền. Còn khi checkUnique trong Function hoặc Procedure thì thầy lại gom các Var lại rồi check 1 lần sau đó thì mới check đến các phần trong block. ... checkUnique(paramSymbols2 ++ varConstSyms(getVarConst(body.body), symbols)) checkBlock(body, paramSymbols2 ++ symbols, false) ...Re:định dạng output! Type Missmatch In Statement: if(1,[var(a,string),assign(a,"'ass'")])Re:string trong Assign ? Lúc đầu mình nghĩ là string thì phải tự hiểu mà thêm vào. Giờ nghe các bạn nói vậy nghĩa là nếu mình hiện thực điều mình nghĩ là hợp lý thì thật ra nó là điều vô lý trong Crazy à ?Re:Kiểu của Parameter??? Trong trường hợp này kiểu string vẫn không được chấp nhận đâu bạn. Theo mình thì kiểu string chẳng có tác dụng gì cả ngoài làm cảnh ( không gán được, không truyền tham số được).file PT.scala Xin lỗi mọi người nếu như câu hỏi của mình là spam. Thầy nói là đã up file PT.scala đã được chỉnh sửa lên lâu rồi. Nhưng thực sự mình đã tìm khắp trong mục Assignment, Module và trong Discussion rồi mà vẫn không thấy. Bạn nào biết thầy đã up ở đâu xin chỉ giúp mình, mình đang cần cái PT.scala đó để test. Xin cảm ơn.Re:file PT.scala Cảm ơn bạnVắng TA Trong assignment này còn nhiều mâu thuẫn đang chờ thầy giải quyết. Nhưng sao gần đến deadline rồi mà vẫn không thấy thầy trả lời. Mong thầy sẽ sớm xuất hiện để giải quyết các mâu thuẫn của chúng em.Re:Return statement! Một function phải có ít nhất một return trong các execution path. Nhưng một return không bắt buộc phải nằm trong 1 function. Vì vậy không báo lỗi.Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k? same size of each dimension => báo lỗi bạn.Re:khai báo a: array[4] --> gọi a[1000] Lỗi hay k? Cảm ơn các bạn. Do mình hiểu sai đặc tả nên làm vậy. Thanks mọi ngườiRe:Function Not Return Thưa thầy Hưng chúng em cần thầy xác nhận vấn đề này: Nếu return không nằm trong 1 function nào đó thì: 1. Báo lỗi: Type Missmatch In Statement:<statement> 2. Báo lỗi: Return Must Be In Function 3. Bỏ qua, không kiểm tra.Hỏi về Array Constant Van Persie wrote: còn trường hợp [[1;2];3;true] có parse thành công không? và nếu em xử lý chuỗi đó luôn (báo lỗi) thì có bị sai không? Em cung co cung cau hoi nhu ban nay.Re:Mấy bạn cho mình hỏi lỗi này Vấn đề 2 của bạn có một số mâu thuẫn: 1. Hàm mũ là kết hợp phải, mà bạn để kết hợp trái do phép lặp ở bên phải => đem lặp qua bên trái expr 2. case a ~ lst => (a :\ lst) => case lst ~ a => (lst :\ a) 3. case (x, "^" ~ y) => new ExponentExprPT(x, y) => case (x ~ "^", y) => new ExponentExprPT(x, y) Bạn thử xem sao.Re:Mấy bạn cho mình hỏi lỗi này case a ~ lst => (a :\ lst) => case lst ~ a => (lst :\ a) 3.Re:Hỏi về break và continue @Tan Phat: thầy Tân nói là không kt phạm vi break và continueRe:Vài Question mong mọi người giúp đỡ( rất gấp) Guest User wrote: Moi nguoi giup minh voi, khi minh khai bao : const a = [ ;  (noi chung la rerserved word hay delimiters) thi deu parse thanh cong. Minh khong hieu sao nua !!! Đây là phần khai báo const. Mình thấy đến chỗ dấu [ mà bạn vẫn parse dc, thì mình nghi là do cách parse arrayLiteral của bạn. Bạn kiểm tra lại cách bạn nhận dạng arrayLiteral . Đây là cách nhận dạng của mình: ("[" ~> lstliteral <~ "]") Trong đó lstliteral là một danh sách List[LiteralPT] . Các LiteralPT trong danh sách đó gồm có: intLiteral | realLiteral | stringLiteral | boolLiteral | arrayLiteral Good luck !1 số thắc mắc  Em yêu Scala ♥♥♥ wrote: Nếu nói tự phân biệt thì ai cũng phân biệt được nhưng ko phải ai cũng giống nhau :) Like 1+Re:1 số thắc mắc  Thanh Pham Minh wrote: A program in Crazy consists of many declarations which are variable, constant, procedure and function declarations. Nếu không có hoặc chỉ có một declaration thì sao? :D Trường hợp chỉ có một declaration: có test mẫu và đáp án mẫu rồi => không cần lo. Trường hợp không có gì cả (file input trống trơn): theo mình nên để parse được. Output là []. Vì nếu đáp án là không parse được thì đáp án đó mâu thuẫn với test mẫu rồi. Đồng ý với bạn. Với input trống trơn thì mình ra output là: []Re:String Literal Em cung co thac mac ve stringLiteral nhu trenRe:access Array Element???? line 3:15: unexpected token: [