cách xử lý integer, real, boolean, string Mý bạn có thể cho mình hướng xử lý mý cái này dc ko, mình cám ơn,cách xử lý integer, real, boolean, string tran ngoc duc wrote: M.U.  wrote: Mý bạn có thể cho mình hướng xử lý mý cái này dc ko, mình cám ơn, 1. Kiểm tra kiểu nào được thao tác tren phép toán nào.' def KiemTraKieu1(op: string, expr: Expr){ nếu op == "bnot" thì expr fai là boolean ... } 2. Kiểm tra ứng với kiểu đó, kết quả trả về của phép toán là ji boolean and boolean => boolean cám ơn bạn nhìuTestCase này mình ko hiểu ? Test44 của bạn vanhoa như sau: proceduremain(); begin vararrVar:array[2]ofstring; arrVar:=['1';'2']; arrVar[1]:='13'; end; [proc(main,[],[var(arrVar,arr([2],string)),assign(arrVar,array([string("'1'"),string("'2'")])),assign(ele(arrVar,[1]),string("'13'"))])] Program(List(Proc(main,List(),Block(List(Var(arrVar,Arr(List(IntLit(2)),PrimitiveType(string))), Assign(Id(arrVar),ArrayLit(List(StringLit("'1'"), StringLit("'2'")))), Assign(Ele(arrVar,List(IntLit(1))), UnaryOp (string,StringLit("'13'")))))))) Mình ko hiểu cái UnaryOp, tại sao lại có và các vấn đề liên quan đến nó, mý bạn có thể giải thích giúp mình theo testcase ở trên ko, mình cám ơn rất nhiều.Re:TestCase này mình ko hiểu ? cám ơn bạn nhìuunaryop(string,StringLit("'hello'")) có tồn tại ko thầy có nói trong notice :Trả lời: xem đặc tả ngôn ngữ string không có bất cứ phép toán nào cả Trong đặc tả scala có đoạn: The keyword string is used for a string type. A string constant can be assigned to a variable in an assignment statement, constant definition or be passed to a parameter. There is no operation on this type. vậy thì trường hợpunaryop(string,StringLit("'hello'")) có tồn tại ko ? Mình vẫn chưa hiểu hết về String cho lắm, mý bạn có thể nói rõ thêm String có thể dc phép làm gì nữa hay ko :( mình cám ơn :( Vậy còn lúc truyền par thì sao >"< Cám ơn mọi người. Sắp xong ùi, cố lên >"<Re:cac bạn Test cái này xem. Trần Gia Lạc wrote: Scala ^^  wrote: cai nay se bao loi j moi nguoi const a=['a']; line 1:10: unexpected token: ' phai k? cái này mình lại parse thành công [proc(init,[par(x,arr([5],int))],[var(i,int),assign(i,0),assign(ele(x,[true]),ele(a,[i]))]),const(a,[a])] bộ arrayLiteral không nhận string sao các bạn The elements may be integer, real, boolean or array constant. Spec ghi rõ là ko có string rồi bạn.Re:cac bạn Test cái này xem. Dream  wrote: Scala ^^  wrote: test thu cai nay no bao loi sao may ban const a=aba[1]; minh moi sua lai, const a=['a']; se bao loi lun cai 'a' Của mình là: line 1:9: unexpected token: aba me tooMọi người cho mình hỏi về xuất chuỗi const a='a'; cấu trúc PT sinh ra là: const(a, ' a ' ) vậy làm sao để nó hiện ra dc cái dấu nháy đó vậy. Cám ơn mọi người.Re:Mọi người cho mình hỏi về xuất chuỗi Guest User wrote: xoa ham substring o def const di cám ơn bạn, mình làm dc rùi ^^Re:1 thắc mắc cần đính chính! Rec4rx  wrote: [proc(a,[],[assign(a,ele(b,[add(1,2),ele(c,[2])]))])] me tooRe:Điểm thi cuối kì mừng quá, pass dc môn này rồi T___TĐiểm thi cuối kì Christian Enzo wrote: Tân Trần Vĩnh wrote: Tôi đã phổ biến từ đầu học kỳ và công khai trên website này từ đầu năm rồi đó. Nếu em cần chi tiết hơn nữa thì đây. Lab+tut: 10% Assignment 1 - Stage 1: 7.5% Assignment 1 - Stage 2: 7.5% Assignment 2: 15% Mid-term: 20% End-term: 40% Em nghe thầy Hùng nói, Ass 1 : stage 1 chiếm 0.25% còn stage 2 là 0.75%. Sao giờ lại đổi thành 50& - 50% vậy thầy :D tỷ lệ thầy Hùng đưa ra hợp lý hơn, vì trọng lượng stage 1 và stage 2 chênh lệch nhau rất nhìu, với lại làm stage 2 dc sửa lại những gì của stage 1 chưa hoàn chỉnhRe:Phân biệt SUB và NOT thanks mấy bạn, fix dc thêm lỗi này.Re:Trường hợp break và continue procedure main(); begin while 1 do begin end break; end; vậy trường hợp này báo lỗi hay pars ra dc vậy, mình làm ra báo lỗi line 4:5: unexpected token: breakRe:Trường hợp break và continue BT Lớn wrote: M.U.  wrote: procedure main(); begin while 1 do begin end break; end; vậy trường hợp này báo lỗi hay pars ra dc vậy, mình làm ra báo lỗi line 4:5: unexpected token: break par đc chứ bạn... cám ơn bạn, do input thiếu dấu ; sau end nên nó báo lỗi :D pars dc rùi, tắt máy đi ngủ, thí điểm lab ngày mai roài T__TGán String thế này sẽ output thế nào? procedure main(); begin var a: string; const strConst='hello '' world'; a := '2' + strConst; end; lỗi sẽ là string addition hay là assigment vậy mọi người? Mình đoán là string addition. Cám ơn mọi người.Re:Gán String thế này sẽ output thế nào? Kid  wrote: Type Mismatch In Statement: assign(a,add("'2'",strConst)) bản chất a la string thi khong duoc la LHS roi`, báo lỗi liền. nên k cần xét RHS. cám ơn bạn nhìu.Cho mình hỏi cách test trên Cygwin Mình làm ass2 này là dựa vào cái Intermediate, nhưng khi test trên cygwin thì hok có box console để mà nhập input rùi Ctrl Z, do đó input sẽ nhập vào đâu. Mình cám ơn.Re:Cho mình hỏi cách test trên Cygwin ai giúp mình với :((Re:Testcase proceduremain(); begin vara:boolean; a:=(1+2*3.4)=5.0; a:=1=2; a:=1.2=2.2; a:=1=2.2; a:=(1<2)and(2<3); a:=1<2<3; end; tại sao lại báo lỗi dòng này vậy a:=(1+2*3.4)=5.0; ??? Cám ơnHội những người Crazy. Mai Hoa Đạo  wrote: Sau Assignment 2 kì này, bạn nào bị assignment làm cho crazy thì vào đây bùng nổ tâm sự cùng với mọi người nhé. Bản thân mình thì thật sự bị crazy rồi, quả thật đúng như tên gọi của nó. Chỉ còn vài tiếng nữa thôi là chúng ta đc giải thoát rồi. Cuối cùng chúc các bạn sẽ gặt hái được thật nhiều testcase nhé. vậy bạn có file main.scala để test trên cywin ko, chia sẻ mình với, mình đã đánh liều nộp đại luôn, chua test dc thế nào trên cywin nữa...Giúp mình xử lý trường hợp này với  Lions wrote: procedure main(); begin a:=1 +- (2); a:=1 *- (2); end; Chỗ "+-" liên tiếp xử lý sao vậy các bạn? kết quả nè bạn [proc(main,[],[assign(a,add(1,sub(2))),assign(a,times(1,sub(2)))])]Re:Giúp mình xử lý trường hợp này với  Lions wrote: Mình viết thế này def expr1: Parser[ExprPT] = expr2~rep(("+" | "-") ~ expr2) ^^ { case a ~ lst => (a /: lst) { case (x,"+" ~ y) => new AddExprPT(x, y) case (x,"-" ~ y) => new SubExprPT(x, y) } } nó chỉ xử lý đượca:=1 + 2; :( cái toán tử dấu âm: - ở đây bạn cho độ ưu tiên thấp hơn +|-, và dùng sub 1 ngôi, ví dụ cho bạn dễ hiểu, mình chỉ ví dụ thôi, vì còn độ ưu tiên khác nữa như nhân chia ... rồi mới đến số âm (dấu - 1 ngôi) def expr1: Parser[ExprPT] = expr2~rep(("+" | "-") ~ expr2) ^^ { case a ~ lst => (a /: lst) { case (x,"+" ~ y) => new AddExprPT(x, y) case (x,"-" ~ y) => new SubExprPT(x, y) } } def expr2: Parser[ExprPT] = rep("-") ~ expr3 ^^ { case lst ~ a => (lst :\ a) { case ("-", a) => new SubExprPT(a) } } | expr3 Cái này chỉ mang tính chất minh họa, để parse dc cái input trên thôi nhé, bạn bám theo nó là die rất nhìu trường hợp đóRe:Giúp mình xử lý trường hợp này với  free_love  wrote: [proc(main,[],[assign(a,add(1,bnot(2))),assign(a,times(1,bnot(2)))])] trường hợp -2 ở đây ko phài là not đâu bạn, thầy Hùng đã notice roài SubExprPT sử dụng cho toán tử trừ, bao gồm cả 1 ngôi vd: -2, hay 2 ngôi vd: 2-3Re:Gấp gấp, các bạn giúp mình với, đây là code mình bị lỗi giải thuật chỗ nào vậy? cái phép toán not | - bạn lặp lại nhìu lần nhưng ở hàm bạn viết thì chỉ tồn tại hay ko, ko thể hiện việc lặp đi lặp lại nên die ngay cái not thứ 2Re:Gấp gấp, các bạn giúp mình với, đây là code mình bị lỗi giải thuật chỗ nào vậy? baran  wrote: pan co the goi y them cho minh dc ko :) thay opt bằng repthem test cho may pro thu suc ! [proc(main,[],[call(kingoff,[call(foo,[call(fal,[call(li,[ele(lee,[add(1,ele(f,[a]))])])])])]),assign(a,ele(b,[call(f,[ele(c,[i])])]))])]Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!! function testStruct(): boolean; begin loop 1 do begin a:=1; b:=2; break; end ; end; procedure main(); begin fill(a); end; có dấu ; ngay sau end của loop Việc ko có dấu ; parse dc thì ko nói gì, nhưng việc có dấu ; này ko bít paser dc ko ta còn trường hợp này: var a:integer ;; ko bít parse dc ko Thanks all.Re:Testcase cuối cùng. thanks bạn testcase này, mém tý nữa die lun sửa cái này, dính chuỗi khác, thui potay :<Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!! free_love  wrote: co dau ; ko parse ban ah ; = ,có cáiđó là kết thúc 1 cấu trúc gọi từ program xuống,nhưng beginở trên vẫn chưa có ead lên báo lỗi ; bạn nói trường hợp 1 hay 2?Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!! trường hợp 1 có thể hiểu dc do trong statement thì ko có ; sau end Nhưng còn trường hợp 2, khai báo, và kết thúc bằng 1 loạt dấu ;Re:Gấp gấp :: Mấy bạn cho hỏi trường hợp này Parse dc ko mấy bạn !!! free_love  wrote: trường hợp 2 cũng dễ hiểu thôi...đấu ;đầu tiên là kết thúc của cấu trúc var...khi bắtđầu cấu trúc mới gặp ngay ; nữa mà ko có cấu trúc nào như vậy lên báo lỗi thôi...thân thanks bạn, vì mình ko thấy đặc tả ghi rõ về ; , mình nghĩ trong các ngôn ngữ khác thì dấu ; sau khai báo bao nhiu lần cũng dc nên hỏi cho chắc cú.Re:Làm sao để chạy thử test??? mình add file PT của ass1 vào, chạy file main hay làm sao vậy bạn.Re:Làm sao để chạy thử test??? Rec4rx  wrote: mình lấy cái input như là assignment1 á, rồi parse ra được cái output (out put này của Assignment 1 nè). Rồi sau đó chạy file main.scala , nhập input vào console ở dưới, nhần Ctrl + Z  ..... cám ơn Rec4rx nhìu nha.Chương trình như vậy output thế nào vậy? var a: array[5] of integer; // global variable procedure fill(x:array[5] of integer); begin var a:real; // superseding global variable a var x:real; // WRONG because parameter x has the same name a:=5.9; init(x); end; procedure init(x:array[5] of integer); begin var i:integer; //block variable i:=0; x[i]:=a[i]; // a is global var. end; procedure main(); begin fill(a); end; Chương trình này trong mục 5 của file đặc tả scala, ở đây mình thấy ở procedure fill sử dụng hàm init, nhưng procedure init lại dc khai báo sau procedure fill. Như vậy output sẽ thế nào vậy? Cám ơn mọi người.Re:Chương trình như vậy output thế nào vậy? ai giúp mình trả lời nhanh nhanh :( mình hy vọng cái program trên sai cho đỡ phiền =.=Re:ai cứu với hix hix... def funcDec: Parser[FuncDecPT] = ("function" ~> ident) ~("(" ~> paramList <~ ")") ~ (":" ~> varType <~ ";") ~ ( ";" ~ > blockStmt <~ ";") ^^ { case a ~ b ~ c ~ d => new FuncDecPT(new IdPT(a), b, c, d) } chỗ này bạn sai: xóa cái phần mình tô màu đỏ đi.Re:Cách compile các file Thanks all.Re:Cách compile các file MFC.Maximus wrote: cho mình hỏi, mình đã làm đúng như trên, khi gõ "scalac TestToken.scala" thì nó báo lỗi not found : type CrazyLexical val lexical = new CrazyLexical ai biết cách sửa không :D đầu tiên bạn scalac *.scala sau đó gõ scala TestToken là xong.Hỏi về Array Constant kid_ chem_ gio wrote: anh hùng cho em hỏi: const x = [[1;2];[3];[4]]; trong đề ghi là kiểu các phần tử trong mảng phải giống nhau.[1;2] =/=[3] như vậy sao parse thành công được mình nghĩ là là trong array [[1;2];[3];[4]] gồm 3 kiểu array là [1,2] , và 2 array 1 phần tử là [3] và [4] nên sẽ parse dcRe:Hỏi về Array Constant ra nguyên cái [[1;2];[3];[4]] luôn bạnConst Array này nhận được ko vậy mọi người [[1;2];[true;false]] parse dc ko vậy mọi người Cám ơn mọi người ^^Mấy bạn cho mình hỏi lỗi này Minh làm như vậy: def oneDec: Parser[List[SubtinePT]] = varDec | funcDec | constDec | procDec ^^ { case a => List(a) } nhưng lại báo lỗi, Multiple markers at this line - type mismatch; found : CrazyParser.this.Parser[ScalaObject] required: CrazyParser.this.Parser[List[SubtinePT]] - type mismatch; found : CrazyParser.this.Parser[ScalaObject] required: CrazyParser.this.Parser[List[SubtinePT]] nên mình ko thể nào tạo dẫn xuất ra dc khai báo hàm và khai báo constant để kiểm tra hàm mình viết. Ko biết mình nên làm thế nào đây, mong mấy bạn có thể giúp đỡ mình. Mình cám ơn. ///////////////// Một vấn đề nữa: code hàm mũ của mình cần kết hợp phải, nhưng mình code như vậy def expr_pow: Parser[ExprPT] = expr ~ rep(("^") ~ expr) ^^ { case a ~ lst => (a :\ lst) { case (x, "^" ~ y) => new ExponentExprPT(x, y) } } báo lỗivalue :\ is not a member of ExprPT mình ko thể hiện dc tính kết hợp phải, mong mấy bạn chỉ giúp. //////////////// còn về - hoặc not, mình viết như vậy def expr_not: Parser[ExprPT] = (rep("-"|"not") ~ expr1) ^^ { case ("-" ~ a) => new BnotExprPT(a) case ("not" ~ a) => new BnotExprPT(a) } cái này nói thiệt là mình viết đại :( ai biết chỉ giúp mình với, :( Mình cám ơn rất nhìu ^^Mấy bạn cho mình hỏi lỗi này Minh Nguyen wrote: trong sakai có bạn hỏi cái này rồi mà bạn def oneDec: Parser[List[SubtinePT]] = varDec |( funcDec | constDec | procDec ) ^^ { case a => List(a) } Sửa lại giống trên cám ơn bạn rất nhìu, mình sữa lại được rồi. Còn vấn đề 2 và 3, mong mấy bạn chỉ giúp ^^Re:Mấy bạn cho mình hỏi lỗi này coffee cafe wrote: vấn đề 2 bạn sửa lại dấu(a :\ lst) =>>>>> (a /: lst) ủa, mình nghĩ /: là tính kết hợp trái mà, mà hàm ^ thì kêu mình kết hợp phải mà bạn. Có gì sai monh mọi người chỉ thêm :(Re:Mấy bạn cho mình hỏi lỗi này Mai Hoa Đạo  wrote: Vấn đề 2 của bạn có một số mâu thuẫn: 1. Hàm mũ là kết hợp phải, mà bạn để kết hợp trái do phép lặp ở bên phải => đem lặp qua bên trái expr 2. case a ~ lst => (a :\ lst) => case lst ~ a => (lst :\ a) 3. case (x, "^" ~ y) => new ExponentExprPT(x, y) => case (x ~ "^", y) => new ExponentExprPT(x, y) Bạn thử xem sao. cám ơn bạn và coffee cafe nhìu nha, mình đã sửa dc vấn đề 2 ùi, còn vấn đề thứ 3, nữa, cố lên cố lên <3 <3 <3Vài Question mong mọi người giúp đỡ( rất gấp) DoomAce  wrote: Mình chỉ còn đêm nay để hoàn tất ass1 thôi, sáng mai phải về quê sớm rồi, có vài câu hỏi thôi, mong ai biết giúp mình nhé: 1.  Trong hàm def show, mình hiểu hướng để làm nhưng ko hiểu cách thức trình bày cái unexpected token sao ko đc chấp nhận: "line "+< >+":"+< >":"+" unexpected token: " + if(.....) {.....} else { .....} Có bạn nào biết sai ở đâu nhắc mình tí với, dấu + dùng ở đây có phù hợp ko? bạn DoomAce có thể chỉ rõ giúp mình phần show dc ko, mình mò hum qua đến giờ, đọc bài mấy bạn chỉ làm cũng ko dc nữa, hixx :(( nick yahoo của mình là kai_ducati hy vọng dc bạn giúp :(